DisplayStats
════════════════════════════════════════════════════════════════════════
// Stable size independent of aspect ratio
const WIDTH = min(SCREEN_SIZE.x, SCREEN_SIZE.y)

/* Array of strings computed at `DisplayStats.enter`. This is
   broken up for layout purposes, but also to avoid overloading
   the renderer with a massive, mostly-offscreen draw call.*/
let vocabulary_text_array

const scroll = make_scroll_tracker()

let bottom_bar_callback

def alternating_color():
    ++alternating_color.count
    return if alternating_color.count mod 2 then TABLE_ALT_ROW_COLOR else #FFF


/*
 - `caption`  Left column value
 - `lifetime` Center column value
 - `today`    Right column value
 - `color`    Color of the left and center values
 - `today_color` Color of the today value
*/
def draw_row(y, caption, lifetime, today, color default alternating_color(), today_color default color, today_suffix default ∅):
    const args = {font: leaderboard_font, color: color, outline: #000, x_align: "left"}
    const x = ½ SCREEN_SIZE.x
    const x_left   = x - ½ WIDTH + 6
    const x_center = x + (if today ≠ "N/A" then 29 else 62)
    const x_right  = x + ½ WIDTH - 9
    
    if caption: draw_text({…args, text: caption, pos: xy(x_left, y)})
    
    if today_suffix:
        draw_text({…args,
            pos: xy(x_right + 4, y),
            text: today_suffix,
            color: today_color})
    
    if caption and (ends_with(caption, "Word") or ends_with(caption, "Free") or ends_with(caption, "Wild")): args.font = history_font
    draw_text({…args, x_align: "right", text: lifetime, pos: xy(x_center, y)})
    if today and today ≠ "N/A": draw_text({…args, x_align: "right", text: today, pos: xy(x_right, y), color: today_color})

    return 13



def draw_trend_row(y, caption, format, lifetime, today):
    return draw_row(
        y,
        caption,
        format_number(lifetime, format),
        format_number(today, format),
        ∅, 
        if today > lifetime then HIGHLIGHT_COLOR else ∅,
        if today > lifetime then "↑" else ∅)



def draw_section_title(y, title):
    return draw_text({
        pos: xy(½ SCREEN_SIZE.x, y + 10),
        color: HIGHLIGHT_COLOR,
        outline: #000,
        font: leaderboard_font,
        text: title,
        wrap_width: WIDTH - 20,
        y_align: "top",
        x_align: "center"}).height + 20
        

        
def draw_content():
    alternating_color.count = 0
    const lifetime = player.stats.lifetime
    const today    = player.stats[today_date_string()] default make_empty_stats_entry()
    
    let y = 5
    
    y += draw_row(y, ∅, "Past", "Today", HIGHLIGHT_COLOR)
    
    const long_row_array = [
        {ability: "Longest Word Stat",   title: "Longest Word", field: "longest_text"},
        {ability: "Freestyle",           title: "Longest Free", field: "longest_freestyle_text"}]

    for ability, title, field in entry in long_row_array
    & if player.has_ability[ability]:
        const better = size(today[field]) ≥ size(lifetime[field]) and (today[field])
        y += draw_row(y, title, 
            lifetime[field],
            today[field] or "-",
            ∅,
            if better then HIGHLIGHT_COLOR else ∅,
            if better then "↑" else ∅)
    
    const best_row_array = [
        {ability: "Best Word Stat", title: "Best Word", prefix: "best_word"},
        {ability: "Freestyle",      title: "Best Free", prefix: "best_freestyle_word"},
        {ability: "Wild",           title: "Best Wild", prefix: "best_wild_word"}]
        
    for ability, title, prefix in row in best_row_array:
        if player.has_ability[ability]:
            const better = today[prefix + "_text"] and (today[prefix + "_points"] ≥ lifetime[prefix + "_points"])
            y += draw_row(y, title,
                if lifetime[prefix + "_text"] then lifetime[prefix + "_text"] + " " + lifetime[prefix + "_points"] else "",
                (if today[prefix + "_text"]then (today[prefix + "_text"] + " " + today[prefix + "_points"]) else "-"),
                ∅,
                if better then HIGHLIGHT_COLOR else ∅,
                if better then "↑" else ∅)

    const most_row_array = [
        {ability: "Most Words Stat", title: "Most Words", format: "0",        field: "most_words"},
        {ability: "High Score Stat", title: "High Score", format: "commas",   field: "best_score"}]

    for ability, title, format, field in row in most_row_array:
        if player.has_ability[ability]:
            y += draw_trend_row(y, title, format, lifetime[field], today[field])
        
    y += 10
    if player.has_ability["Award Stat"]:
        for title at i in ["Highest Score", "Best Word", "Best Rare", "Longest", "Most Words"]:
            const field = lowercase(replace(title, " ", "_"))
            y += draw_row(y, replace(title, "Highest", "High") + " Badges", format_number(lifetime.badge_count[field], "commas"), "+" + format_number(today.badge_count[field], "commas"))
    
    y += 10
    const total_row_array = [
        {ability: ∅,                        title: "XP",                field: "xp",        func: pass_through},
        {ability: "Total Words Stat",       title: "Total Words",       field: "words",     func: pass_through},
        {ability: "Discovered Words Stat",  title: "Discovered Words",  field: "word_list", func: size}]
        
    for ability, title, field, func in row in total_row_array:
        if not ability or player.has_ability[ability]:
            y += draw_row(y, title, format_number(func(lifetime[field]), "commas"), "+" + format_number(func(today[field]), "commas"))

    y += 10
    const per_row_array = [
        {ability: "Total Matches Stat", title: "Matches Played",        format: "commas",   field: "matches",     per: 1},
        {ability: "Words/Match Stat",   title: "Words/Match",           format: "0.0",      field: "words",       per: "matches"},
        {ability: "Points/Match Stat",  title: "Points/Match",          format: "0",        field: "points",      per: "matches"},
        // This stat is misleading because when the player first unlocks freestyle they have played a lot of matches.
        // However, that makes it easy to get a new personal best every day, so we compute it this way as motivation.
        {ability: "Freestyle Points/Match Stat",  title: "Freestyle Pts/Match",    format: "0",  field: "freestyle_points", per: "freestyle_matches"},
        {ability: "XP/Match Stat",      title: "XP/Match",              format: "commas",   field: "xp",          per: "matches"},
        
        {ability: "Days Played Stat",   title: "Days Played",           format: "commas",   field: "days",        per: 1},
        {ability: "Matches/Day Stat",   title: "Matches/Day",           format: "0",        field: "matches",     per: "days"},
        {ability: "XP/Day Stat",        title: "XP/Day",                format: "commas",   field: "xp",          per: "days"}]

    for ability, title, format, per, field in row in per_row_array
    & if player.has_ability[ability]:
        if title == "Days Played": y += 10
        y += draw_trend_row(y, title, format, lifetime[field] / (if per == 1 then 1 else max(lifetime[per], 1)), today[field] / (if per == 1 then per else max(today[per], 1)))

    y += draw_section_title(y, "Earned " + size(player.has_ability) + " Abilities")

    // Assumes the entries are sorted by increasing level    
    for entry at name in ABILITY_TABLE
    & if entry.description ≠ "SILENT":
        // Break before the "new ability at..." message
        if not player.has_ability[name]: y += 10
        
        const pos = xy(½ SCREEN_SIZE.x - 36, y)        

        // Icon
        const sprite = if player.has_ability[name] then evaluate_constant_expression(entry.sprite_name) else shapes.lock
        draw_disk(pos + xy(-17, 5), 7, #999)
        draw_sprite({sprite: sprite, pos: pos + xy(-17, 5), scale: 10 / sprite.size.x})
        
        // Text
        y += draw_text({
            pos: pos,
            color: if player.has_ability[name] then alternating_color() else #999,
            outline: #000,
            font: leaderboard_font,
            text: if player.has_ability[name] then name else "New ability at level " + entry.level + "!",
            wrap_width: WIDTH - 20,
            markup: true,
            y_align: "top",
            x_align: "left"}).height + 6

        if not player.has_ability[name]:
            // We're done with abilities, having shown one more
            // than earned as a preview
            break

    if player.has_ability["Discovered Words Stat"]:
        y += draw_section_title(y + 7, "Discovered " + format_number(size(lifetime.word_list) + size(today.word_list), "commas") + " Words") + 12
        for text in vocabulary_text_array:
            y += draw_text({
                pos: xy(½ (SCREEN_SIZE.x - WIDTH) + 10, y),
                color: TABLE_ALT_ROW_COLOR,
                outline: #000,
                font: history_font,
                text: text,
                wrap_width: WIDTH - 10,
                markup: true,
                y_align: "top",
                x_align: "left"}).height + 20

    return y
    

enter(_bottom_bar_callback)
────────────────────────────────────────────────────────────────────────
bottom_bar_callback = _bottom_bar_callback

player_achieve(player, "Check Stats")

scroll.scroll = 0

const vocab = keys(player.vocabulary)
sort(vocab)

// Decode and accumulate by first letter
const text_array = []
let letter = if size(vocab) then vocab[0][0] else ∅
let array = []
for word in vocab:
    if word[0] ≠ letter:
        push(text_array, array)
        array = []
        letter = word[0]
        
    let text = q_decode(word)
    if size(text) > 6:
        text = "{color:#FFF " + text + "}"
    push(array, text)

// Last one
if size(array): push(text_array, array)

// Break into max 26 strings to avoid overloading the renderer
vocabulary_text_array = []
for array in text_array:
    push(vocabulary_text_array, join(array, ", "))



frame
────────────────────────────────────────────────────────────────────────
if landscape(): draw_background_words()
draw_rect(½ SCREEN_SIZE, xy(WIDTH + 10, SCREEN_SIZE.y), #0009)

avatar_draw({avatar: player.avatar, sprite: player.avatar.sprite.x_flipped, pos: xy(½ SCREEN_SIZE.x - ½ WIDTH + 22, 15), scale: 200%})

local:
    const x = ½ SCREEN_SIZE.x - ½ WIDTH + 50
    draw_text({text: trim_spaces(player.avatar.name) + ": Level " + player.avatar.level, font: score_font, x_align: "left", pos: xy(x, 9), color: #FFF})
    draw_text({
        text: format_number(player.stats.lifetime.xp + player.stats[today_date_string()].xp, "commas") + " XP. Next level @ " + format_number(level_to_xp(player.avatar.level + 1), "commas") + " XP", 
        font: if player.avatar.level > 38 then history_font else leaderboard_font,
        x_align: "left", 
        pos: xy(x, 22), 
        color: #FFF})

preserving_transform:
    const scroll_rect = {corner: xy(0, 30), size: xy(SCREEN_SIZE.x, SCREEN_SIZE.y - 58)}
    set_clip(scroll_rect)
    set_transform(scroll_rect.corner - scroll.offset)
    scroll_tracker_update(scroll, xy(0, draw_content()), scroll_rect)

bottom_bar_callback()



