/* An npc_message is like a notification, but they are not queued and have
   an auto-cancel condition.
   
   An "NPC" is a bot with a personality who presents as a fictional character,
   vs. one impersonating a human to fill out the leaderboard. */



/* Singleton */
let _npc_message


/* A higher importance message will clear a lower importance one. This allows 
   multiple NPCs to try and comment without overriding anyone. The sound will
   be played the first time that the message is displayed. 
   
   Will close if the user clicks, presses (c), or if
   `auto_close_condition(data, game_frames_since_opened)` is truish */
def set_npc_message(avatar, text, importance default 0, play_sound_args default ∅, max_frames default ∞, auto_close_condition default ∅, data default ∅, auto_close_play_sound_args default ∅):
    if not _npc_message or _npc_message.importance < importance:
        _npc_message = {
            avatar: avatar,
            text: text,
            importance: importance,
            play_sound_args: play_sound_args,
            auto_close_play_sound_args: auto_close_play_sound_args,
            auto_close_condition: auto_close_condition,
            data: data,
            max_frames: max_frames,
            open_game_frames: game_frames}



/* Call to erase the current message. */
def clear_npc_message():
    _npc_message = ∅



/* Hook to render the npc message. */
def npc_message_hook()
& if _npc_message
& preserving_transform
& with avatar, text, open_game_frames, data, max_frames, auto_close_condition in _npc_message:
        
    // Includes the surrounding graphic
    const history_rect = get_history_rect()
    const rect = {
        corner: xy(0, 0), 
        size: xy(history_rect.size.x, 36)}
        
    set_transform(history_rect.corner + ½ xy(0, history_rect.size.y - rect.size.y - 8), ∅, 50)
    
    // Play the open sound once, erasing the property afterwards
    if _npc_message.play_sound_args:
        play_sound(_npc_message.play_sound_args)
        _npc_message.play_sound_args = ∅
    

    draw_corner_rect(rect.corner, rect.size, rgba(get_background(), 50%))
    
    // Avatar
    avatar_draw({
        avatar: avatar,
        pos: xy(avatar_sprite.sprite_size.x, rect.size.y - avatar_sprite.sprite_size.y),
        scale: 200%,
        outline: #CCC})
    
    // Inset by the border size and offset by the avatar sprite
    const bubble_rect = {
        corner: speech_bubble_sprite.sprite_size + xy(2 avatar_sprite.sprite_size.x - 2, 1), 
        size: rect.size - 2 speech_bubble_sprite.sprite_size - xy(2 avatar_sprite.sprite_size.x - 2, ¾ avatar_sprite.sprite_size.y + 2)}

    // Animate opening the message
    bubble_rect.size.x = round(lerp(32, bubble_rect.size.x, min(100%, (game_frames - open_game_frames) / 10)))
    
    // Speech bubble
    draw_sprite_corner_rect(speech_bubble_sprite.center, bubble_rect.corner, bubble_rect.size)

    // Clip the message to the speech bubble, but only in the horizontal direction.
    // Vertically we need to extend into the region and the bubble only grows horizontally.
    set_clip(transform_ws_to_ss(xy(bubble_rect.corner.x - 8, rect.corner.y)), xy(bubble_rect.size.x + 16, rect.size.y))
    
    // The message    
    draw_text({
        font: leaderboard_font, 
        pos: bubble_rect.corner + ½ bubble_rect.size - xy(0, 1),
        text: "\"" + text + "\"",
        color: avatar.color})

    // Close prompt
    if player.using_gamepad:
        draw_text({
            font: leaderboard_font,
            pos: rect.size - xy(5, 3),
            text: joy.prompt["(c)"],
            x_align: "right",
            y_align: "bottom",
            color: #333})
    
    if (((game_frames - open_game_frames ≥ MIN_DIALOG_FRAMES) and 
         (touch.a and overlaps(touch.xy, rect)) or 
         joy.pressed_c) or 
         
        (game_frames - open_game_frames ≥ max_frames) or 
        
        (auto_close_condition and auto_close_condition(data))):
        
        play_sound(_npc_message.auto_close_play_sound_args)
            
        clear_npc_message()
    
    