/* An npc_message is like a notification, but they are not queued and have
   an auto-cancel condition.
   
   An "NPC" is a bot with a personality who presents as a fictional character,
   vs. one impersonating a human to fill out the leaderboard. */



/* Singleton */
let _npc_message


/* A higher importance message will clear a lower importance one. This allows 
   multiple NPCs to try and comment without overriding anyone. The sound will
   be played the first time that the message is displayed.
   
   Args properties:
   - `avatar`: Avatar to display with the message
   - `text`: Message text, supports markup formatting (e.g., {color:#D00 text})
   - `importance`: Priority level (default 0)
   - `play_sound_args`: Sound to play when opening (default ∅)
   - `max_time`: Maximum display time in seconds (default ∞)
   - `auto_close_condition`: Function(data) that returns truish to close (default ∅)
   - `data`: Data passed to auto_close_condition (default ∅)
   - `auto_close_play_sound_args`: Sound to play when auto-closing (default ∅)
   - `close_callback`: Function called when message is dismissed (default ∅)
   - `right`: If truish, avatar appears on right with flipped bubble (default ∅)
   
   Will close if the user clicks, presses (c), or if
   `auto_close_condition(data)` is truish. */
def set_npc_message(args):
    if not _npc_message or _npc_message.importance < args.importance:
        _npc_message = {
            avatar: args.avatar,
            text: args.text,
            importance: args.importance default 0,
            max_frames: 60 * (args.max_time default ∞),

            // Optional, can be nil
            play_sound_args: args.play_sound_args,
            auto_close_play_sound_args: args.auto_close_play_sound_args,
            auto_close_condition: args.auto_close_condition,
            data: args.data,
            close_callback: args.close_callback,
            right: args.right,

            // Not an arg
            open_game_frames: game_frames}



/* Sets a chain of messages via set_npc_message. If the first message is shown,
   then the entire chain will be shown (if no other messages intervene), 
   otherwise none will be shown.
   
   Automatically defaults `right` to true for messages with the same avatar as
   the first message, and false otherwise (unless explicitly specified as non-nil). */
def set_npc_conversation(...array):
    assert(size(array) > 1)
    
    const first_avatar = array[0].avatar

    for m < size(array):
        // Default right based on avatar match if not explicitly specified
        const right = if array[m].right == ∅ then (array[m].avatar == first_avatar) else array[m].right
        
        if m + 1 < size(array):
            // Capture this callback before we mutate the array values
            const original_close_callback = array[m].close_callback
            
            def chained_close_callback():
                if original_close_callback: original_close_callback()
                set_npc_message(array[m + 1])
            
            array[m] = {...array[m], close_callback: chained_close_callback, right: right}
        else:
            // Last message, just apply right
            array[m] = {...array[m], right: right}
    
    // Start the chain with the first message
    set_npc_message(array[0])



/* Call to erase the current message. */
def clear_npc_message():
    if _npc_message and _npc_message.close_callback:
        _npc_message.close_callback()
    _npc_message = ∅



/* Returns true if a message is currently displayed */
def npc_message_showing():
    return _npc_message != ∅



/* Hook to render the npc message. */
def npc_message_hook()
& if _npc_message
& preserving_transform
& with avatar, text, open_game_frames, data, max_frames, auto_close_condition, right in _npc_message:
        
    // Includes the surrounding graphic
    const history_rect = get_history_rect()
    const rect = {
        corner: xy(0, 0), 
        size: xy(history_rect.size.x, 64)}
        
    set_transform(history_rect.corner + ½ xy(0, history_rect.size.y - rect.size.y - 8), ∅, 50)
    
    // Play the open sound once, erasing the property afterwards
    if _npc_message.play_sound_args:
        play_sound(_npc_message.play_sound_args)
        _npc_message.play_sound_args = ∅

    draw_corner_rect(rect.corner, rect.size, rgba(get_background(), 50%))
    
    // Avatar
    const avatar_scale = 200%
    const scaled_avatar_size = avatar_scale * avatar_sprite.sprite_size
    const avatar_x = if right then (rect.size.x - ½ scaled_avatar_size.x) else (½ scaled_avatar_size.x)
    avatar_draw({
        avatar: avatar,
        pos: xy(avatar_x, rect.size.y - ½ scaled_avatar_size.y),
        scale: avatar_scale,
        outline: #CCC})
    
    // Inset by the border size and offset by the avatar sprite
    const bubble_corner_x = if right then (speech_bubble_sprite.sprite_size.x + 1) else (speech_bubble_sprite.sprite_size.x + scaled_avatar_size.x + 1)
    const bubble_rect = {
        corner: xy(bubble_corner_x, speech_bubble_sprite.sprite_size.y + 1), 
        size: rect.size - xy(2 speech_bubble_sprite.sprite_size.x, speech_bubble_sprite.sprite_size.y) - xy(scaled_avatar_size.x, ½ scaled_avatar_size.y + 2)}

    // Animate opening the message
    bubble_rect.size.x = round(lerp(32, bubble_rect.size.x, min(100%, (game_frames - open_game_frames) / 10)))
    
    // Speech bubble
    const bubble_sprite = if right then speech_bubble_sprite.center.x_flipped else speech_bubble_sprite.center
    draw_sprite_corner_rect(bubble_sprite, bubble_rect.corner, bubble_rect.size)

    // Close prompt
    if player.using_gamepad:
        draw_text({
            font: leaderboard_font,
            pos: rect.size - xy(5, 3),
            text: joy.prompt["(c)"],
            x_align: "right",
            y_align: "bottom",
            color: #333})

    // Clip the message to the speech bubble, but only in the horizontal direction.
    // Vertically we need to extend into the region and the bubble only grows horizontally.
    set_clip(transform_ws_to_ss(xy(bubble_rect.corner.x - 8, rect.corner.y)), xy(bubble_rect.size.x + 16, rect.size.y))
    
    // The message
    draw_text({
        font: leaderboard_font, 
        pos: bubble_rect.corner + ½ bubble_rect.size - xy(0, 1),
        text: "\"" + text + "\"",
        wrap_width: bubble_rect.size.x,
        color: avatar.color,
        markup: true})

    
    if (((game_frames - open_game_frames ≥ MIN_DIALOG_FRAMES) and 
         (touch.a and overlaps(touch.xy, rect)) or 
         joy.pressed_c) or 
         
        (game_frames - open_game_frames ≥ max_frames) or 
        
        (auto_close_condition and auto_close_condition(data))):
        
        if _npc_message.auto_close_play_sound_args:
            play_sound(_npc_message.auto_close_play_sound_args)
        clear_npc_message()
    
    