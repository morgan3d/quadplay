Freestyle
════════════════════════════════════════════════════════════════════════
let selection_color = TILE.CENTER_SELECTED_COLOR

/* Return the word, maybe returning a wildcard character, represented
   by the player's current `free_row` tiles */
def free_row_pattern(player):
    let pattern = ""
    
    for tile at t in player.free_row:
        pattern += tile.letter
        
    return pattern



/* Recompute `player.history.free` from `player.free_row` and return the `free_selection_color`.
   See also `player_selection_change_callback()` for the `Play` mode.
   
   Also updates player.wild_word_text and player.wild_word_points */
def player_free_selection_change_callback(player):    
    // Clean up the list for any removals
    player_remove_destroyed_freestyle_words(player)

    // Look for any additions, tracking the most points seen for sound triggers
    let max_points = -1
    let best_new_word = ∅
    let best_new_color = ∅
    
    // Find all words matching this sequence in the dictionary
    const pattern = free_row_pattern(player)
    for word in dictionary_search(pattern):
        if player.already_found[word] or player_free_contains(player, word):
            // Show that we've already seen these just-completed words by 
            // finding and emphasizing them
            player_emphasize_history_word(player, word)
        else:
            const points = score_word(word, pattern)
            const color = player_add_to_free(player, word, points)
            if points > max_points:
                max_points = points
                best_new_word = word
                best_new_color = color
                                    
    if best_new_word:
        // At least one word was added
        player_spawn_free_score_animation(player, best_new_word, best_new_color)
        play_points_sound(max_points)
        player_achieve(player, "Freestyle Word")
    
    // Check for the presence of the wild character in the pattern
    // instead of player.wild_tile.used because
    // that is future-proof against possible multiple wildcards
    const wild = contains(pattern, WILDCARD_CHARACTER)
    player.wild_word_text = if wild then q_decode(pattern) else ""

    // Choose the color based on the best selection
    player.wild_word_points = 0
    max_points = 0
    for points in entry in player.history.free:
        max_points = max(max_points, points)
        if wild: player.wild_word_points += points
    
    return (
        if max_points > 0 
        then color_for_points(max_points) 
        else TILE.CENTER_SELECTED_COLOR)

todo("Handle sensitive wild words that the player didn't explicitly enter")

/* Creates animation going from the selection to the last word in the free list */
def player_spawn_free_score_animation(player, word, color):
    let target
    let letter_array = []
    let start_array = []
    
    const entry = player.history.free[find(player.history.free, {word: word}, ∅, "word")]
    assert(entry)
    
    // Have to wait until callback time for this so that the 
    // target actually gets rendered and assigned a pos first
    def capture_target():
        // Abort if the mode ends and history is cleared while 
        // waiting for this callback
        if not entry: return sequence.BREAK
        
        for i < size(word):
            const tile = player.free_row[i]
            
            if not tile or (tile.letter ≠ word[i] and tile.letter ≠ WILDCARD_CHARACTER): return sequence.BREAK
            
            push(start_array, xy(tile.pos))
            push(letter_array, q_decode(tile.letter))
        target = entry.pos + xy(4 size(entry.word), 4)


    def callback(frames_left, total_frames):
        const α = linstep(total_frames, 0, frames_left)^1.5
        for i < size(letter_array):
            const pos = lerp(start_array[i], target, α)
            draw_disk(pos, 12 (1 - α), color, ∅, 9)
            draw_text({font: score_font, x_align: "center", y_align: "center", text: letter_array[i], pos: pos, color: rgba(1, 1, 1, 1 - α³), z: 10})
    
    // Wait 1 frame to guarantee the tiles have been rendered
    sequence(1, {begin_callback: capture_target, callback: callback, frames: HISTORY.POINTS_ANIMATION_FRAMES})



/* Remove any previous entry of player.history.free that does not belong */
def player_remove_destroyed_freestyle_words(player):
    const pattern = free_row_pattern(player)
    
    def maybe_remove(entry):
        if not wildcard_starts_with(pattern, entry.word):
            return iterate.REMOVE
    
    iterate(player.history.free, maybe_remove)
    
    
    
/* Add a tile to the free row */
def add_tile_to_word(tile):
    assert(not tile.used)
    
    _board_play_sound(if tile == player.wild_tile then wild_placement_sound else select_tile_sound, 85%, 100%, xy(2, 2))
    
    tile.used = true
    push(player.free_row, {
        letter: tile.letter,
        source_tile: tile,
        points: LETTER_POINT_TABLE[tile.letter]})
    
    selection_color = player_free_selection_change_callback(player, player.free_row)



/* Remove the last tile from the free row */
def remove_last_tile():
    remove_tile_at_index(size(player.free_row) - 1)
        


/* Remove a specific tile from the free row by index */
def remove_tile_at_index(index):
    assert(index ≥ 0 and index < size(player.free_row))
    const tile = player.free_row[index]
    // Put back into the board
    tile.source_tile.used = false

    // Remove from the player.free_row
    remove_values(player.free_row, tile)
   
    play_sound({sound:select_tile_sound, volume:150%, pitch:40%})

    // Update selection
    selection_color = player_free_selection_change_callback(player, player.free_row)



/* Draw the free word construction area. Returns the history rect
   because that is computed as a side effect of layout. */
def draw_free_row(board_pos)
& preserving_transform:
    // Move in front of the history
    set_transform(∅, ∅, 2)
    
    const [board_grid_size, board_tile_size, board_gutter] = get_freestyle_board_dims()
    const board_width = board_grid_size.x + ¼ board_tile_size.x
    
    let history_rect = get_history_rect()
        
    // Choose tile size. Leave room for one extra tile until we hit 16
    // to imply that the player can keep going
    const tile_slots = clamp(size(player.free_row) + 1, if landscape() then 8 else 6, ROWS * COLS)
    
    const tile_area_width = if landscape() then board_grid_size.x else (history_rect.size.x - 10)
    
    let tile_size = xy(1, 1) * (tile_area_width / tile_slots)
    
    if tile_slots < ROWS * COLS:
        // Round up, we have some room
        tile_size = ceil(tile_size)
    else:
        // Have to make that last letter fit
        tile_size = round(tile_size)
        
    
    // Take off the padding
    if tile_size.x > 21:
        tile_size -= 1
        
    if tile_size.x ≥ 12:
        tile_size -= 1
        
    // Spacing between tiles
    const tile_spacing = tile_size.x + (if tile_size.x > 21 then 2 else (if tile_size.x > 12 then 1 else 0))

    const last_entry = last_value(player.history.free) default {word: "", color: TILE.CENTER_SELECTED_COLOR}
    let selection_length = size(last_entry.word)
    const selection_color = last_entry.color

    
    let free_rect
    if landscape():
        // Landscape: free over board
        free_rect = {
            corner: board_pos - xy(½ board_width, ½ board_width + tile_size.y + 14),
            size: xy(board_width, tile_size.y + 6)}
    else: 
        // Portrait: free over reduced history
        history_rect.size.y -= tile_size.y + 4
        
        free_rect = {
            corner: history_rect.corner + xy(1, history_rect.size.y),
            size: xy(history_rect.size.x - 2, tile_size.y + 6)}    
    
    for i ≤ 2:
        draw_rect(free_rect.corner + ½ free_rect.size, free_rect.size + 2i, if i == 0 then player.background_color else ∅, selection_color)
        
    // Draw tiles in the word
    const start_x = free_rect.corner.x + ⌈½ tile_spacing⌉ + 2
    const tile_y = free_rect.corner.y + ⌊½ free_rect.size.y⌋

    let i = 0
    let removed_already = false
    while i < size(player.free_row):
        const tile = player.free_row[i]
        tile.pos = xy(start_x + i * tile_spacing, tile_y)
        
        tile.selected = i < selection_length
        tile_draw(tile, tile.pos, false, 0°, selection_color, tile_size, true)
        
        // Use touch.a instead of touch.pressed_a so that the player can swipe across
        // to remove all
        if not removed_already and touch.a and overlaps(touch.xy, {pos: tile.pos, size: tile_size}):
            --selection_length
            removed_already = true
            remove_tile_at_index(i)
        else:
            ++i
            
    for size(player.free_row) ≤ i < tile_slots:
        draw_rect(xy(start_x + i * tile_spacing, tile_y), tile_size - 2, TILE.HOLE_COLOR)
                
    // Draw the connectors between letters if it is a word. Intentionally
    // do not draw the selected-but-not-a-word line, as it makes them not 
    // look like tiles any more
    if selection_length > 1:
        draw_line(xy(start_x, tile_y), xy(start_x + (selection_length - 1) * tile_spacing, tile_y), selection_color, TILE.CENTER_Z, ¼ tile_size.y)

    return history_rect
    


/* Returns `[grid_size, tile_size, gutter]` for the
   Freestyle board, which is shrunk in landscape mode. */    
def get_freestyle_board_dims():
    let tile_size = xy(TILE.EXTENT, TILE.EXTENT)
    
    if landscape():
        // Make the board smaller to make room for the free row.
        // The player may not notice as we blacked the screen
        // between rounds
        tile_size = ⌊85% tile_size⌋
        
    const gutter = ⌊tile_size.x / 8.8⌋
    const grid_size = xy(COLS, ROWS) * tile_size + xy(COLS - 1, ROWS - 1) * gutter

    return [grid_size, tile_size, gutter]



/* Draw the board with used tiles shown as blank */
def draw_freestyle_board(pos)
& preserving_transform:
    // Duplicates some `player_update_board()` code because it has to draw
    // the board in a special way to make it smaller and have missing tiles

    const [grid_size, tile_size, gutter] = get_freestyle_board_dims()
    const center_size = tile_size - gutter
    
    set_transform(pos)
        
    const board_size = grid_size + ¼ tile_size.x
    for 0 ≤ i ≤ 2:
        draw_rect(xy(0, 0), board_size + 2 i, if i then ∅ else player.background_color, player.board.selection_color)

    if not player.has_achievement["Freestyle Word"]:
        draw_tutorial(
            if landscape() then xy(-½ board_size.x, 0) else xy(0, -½ board_size.y),
            "Choose letters in\nany order to spell\none long word",
            if landscape() then 0° else 270°)

    for col at i in player.board.tile:
        for tile at j in col:
            const index = xy(i, j)
            const tile_pos = (index * (gutter * xy(min(index.x, 1), min(index.y, 1)) + tile_size.x) - ½ xy(COLS - 1, ROWS - 1) * (tile_size.x + gutter))
            const is_cursor_tile = player.using_gamepad and player.cursor_tile_index.x == i and player.cursor_tile_index.y == j
            
            tile.pos = transform_ws_to_ss(tile_pos)
            
            // Touch selection for adding tiles to word
            const tile_center = {pos: tile_pos, shape: "disk", size: center_size}
            if mode_frames > 5 and touch.a and overlaps(tile_center, touch.xy) and not tile.used:
                add_tile_to_word(tile)
            
            // Gamepad selection
            if player.using_gamepad and is_cursor_tile:
                if player.gamepad.pressed_a and not tile.used:
                    add_tile_to_word(tile)
                        
            if not tile.used:
                tile_draw(tile, tile_pos, is_cursor_tile, 0°, #CCC, tile_size)
            else:
                draw_rect(tile_pos, xy(35, 35), TILE.HOLE_COLOR)
                
                // Cursor on used tile: border only
                if is_cursor_tile:
                    for i < 2:
                        draw_rect(tile_pos, tile_size - 2 i, ∅, CURSOR_COLOR)


def done():
    play_sound({sound: blip_alt_sound, volume: 80%})
    player_achieve(player, "Exit Freestyle")
    pop_mode() because "Button"



def wild_callback():
    add_tile_to_word(player.wild_tile)



enter
────────────────────────────────────────────────────────────────────────
play_sound({sound: blip_alt_sound, pitch: 75%, volume: 80%})



frame
────────────────────────────────────────────────────────────────────────
maybe_connect_to_network()
const time_left = end_time - frame_utc_now

// Handle gamepad cursor movement
if player.using_gamepad:
    const target = player.cursor_tile_index + player.gamepad.xy * |sign(player.gamepad.dxy)|
    if target.x ≥ 0 and target.x < COLS and target.y ≥ 0 and target.y < ROWS:
        player.cursor_tile_index = target

const board_pos = get_board_pos()

draw_timer(board_pos)
player_draw_score(player, board_pos)

if landscape():
    // Move the board down to make room for the free row
    board_pos.y += 17

// Draw the board with used tiles as blank
draw_freestyle_board(board_pos)

// Draw free word construction area
const history_rect = draw_free_row(board_pos)

history_update(player.history, history_rect)

handle_buttons(
    ability_icon.ok, "Done", done,
    ability_icon.remix, ∅,
    aux_icon.backspace, if size(player.free_row) then remove_last_tile else ∅, true,
    if player.wild_tile.used or size(player.free_row) == 0 then ∅ else wild_callback)
    
// In case the player parks in Freestyle for too long
// we check the network timer here to see if we should log on
update_network()

if time_left ≤ GRACE_SECONDS:
    // Make a few frames black at the end so that a player can
    // still trace a little further but can't see. This makes
    // it feel like they squeezed in one more word and weren't
    // "robbed" if in the process of selecting. Without this
    // it always feels like "I was just about to finish my word"
    
    set_post_effects({color: #000})

if time_left ≤ 0:
    // Go back to Play, which will then go to the intermission
    pop_mode() because "Timer"

