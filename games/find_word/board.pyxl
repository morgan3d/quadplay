/* Routines for manipulating a game board of `ROWS` x `COLS` *tiles*.
   The board includes information about the current selection. 
   
   A tile `index` is an integer `xy()` position, where `(0, 0)` is the
   upper left and `(COLS, ROWS)` is the lower right.
   
   Drawing the board is handled by the player script because it is intertwined
   with UI data stored on the player. */


/* Create a new board. The board is not initialized. Use `board_reset()`. */
def make_board():
    const board = {
        // Lower case q-decoded word and permutation number
        // used to generate this board
        seed: ∅,
        
        // The tiles
        tile: make_array(xy(COLS, ROWS), make_tile(), deep_clone),
                
        // The UI selection as xy() indices, in order of selection
        selection: [],
        
        // Chosen based on the point value of the current word in _check
        selection_color: TILE.CENTER_SELECTED_COLOR,
        
        // Q-encoded. Identified by `board_search()`
        word_list: [],
        
        // Q-encoded. Set version of word_list produced by `board_search()`
        word_set: {}
    }
    
    return board
    


def board_find_good(board, game_type):
    // Construct the rng based on the time. This will
    // cause players within the same window to be more likely
    // to have the same board. Temporary prior to investing
    // multiplayer servers.
    const rng_seed = (if in_waiting_room or game_type == SOLO_GAME or DEBUG.BOARD_SEARCH then 
            (10 utc_now())
        else
            // Use the seed for the curent game period, but look a few
            // seconds into the future in case this player is joining early
            // to make it robust
            ⌊1 + (utc_now() + 10) / GLOBAL_PERIOD⌋)
    
    const board_rng = make_random(rng_seed)

    const {board_string, word_array, seed} = make_good_board_string(board_rng)
    
    // Convert to board
    board.word_list = word_array
    board.word_set = array_to_set(word_array)
    assert(size(board.word_set) == size(word_array))
    board.word_count = size(word_array)
    board.seed = seed
    for x < COLS:
        for tile at y in board.tile[x]:
            tile.letter = board_string[x + y * COLS]
            tile.selected = 0
            tile.used = false
            
            
    
/* Returns a selection array [xy(), …] that matches the word, or ∅ if the word 
   does not appear in this board. The word is all caps and NOT Q-encoded */
def board_find_unencoded_word(board, unencoded_word):
    // Workaround bug
    if not unencoded_word: return ∅

    let path = ∅
    const encoded = q_encode(unencoded_word)

    def visit(word, index, base16_path):
        if not starts_with(encoded, word):
            return true
        else if word == encoded:
            path = []
            // Convert the base36 path into an xy() path
            for d in base16_path:
                const i = HEX_TO_DEC[d]
                push(path, xy(i mod COLS, ⌊i / COLS⌋))
                
            return true
            
    board_string_visit_subpaths(board_to_string(board), visit)
    
    return path




def get_board_pixel_size():
    return xy(COLS, ROWS) * TILE.EXTENT + xy(COLS - 1, ROWS - 1) * TILE.GUTTER

    

/* For debugging */
def board_to_string(board, line_suffix default ""):
    let s = ""
    for y < ROWS:
        for x < COLS:
            s += board.tile[x][y].letter
        if y ≠ ROWS - 1:
            s += line_suffix
    return s
    
    

/* True if these xy() tile integer indices are adjacent */
def _adjacent(A, B):
    return XY_DISTANCE(A, B) < 1.5
    
    

/* Returns the center of the tile at index in pixels relative to the
   grid upper left corner */
def _index_to_pos(index):
    return (index * (TILE.GUTTER * xy(min(index.x, 1), min(index.y, 1)) + TILE.EXTENT)
           - ½ xy(COLS - 1, ROWS - 1) * (TILE.EXTENT + TILE.GUTTER))



/* Add the `xy()` value `index` to the current selection, playing sounds
   as appropriate.  */
def board_select(board, index, player):
    push(board.selection, index)
    board.tile[index.x][index.y].selected = game_frames

    if size(board.selection) == 1:
        // This is a new selection starting, so disable the auto list
        player.remix_list = ∅

    // Pan sound with position
    if not player_selection_change_callback(player):
        _board_play_sound(select_tile_sound, 85%, 100%, index)



def board_deselect_last(board, player):
    board.selection_color = TILE.CENTER_SELECTED_COLOR
    
    const index = pop(board.selection)
    board.tile[index.x][index.y].selected = false
    
    if not player_selection_change_callback(player):
        // Could play a deselect sound here



def board_deselect_all(board, player):
    board.selection_color = TILE.CENTER_SELECTED_COLOR

    for index in board.selection:
        board.tile[index.x][index.y].selected = false

    resize(board.selection, 0)
    // Could play a deselect sound here
        
        

/* Adjusts the pan for the index */
def _board_play_sound(sound, volume, pitch, index):
    play_sound({
        sound: sound,
        volume: volume,
        pan: if index then (index.x + 1) / (COLS + 1) else ∅,
        pitch: pitch})
    


/* Swaps tiles as if the board were rotated 90 degrees CW */
def board_rotate(board):
    assert(size(board.selection) == 0)
    assert(ROWS == COLS)
    
    const old = board.tile
    
    board.tile = make_array(xy(COLS, ROWS))
    for i < COLS:
        for j < ROWS:
            board.tile[i][j] = old[j][ROWS - i - 1]



/* 90° CCW */
def board_reverse_rotate(board):
    assert(size(board.selection) == 0)
    assert(ROWS == COLS)
    
    const old = board.tile
    
    board.tile = make_array(xy(COLS, ROWS))
    for i < COLS:
        for j < ROWS:
            board.tile[i][j] = old[ROWS - j - 1][i]



/* Returns the Q-encoded upper-case text word that is selected, 
   or "" if no selection */
def board_selected_word(board):
    let word = ""

    for s in board.selection:
        word += board.tile[s.x][s.y].letter
        
    return word
    


/* Draw a mini version of the game board on the intermission modes. 
   See also `player_update_board()` */
def board_draw_mini(board, pos)
& preserving_transform:
    compose_transform(pos)
            
    for y < ROWS:
        for x < COLS:
            const tile = board.tile[x][y]
            const letter = if tile.letter == "Q" then "Qu" else tile.letter
            
            tile.pos = 12 xy(x - 1.5, y - 1.5)
            
            // Pulse when just selected
            const radius = if tile.selected and (tile.selected ≥ game_frames - 16) then 6 else 5
            draw_disk(tile.pos, radius, if tile.selected then (if |game_frames - tile.selected - 6| ≤ 7 then #FFF else board.selection_color) else #FFF)
            
            draw_text({
                pos: tile.pos,
                font: history_font,
                color: if tile.selected then #FFF else #000,
                text: letter})
    
    if size(board.selection) > 0:
        const word = q_decode(board_selected_word(board))
        
        // Draw word
        draw_text({
            font: leaderboard_font,
            text: word,
            pos: xy(0, -31),
            shadow: #000,
            color: player.board.selection_color})
            
        // Draw connectors
        for 1 ≤ i < size(board.selection):
            const prev = board.selection[i - 1]
            const curr = board.selection[i]
            draw_line(board.tile[prev.x][prev.y].pos, board.tile[curr.x][curr.y].pos, board.selection_color, -1, 2)



/* Force a selection in the intermission modes.
   `word` is Q-decoded. Does not select if already selected,
   so that pulse animation works */
def board_select_word(board, word, color default HIGHLIGHT_COLOR):
    assert(word)
    // In the case of a word that is not findable (because it uses wild card tiles
    // for example), becomes []
    const selection = board_find_unencoded_word(board, word)
    if not selection or q_decode(board_selected_word(board)) == word: return

    board_deselect_all(player.board)
    board.selection = selection
    board.selection_color = color
    
    // Select these letters
    for index at i in board.selection:
        board.tile[index.x][index.y].selected = game_frames + 2 i
    
    play_sound({sound: blip_sound, pan: board.pos})


    


