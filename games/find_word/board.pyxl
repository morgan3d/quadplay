/* Functions that operate on 16-letter row-major `board_string` and the 
   logic for finding a good `board` object */


def make_board(seed, board_string, word_list):
    return {
        // Lower seed number and permutation number
        // used to generate this board
        seed: seed,
        
        // Q-encoded. Identified by `board_search()`
        word_list: word_list,        
    
        // Q-encoded. Set version of word_list produced by `board_search()`
        word_set: array_to_set(word_list),

        // Raw board string used for generation. 16 characters, no spaces.
        board_string: board_string}



/* Computes and returns all n-tile sequences that are possible on this board. 
   Used by the solver.
   
   As a side effect, puts all members of that set and smaller
   n-grams larger than DICTIONARY.MIN_WORD_LENGTH that are also in `dictionary`
   into `word_set`.
   */
def board_string_ngram_set(board_string, n, word_set):
    const ngram_set = {}
    const before = now()
    
    // Applied to each subpath
    def visit(kgram, index):
        const k = size(kgram)
        
        if k ≥ DICTIONARY.MIN_WORD_LENGTH:
            // We found a real word as a side effect of trigram processing
            if dictionary.all[kgram]:
                word_set[kgram] = 1
        
            // We have completed an n-gram, done with this path    
            if k == n:
                ngram_set[kgram] = 1
                return true

    board_string_visit_subpaths(board_string, visit)   
    
    // debug_print(round((now() - before) * 1000), "ms to find", size(ngram_set), "x " + n + "-grams and all shorter words")
    return ngram_set
    
    
    
/*
  Visit all possible subpaths and invoke `visit(word, index, base16_path)` on them,
  where the tile index is `xy(index mod COLS, floor(index / COLS))`.
  
  If `visit()` returns true, stop searching children of that subpath.
  
  The word is all-caps and Q-encoded.
*/
def board_string_visit_subpaths(board_string, visit):
    assert(ROWS * COLS ≤ 16, "Cannot express all tiles as single-digit base16")
    
    for index < ROWS * COLS:
        _board_string_visit_subpaths_helper(board_string, index, 1 bitshl index, board_string[index], visit, DEC_TO_HEX[index])
    


/* `_neighbor_index_array_table[i]` = array of indices of all neighbors of tile (`i mod COLS`, `floor(i / cols)`),
   where the indices have the same packing. Used by `_board_ngram_set_helper()`.

   This simplifies the code for searches over the board and technically makes it them a more
   generalizable graph algorithm. There's negligible performance impact from
   using precomputed neighbors vs. computing dynamically
 */ 
const _neighbor_index_array_table = make_array(COLS * ROWS, [], clone)

// Initialize `_neighbor_index_array_table`.
// Iteration order doesn't matter for these loops, but this makes 
// more obvious that we're using row-major indexing.
for y < ROWS
& for x < COLS:
    const tile = _neighbor_index_array_table[x + y * COLS]
    
    // For each direction
    for -1 ≤ dx ≤ +1:
        for -1 ≤ dy ≤ +1:
            // Is this neighbor in bounds?
            if x + dx ≥ 0 and x + dx < COLS and y + dy ≥ 0 and y + dy < ROWS and (dx ≠ 0 or dy ≠ 0):
                push(tile, (x + dx) + (y + dy) * COLS)


/* Recursive portion of `board_string_visit_subpaths` 

   `board_string`
   : The board as a row-major flattening

   `word`
   : Concatenation of the labels of the visited tiles,
     pulled from `board_string`.
   
   `index`
   : `x + y * COLS` of the current tile coordinates
   
   `base16_path`
   : A string of the path to this point, encoded as the
     index in hexadecimal.
   
   `visit(word, index)`
   : Arbitrary callback for processing this subpath.
     If `visit` returns `true` then the path terminates here,
     otherwise it recurses as deep as possible.
*/
def _board_string_visit_subpaths_helper(board_string, index, used_mask, word, visit, base16_path):
    // Run the callback and only continue if it returns false
    if not visit(word, index, base16_path):
    
        // Check all neighbors of index
        for neighbor in _neighbor_index_array_table[index]:
            const mask = 1 bitshl neighbor
            
            // Did we already use the tile at neighbor?
            if not (mask ∩ used_mask):
                // Continue search, updating the mask, word, and path
                _board_string_visit_subpaths_helper(board_string, neighbor, mask ∪ used_mask, word + board_string[neighbor], visit, base16_path + DEC_TO_HEX[neighbor])
        


/* Return true if `word` can be found in `board_string`.
   See also `player_find_unencoded_word()`*/
def board_string_validate_word(board_string, word):
    let found = false
        
    def visit(prefix):
        if found or word[last_key(prefix)] ≠ last_value(prefix):
            // Prune the search. Stop all other recursion once we've
            // found the word on some other path, or determined that
            // this prefix cannot lead to this word
            return true
        else if word == prefix:
            // We found the word exactly
            found = true
            return true
    
    board_string_visit_subpaths(board_string, visit)
    
    return found
        


/* Returns an alphabetically-sorted array of all possible dictionary 
   words of `MIN_WORD_LEN` on this board. The words are q-encoded 
   and are uppercase. */
def board_string_find_all_words(board_string):
    // Words discovered during n-gram search
    const word_set = {}
    
    // This produces the 5-grams used for filtering and in the process
    // also finds all words of length 3, 4, 5.
    const quintgram_set = board_string_ngram_set(board_string, 5, word_set)
    
    // Search all words of length > 5 in the dictionary for likely hits
    def test_against_board(word):
        const k = size(word)
        
        if (k > 5 and
            // 6+-letter word prefix
            quintgram_set[slice(word, 0, 5)] and
         
            // 6+-letter word suffix
            (k < 6 or quintgram_set[slice(word, k - 5)]) and

            // 8+-letter word middle
            (k < 8 or quintgram_set[slice(word, 2, 7)])):

            // This long word is very likely to appear, but we
            // must validate it.
            return if board_string_validate_word(board_string, word) then word else ∅
                
    const word_array = keys(array_to_set(dictionary_array.all, ∅, word_set, test_against_board))
    sort(word_array)
    return word_array



/* Detect if a row or column or main diagonal spells a sensitive word.
   These words are acceptable in play but we don't want to explicitly
   spell them out in the default or reverse orientation. */
def board_string_has_obvious_sensitive_word(board_string, only_stop_offensive default false):
    
    const dict = if only_stop_offensive then offensive else sensitive
    
    def is_sensitive(word):
        // The sensitive dictionary has not been encoded
        word = lowercase(q_decode(word))
        return dict[word] or dict[reversed(word)]
    
    // Check columns
    for i < COLS:
        let word = ""
        for j < ROWS:
            word += board_string[i + COLS * j]
        
        if is_sensitive(word): return true
        
    // Check rows
    for j < ROWS:
        let word = ""
        for i < COLS:
            word += board_string[i + COLS * j]
           
        if is_sensitive(word): return true
            

    // Check diagonals. If not square, make a half-hearted attempt at this
    // by using the shorter dimension
    const len = min(COLS, ROWS)
    let word = ""
    for i < len:
        word += board_string[i + COLS * i]
        
    if is_sensitive(word): return true

    word = ""
    for i < len:
        word += board_string[COLS - i - 1 + COLS * i]
        
    if is_sensitive(word): return true

    return false
    
    
    
/* Creates a random board, searching for good values as
   controlled by `GENERATE_BOARD.CRITERIA` constants. */
def make_good_board_string(board_rng):

    let done = false
    let seed_base
    let word_array
    
    let short_word_count = 0
    let long_word_count = 0
    let very_long_word_count = 0
    let valuable_letter_use_count = {}
    let valuable_letter_long_count = {}
    let mean_valuable_letter_uses = 0
    let mean_valuable_letter_long_uses = 0
    let min_valuable_letter_uses = ∞
    let min_valuable_letter_long_uses = ∞
    
    let seed
    let board_string
    let vowels

    let tries = -1  
    while tries < GENERATE_BOARD.CRITERIA.RETRIES:
        ++tries
        if tries > 0 and DEBUG.BOARD_SEARCH: debug_print("\n****************************************\n*** Rerolling because still bad after " + GENERATE_BOARD.CRITERIA.SHUFFLE_RETRIES + " shuffles ***") 

        seed_base = random_integer(0x0, 0x7FFFFFFF, board_rng)
                
        // Loop for shuffling
        for permute_number < GENERATE_BOARD.CRITERIA.SHUFFLE_RETRIES:
            
            word_array = ∅ 
            const gen = make_random_board_string(seed_base, permute_number)
            board_string = gen.board_string
            seed = seed_base + "." + permute_number
            

            if (tries == GENERATE_BOARD.CRITERIA.RETRIES - 1) and (permute_number == GENERATE_BOARD.CRITERIA.SHUFFLE_RETRIES - 1):
                // Last try, so just give up and accept the board
                if DEBUG.BOARD_SEARCH: debug_print("Gave up and accepted " + seed_base)
                done = true
                break
                        
            // Between 4 and 7 vowels seems to be the sweet spot for a good 4x4 grid,
            // so re-roll if we fail on this
            if gen.vowels < ROWS or gen.vowels ≥ 2 ROWS:
                if DEBUG.BOARD_SEARCH: debug_print("\n*** Rerolling because " + gen.vowels + " vowels ***")
                // Break out of the shuffle loop
                break
    
            if board_string_has_obvious_sensitive_word(board_string, tries > ½ GENERATE_BOARD.CRITERIA.RETRIES):
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it had an obvious sensitive word")
                continue
    
            // Now that trivial tests have passed, examine whether there
            // are enough good words
            word_array = board_string_find_all_words(board_string)
            
            // Number of times a valuable letter was used
            valuable_letter_use_count = {}
            let num_valuable_letter_instances = 0
            let num_very_valuable_letter_instances = 0
            for letter in board_string:
                if LETTER_POINT_TABLE[letter] ≥ 4:
                    valuable_letter_use_count[letter] = 0
                    ++num_valuable_letter_instances
                    if LETTER_POINT_TABLE[letter] ≥ 5:
                        ++num_very_valuable_letter_instances
            
            const valuable_letters = keys(valuable_letter_use_count)

            if size(word_array) < (if size(valuable_letters) then GENERATE_BOARD.CRITERIA.MIN_WORDS_VERY_VALUABLE_LETTER_BOARD else GENERATE_BOARD.CRITERIA.MIN_WORDS):
                // Not enough words to even examine the board
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it only produced " + size(word_array) + " words on a board with " + num_very_valuable_letter_instances + " very valuable letters")        
                continue
            
            if tries ≥ GENERATE_BOARD.CRITERIA.RETRIES - 2:
                // We're running out of tries. This board passes
                // the min words test, so just accept it instead of getting
                // stuck with the last board we generate
                if DEBUG.BOARD_SEARCH: debug_print("Gave up and accepted board " + seed_base + " because we had two tries left and this passed minumum words")
                done = true
                break
    
            // Examine the actual words to see if there are enough *good* ones   
            //
            // If a valuable letter appears, ensure that it is used in 
            // at least two words. First find high point value letters.
                        
            valuable_letter_long_count = clone(valuable_letter_use_count)
            
            // Iterate through words, rating them for each criterion
            short_word_count = 0
            long_word_count = 0
            very_long_word_count = 0
            for word in word_array:
                if size(word) ≤ 4:
                    ++short_word_count
                else if size(word) < 7:
                    ++long_word_count
                else:
                    ++very_long_word_count
                                        
                for letter in valuable_letters:
                    if contains(word, letter):
                        ++valuable_letter_use_count[letter]
                        
                        if size(word) ≥ 5:
                            ++valuable_letter_long_count[letter]
            
            if short_word_count < GENERATE_BOARD.CRITERIA.MIN_SHORT_WORDS:
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it only produced " + short_word_count + " short words")        
                continue
            
            if long_word_count < GENERATE_BOARD.CRITERIA.MIN_LONG_WORDS:
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it only produced " + long_word_count + " long words")        
                continue
            
            if very_long_word_count < GENERATE_BOARD.CRITERIA.MIN_VERY_LONG_WORDS:
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it only produced " + very_long_word_count + " very long words")        
                continue
            
            // See if we used the valuable letters.
            let total_valuable_letter_uses = 0
            let total_valuable_letter_long_uses = 0
            min_valuable_letter_uses = ∞
            min_valuable_letter_long_uses = ∞
            
            for count at letter in valuable_letter_use_count:
                total_valuable_letter_uses += count
                total_valuable_letter_long_uses += valuable_letter_long_count[letter]
                min_valuable_letter_uses = min(min_valuable_letter_uses, count)
                min_valuable_letter_long_uses = min(min_valuable_letter_long_uses, valuable_letter_long_count[letter])
            
            mean_valuable_letter_uses = total_valuable_letter_uses / max(num_valuable_letter_instances, 1)
            mean_valuable_letter_long_uses = total_valuable_letter_long_uses / max(num_valuable_letter_instances, 1)
            
            if mean_valuable_letter_uses < GENERATE_BOARD.CRITERIA.MEAN_VALUABLE_LETTER_USES:
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it did not use all of the valuable letters " + GENERATE_BOARD.CRITERIA.MEAN_VALUABLE_LETTER_USES + " times on average")
                continue
            
            if mean_valuable_letter_long_uses < GENERATE_BOARD.CRITERIA.MEAN_VALUABLE_LETTER_LONG_WORDS:
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it did not use all of the valuable letters in " + GENERATE_BOARD.CRITERIA.MEAN_VALUABLE_LETTER_LONG_WORDS + " long words on average")
                continue

            if min_valuable_letter_uses < GENERATE_BOARD.CRITERIA.MIN_VALUABLE_LETTER_USES:
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it did not use all of the valuable letters " + GENERATE_BOARD.CRITERIA.MIN_VALUABLE_LETTER_USES + " times")
                continue
            
            if min_valuable_letter_long_uses < GENERATE_BOARD.CRITERIA.MIN_VALUABLE_LETTER_LONG_WORDS:
                if DEBUG.BOARD_SEARCH: debug_print("\nShuffled board " + seed_base + " because it did not use all of the valuable letters in " + GENERATE_BOARD.CRITERIA.MIN_VALUABLE_LETTER_LONG_WORDS + " long words")
                continue
    
            // Success!
            done = true
            break
    
        if done:
            // Stop early as we have a good board
            if DEBUG.BOARD_SEARCH: debug_print("Accepted board")
            break
        else:
            // Try again
            seed_base = ∅

    // Some paths above skip over generating the word array, so we have to fill it in here    
    if not word_array:
        word_array = board_string_find_all_words(board_string)

    sort(word_array, size_comparator)
    
    if DEBUG.BOARD_SEARCH:
        debug_print(join(word_array, ", "))
        debug_print("very_long_word_count =", very_long_word_count)
        debug_print("valuable_letter_use_count =", valuable_letter_use_count)
        debug_print("valuable_letter_long_count =", valuable_letter_long_count)
        debug_print("size(word_array) =", size(word_array))
        debug_print("short_word_count =", short_word_count)
        debug_print("long_word_count =", long_word_count)
        debug_print("mean_valuable_letter_uses =", mean_valuable_letter_uses)
        debug_print("mean_valuable_letter_long_uses =", mean_valuable_letter_long_uses)
        debug_print("min_valuable_letter_uses =", min_valuable_letter_uses)
        debug_print("min_valuable_letter_long_uses =", min_valuable_letter_long_uses)
        debug_print("Total tries:", tries + 1)
        
    return {board_string, word_array, seed}



/* Chooses a random letter for each tile, and then 
   permutes the result into pattern `seed_number`.
   This process is entirely deterministic based on
   the input. 
   
   Returns the `{board_string, vowels}`, where
   `vowels` is a count of AEIOU. */
def make_random_board_string(seed_base, permute_number default 0):
    const rnd = make_random(seed_base)
    
    assert(ROWS * COLS == size(GENERATE_BOARD.LETTER_SET_ARRAY), "Distribution does not have enough tile sets")

    // If true, choose using the word dice algorithm with the
    // standard dice set. If false, choose using sampling from 
    // a bag of tiles without replacement.
    const dice = rnd() < 85%
    if DEBUG.BOARD_SEARCH:
        debug_print("Using " + (if dice then "DICE" else "TILE") + " generator")
        
    // Shuffle the sets themselves
    const distribution = shuffled(GENERATE_BOARD.LETTER_SET_ARRAY, rnd)
    const letter_bag = split(GENERATE_BOARD.LETTER_BAG)
    
    let vowels = 0
    let board_string = ""
    for y < ROWS:
        for x < COLS:
            const letter = random_value(if dice then pop(distribution) else letter_bag, rnd)
            if not dice:
                fast_remove_value(letter_bag, letter)

            board_string += letter
            vowels += DICTIONARY.VOWEL[letter] default 0         

    if DEBUG.MZK:    
        board_string = "K" + slice(board_string, 1)

    if DEBUG.DRQ:    
        board_string = "Q" + slice(board_string, 1)
    
    if permute_number:
        board_string = shuffled(board_string, make_random(permute_number))
        
    if DEBUG.BOARD_SEARCH: debug_print(board_string)
    
    return {board_string: board_string, vowels: vowels}

