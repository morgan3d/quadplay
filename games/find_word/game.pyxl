/* Common code across modes. Mostly UI and timing. */

/* Set by Title. `SOLO_GAME` or `GLOBAL_GAME`. See also `in_waiting_room` */
let game_type = SOLO_GAME

/* In seconds, based on frame_utc_now */
let start_time

/* In seconds, based on frame_utc_now */
let end_time

/* `cursor.lib` cursor */
const cursor = make_cursor()

/* If true, then the player is just warming
   up for a `GLOBAL_GAME` game that will start soon. */
let in_waiting_room

const player = make_player()

// When debugging, do not make a reset player at a reasonable level re-do basic achievements
if DEBUG.FORCE_LEVEL > 3:
    for achievement in ["Change Avatar", "Check Stats", "Use Remix", "Rotate Board", "Freestyle Word", "Exit Freestyle", "Play Solo Match", "Play Global Match"]:
        player_achieve(player, achievement)

let resolution_hook
let time_hook
let input_hook
let notification_hook

/* Set by `Play.enter`. Used to track games that should not affect stats */
let joined_late


// Used by Intermission and AnimateXP to pass information
let prev_xp
let prev_level
let new_xp


/* Global games are synchronized to this clock in seconds, hitting
   this period exactly relative to UTC Unix 0 time */
const GLOBAL_PERIOD = GLOBAL_GAME.PLAY_SECONDS + GATHER_SECONDS + INTERMISSION.SECONDS + (ANIMATE_XP.PRE_FRAMES + ANIMATE_XP.FRAMES + ANIMATE_XP.POST_FRAMES) / 60
assert(not is_nan(GLOBAL_PERIOD))


/* Used by Title and AvatarEditor */
def draw_background_words():
    if not draw_background_words.array:
        // Initialize the background words
        draw_background_words.array = make_array(20, "")
        const dict_array = if player.avatar.level < 10 then dictionary_array.common else dictionary_array.all
        for y < size(draw_background_words.array):
            while size(draw_background_words.array[y]) < 250:
                draw_background_words.array[y] += " " + random_safe_word(dict_array, ∅, min(7, 3 + ⌊¼ player.avatar.level⌋), min(5 + ⌊⅓ player.avatar.level⌋, 16))

    
    for s at y in draw_background_words.array:
        draw_text({
            font: tile_font,
            color: #333,
            text: s,
            pos: round(xy(sign((y mod 2) - 0.5) * 0.2 oscillate(game_frames, -2000, 2000) - 700, 22 y)),
            x_align: "left",
            z: -2})
    

/* Updated once per frame by a frame hook. This ensures that there are no 
   race conditions within a frame because the time can only change 
   between frames */
let frame_utc_now = utc_now()


/* Time at which the last global game already started
   (or is about to start) */
def prev_global_game_utc_start_time():
    return floor(frame_utc_now, GLOBAL_PERIOD)



/* Time at which the next global game will start */
def next_global_game_utc_start_time():
    return round(frame_utc_now, GLOBAL_PERIOD)



def _update_frame_utc_now():
    const prev_time = frame_utc_now
    frame_utc_now = utc_now()
    
    if frame_utc_now - prev_time > 60 REBOOT_TIME_MINUTES:
        reset_game()



/* Hook that automaticaly switches the detected input mechanism */
def detect_input():
    if player.gamepad.pressed_a or player.gamepad.pressed_q or player.gamepad.pressed_b or player.gamepad.xx or player.gamepad.yy:
        player.using_gamepad = true
    else if touch.dx or touch.dy or touch.pressed_a or touch.hover:
        // Used touch screen or mouse
        player.using_gamepad = false



def play_points_sound(points, index default ∅):
    const pitch = 75% + min(max(0, points - 6)^0.1, 3)
    _board_play_sound(word_sound, 100% + 10% pitch, pitch, index)

    // Repeatly ding for 35 or more points
    for i ≤ (points - 35) / 10:
        delay(play_sound, 12 i, {sound: big_points_sound})



/* `true` if in landscape layout mode */
def landscape():
    return SCREEN_SIZE.x + 28 > SCREEN_SIZE.y

    

/* Enquotes text if freestyle is true */
def enquote_if(freestyle, text):
    return if freestyle then "«" + text + "»" else text


    
def set_hooks():
    if not notification_hook:
        notification_hook = add_frame_hook(update_notifications, ∅, ∞, "all")
    
    if not input_hook:
        input_hook = add_frame_hook(detect_input, ∅, ∞, "all")
    
    if not time_hook:
        time_hook = add_frame_hook(_update_frame_utc_now, ∅, ∞, "all")
        
    if not resolution_hook:
        // Fill the screen even at non-quadplay aspect ratios
        // for a good mobile experience. See also `DEBUG.PORTRAIT`
        device_control("set_mouse_cursor", "pointer")
        
        if DEBUG.PORTRAIT:
            device_control("enable_feature", "custom_screen_size")
            set_screen_size(xy(224, 412))
        else:
            resolution_hook = continuously_set_screen_size_to_window("smaller", 224)



/* Cooldown used in `draw_timer()`. Reset in `Play.enter` */
let last_countdown_sound_time

/* Draws the count-down timer for `end_time` relative to the board, and handles
   the countdown beeping and flashing. Returns distored time left. */
def draw_timer(board_pos):
    // Real seconds
    const real_time_left = max(0, end_time - frame_utc_now)
    
    // Remapped to shorten midgame and extend endgame tension
    let time_left = real_time_left
    
    if not in_waiting_room:
        // Start time is when the match started, not when this player joined it
        const game_total_time = end_time - start_time
        
        // Real time at which we pivot to expanding time
        const pivot = TIMER.REMAP_SECONDS / TIMER.END_TIME_SCALE
        
        // How much to scale time before the pivot
        const begin_time_scale = (game_total_time - pivot) / (game_total_time - TIMER.REMAP_SECONDS)
        
        if time_left > pivot:
            time_left = (time_left - pivot) * begin_time_scale + TIMER.REMAP_SECONDS
        else:
            time_left *= TIMER.END_TIME_SCALE
        
    // Display slightly less time than is actually available
    // so it doesn't feel like we're ending too abruptly on 0.
    // Also remove the grace time from the displayed time.
    time_left -= 3/60 + GRACE_SECONDS
    
    const pos = board_pos + xy(-½, -½) * get_board_pixel_size() - xy(-28, 16)
    draw_text({
        pos: pos,
        font: score_font,
        text: format_number(max(time_left, 0), "timer"),
        color: if in_waiting_room then #0F0 else #FFF,
        y_align: "center",
        x_align: "right"})
        
    if time_left > 0.1 and time_left < TIMER.BEEP_SECONDS + 0.5:
        if |loop(time_left, -0.5, 0.5)| ≤ 3/60 and now() - last_countdown_sound_time > 0.25:
            // Play on the second turnover exactly (so it aligns with the global clock instead of local frames)
            // but ensure that we play only once per timeout, converting from time to frames
            last_countdown_sound_time = now()
            play_sound(timer_countdown_sound, 150%)
            
            // Pulse in case sound is off
            player.background_color = #FFF
        else:
            // Fade back towards normal
            player.background_color = lerp(player.background_color, BOARD_COLOR, 4%)
    
    return time_left
    


def draw_round_selection(pos, radius):
    draw_disk(pos - xy(0, 1), radius + 0.5, ∅, #FFF, 2)
    draw_disk(pos - xy(0, 1), radius + 1.5, CURSOR_COLOR, ∅, -0.5)
    draw_disk(pos - xy(0, 1), radius + 4.5, rgba(CURSOR_COLOR, 25%), ∅, -0.6)
    draw_disk(pos - xy(0, 1), radius + 7.5, rgba(CURSOR_COLOR, 15%), ∅, -0.7)


/* If `activate_callback` is ∅, then the button is drawn disabled.

   `index` specifies the horizontal position.
   
   `name` is a unique identifier used for managing selection. This is potentially
   redundant with `index` except that selection can be shared with buttons that
   do not use this function.
   
   If `sprite` is not a sprite, draw a button placeholder circle but no actual button.
   If `sprite` is a number, display the level number as well.
   
   
   Returns the button region. */
def handle_ability_button(index, name, caption, sprite, gamepad_button, activate_callback):
    const radius = 14
    const region = {
        // In portrait mode, bring the buttons in from the edges more to avoid the browser's reload button on Safari
        pos: xy(radius + (if landscape() then (index + 0.25) * ⅓ (SCREEN_SIZE.x - 210) else ¼ (index + ¾) * SCREEN_SIZE.x), SCREEN_SIZE.y - radius - 1),
        size: radius * xy(2, 2),
        shape: "disk"}
            
    const enabled = activate_callback

    if enabled:
        if touch.hover and overlaps(region, touch.hover) and not player.using_gamepad:
            handle_ability_button.selected_button = name
    else if handle_ability_button.selected_button == name:
        // Deselect if not enabled and the currently selected button
        handle_ability_button.selected_button = ∅
        
    const selected = handle_ability_button.selected_button == name
    
    draw_text({
        pos: region.pos - xy(0, ½ region.size.y + 7),
        font: history_font,
        color: if selected then #FFF else (if enabled then #EEE else DISABLED_ABILITY_COLOR),
        outline: if selected then rgba(CURSOR_COLOR, 50%) else ∅,
        text: if type(sprite) == "number" then "Level " + sprite else caption})

    if type(sprite) ≠ "object":
        draw_disk(region.pos, radius, ∅, DISABLED_ABILITY_COLOR)
        draw_sprite({sprite: shapes.lock, pos: region.pos, scale: 75%, opacity: DISABLED_ABILITY_COLOR.a})
        return
        
    if not selected:
        // NOT selected
        draw_disk(region.pos, if name == "Wild" then radius - 2 else radius, if sprite then (if enabled then TILE.CENTER_COLOR else DISABLED_ABILITY_COLOR) else ∅, if not sprite then DISABLED_ABILITY_COLOR else ∅)
        
    if name == "Wild":
        // Make it look like a tile
        draw_rect(region.pos, radius * xy(2, 2), if enabled then TILE.COLOR else ∅, if enabled then ∅ else DISABLED_ABILITY_COLOR, ∅, -1)
    
    draw_sprite({sprite: sprite, pos: region.pos, opacity: (if enabled then 100% else 125% DISABLED_ABILITY_COLOR.a)})
    
    // Special case for the auto button, where the sprite itself shows a number
    if name == "Remix" and size(player.remix_list):
        // Save this position for later score animation
        player.remix_pos = region.pos
        draw_text({
            text: size(player.remix_list),
            pos: region.pos + 1,
            font: tile_font,
            color: if enabled then HIGHLIGHT_COLOR else rgba(HIGHLIGHT_COLOR, 40%),
            outline: if enabled then #FFF else #FFF5})
    
    if enabled:
        if player.using_gamepad:
            draw_text({
                pos: region.pos + xy(80% radius, 70% radius), 
                color: #fff,
                outline: #000,
                font: score_font,
                x_align: "left",
                z: 20,
                text: joy.prompt[gamepad_button]})
            
        if selected:
            draw_round_selection(region.pos, radius)
            
        if (mode_frames > 10 and 
            ((touch.pressed_a and overlaps(touch.xy, region))
            or joy.pressed_q)):
            activate_callback()

    return region

handle_ability_button.last_frame = 0



/* Renders and handles user input for the aux button next to the score and the
   ability buttons on the bottom of the screen.
   
   If `aux_allow_b` then the (b) button as well as the (f) button can activate
   the aux (used in Free Mode for keyboard backspace).
   
   Set a callback to ∅ for any button to render it disabled. */
def handle_buttons(
    free_sprite,  free_caption,  free_callback,
    remix_sprite, remix_callback,
    aux_sprite,   aux_callback,  aux_allow_b default false,
    wild_callback):

    // Deselect all on hover
    if touch.hover and game_frames > handle_ability_button.last_frame:
        handle_ability_button.selected_button = ∅
    handle_ability_button.last_frame = game_frames

    // No abilities except rotate when in the waiting room
    if not in_waiting_room:
        if player.has_ability["Freestyle"]:
            const region = handle_ability_button(0, "Freestyle", free_caption, free_sprite, if free_callback then "(q)" else ∅, free_callback)
            if not player.has_achievement["Freestyle Word"]:
                if get_mode() ≠ Freestyle:
                    draw_tutorial(region.pos - xy(0, 20), "Enter\nFreestyle", ∅, "left")
            else if not player.has_achievement["Exit Freestyle"] and get_mode() == Freestyle:
                draw_tutorial(region.pos - xy(0, 20), "Leave\nFreestyle", ∅, "left")
        
            // The "Scry Remixes" display becomes the "Remix x" button when active
            const remix_region = handle_ability_button(
                1,
                "Remix",
                if player.has_ability["Remix × 2"] then ("Remix ×" + player.remix_uses_left) else "Remix",
                if player.has_ability["Scry Remixes"] then remix_sprite else ABILITY_TABLE["Scry Remixes"].level,
                if player.has_ability["Remix"] and  remix_callback then "(d)" else ∅,
                if player.has_ability["Remix"] then remix_callback else ∅)
                
            if player.has_ability["Remix"] and not player.has_achievement["Use Remix"] and size(player.remix_list) ≥ 4:
                draw_tutorial(remix_region.pos - xy(0, 20), "Activate Remix")                  
    
            handle_ability_button(
                2,
                "Wild",
                "Wild",
                if player.has_ability["Wild"] then ability_icon.wild else ABILITY_TABLE["Wild"].level,
                if free_callback then "(c)" else ∅,
                wild_callback)
            

    if player.has_ability["Rotate"] and aux_sprite:
        const region = {
            pos: get_board_pos() + xy(-4, -16) + xy(½, -½) get_board_pixel_size(), 
            size: 140% aux_sprite.size}

        if aux_callback and touch.hover and overlaps(region, touch.hover) and not player.using_gamepad:
            handle_ability_button.selected_button = "aux"

        draw_sprite({
            sprite: aux_sprite,
            pos: region.pos,
            override_color: if handle_ability_button.selected_button == "aux" then CURSOR_COLOR else ∅,
            opacity: if aux_callback then 100% else DISABLED_ABILITY_COLOR.a})

        if aux_callback:
            if aux_sprite == aux_icon.rotate and not player.has_achievement["Rotate Board"]:
                draw_tutorial(region.pos, "Rotate\nthe\nboard", 90°, "right")

            if player.using_gamepad:
                draw_text({font: button_prompt_font, text: player.gamepad.prompt["(f)"], x_align: "right", pos: region.pos + xy(-5, 7), color: #FFF, outline: #000, z: 10})

            // Slightly oversize the aux button touch area, as they are small
            if (touch.pressed_a and overlaps(region, touch.xy)) or (aux_allow_b and joy.pressed_b) or joy.pressed_f:
                aux_callback()



/* Draw a tutorial arrow. `pos` is the position of the target to highlight. */
def draw_tutorial(pos, text, angle default 270°, text_x_align, text_y_align):
    const bounce = ⌊mode_frames / 30⌋ mod 2

    if angle == 0°:
        text_x_align = text_x_align default "right"        
    else if angle == 90°:
        text_y_align = text_y_align default "top"
    else if angle == 180°:
        text_x_align = text_x_align default "left"
    else if angle == 270°:
        text_y_align = text_y_align default "bottom"

    text_x_align = text_x_align default "center"
    text_y_align = text_y_align default "center"

    const args = {
        sprite: tutorial_arrow[0][0],
        angle: angle,
        pos: pos - angle_to_xy(angle) * (20 + bounce),
        z: TUTORIAL.Z}
        
    // Drop shadow
    draw_sprite({
        …args,
        pos: args.pos + xy(0, 1),
        override_color: #000,
        opacity: 50%})
        
    draw_sprite(args)
        
    draw_text({
        font: score_font,
        text: text,
        pos: pos - angle_to_xy(angle) * (30 + bounce) + xy(if angle ≠ 0° then {left: -6, center: 0, right: +6}[text_x_align] else 0, 0),
        color: #FFF,
        outline: #000,
        shadow: #0008,
        x_align: text_x_align,
        y_align: text_y_align,
        z: TUTORIAL.Z})



/* Returns true if `pattern` starts with `prefix`, where
   at most one `WILDCARD_CHARACTER` in pattern can match any one
   letter from `DICTIONARY.ALPHABET`. Assumes both are q-encoded
   strings, so that "Qu" is the single character "Q".
   
   Note that you might expect a general purpose version of
   this to operate the other way, with wildcards in `prefix`.
   
   Relatively slow. */
def wildcard_starts_with(pattern, prefix):
    if contains(pattern, WILDCARD_CHARACTER):
        const part = split(pattern, WILDCARD_CHARACTER)
        for letter in DICTIONARY.ALPHABET:
            if starts_with(part[0] + letter + part[1], prefix):
                return true
        return false
    else:
        return starts_with(pattern, prefix)
    

