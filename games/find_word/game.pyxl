/* Common code across modes. Mostly UI and timing. */

/* Set by Title. `SOLO` or `GLOBAL`. See also `in_waiting_room` */
let game_type = SOLO

/* In seconds, using frame_utc_now */
let start_time

/* In seconds, using frame_utc_now */
let end_time

/* `cursor.lib` cursor */
const cursor = make_cursor()

/* If true, then the player is just warming
   up for a `GLOBAL` game that will start soon. */
let in_waiting_room = false

let player = make_player()

let resolution_hook
let time_hook
let input_hook
let notification_hook

/* Set by `Play.enter`. Used to track games that should not affect stats */
let joined_late

const SOLO_GAME_TIME = 60 SOLO_GAME_TIME_MINUTES

const GLOBAL_INTERMISSION_TIME = GLOBAL_INTERMISSION_TIME_SECONDS
const GLOBAL_GAME_TIME = GLOBAL_GAME_TIME_SECONDS

/* Global games are synchronized to this clock, hitting this period exactly 
   relative to UTC Unix 0 time */
const GLOBAL_PERIOD = GLOBAL_GAME_TIME + GATHER_TIME_SECONDS + GLOBAL_INTERMISSION_TIME


/* Array of strings for background display on the title and avatar editor, by row. See `draw_background_words()`. */
const background_word_array = []


/* Used by Title and AvatarEditor */
def draw_background_words():
    for s at y in background_word_array:
        draw_text({
            font: tile_font,
            color: #333,
            text: s,
            pos: round(xy(sign((y mod 2) - 0.5) * 0.2 oscillate(game_frames, -2000, 2000) - 700, 22 y)),
            x_align: "left",
            z: -2})
    

/* Updated once per frame by a frame hook. This ensures that there are no 
   race conditions within a frame because the time can only change 
   between frames */
let frame_utc_now = utc_now()


/* Time at which the last global game already started
   (or is about to start) */
def prev_global_game_utc_start_time():
    return floor(frame_utc_now, GLOBAL_PERIOD)



/* Time at which the next global game will start */
def next_global_game_utc_start_time():
    return round(frame_utc_now, GLOBAL_PERIOD)



def _update_frame_utc_now():
    const prev_time = frame_utc_now
    frame_utc_now = utc_now()
    
    if frame_utc_now - prev_time > 60 * REBOOT_TIME_MINUTES:
        reset_game()



/* Hook that automaticaly switches the detected input mechanism */
def detect_input():
    if player.gamepad.pressed_a or player.gamepad.pressed_q or player.gamepad.pressed_b or player.gamepad.xx or player.gamepad.yy:
        player.using_gamepad = true
    else if touch.dx or touch.dy or touch.pressed_a or touch.hover:
        // Used touch screen or mouse
        player.using_gamepad = false



def play_points_sound(points, index default ∅):
    const pitch = 75% + min(max(0, points - 6)^0.1, 3)
    _board_play_sound(word_sound, 100% + 10% pitch, pitch, index)

    // Repeatly ding for 35 or more points
    for i ≤ (points - 35) / 10:
        delay(play_sound, 12 i, {sound: big_points_sound})



/* `true` if in landscape layout mode */
def landscape():
    return SCREEN_SIZE.x + 28 > SCREEN_SIZE.y

    
    
def set_hooks():
    if not notification_hook:
        notification_hook = add_frame_hook(update_notifications, ∅, ∞, "all")
    
    if not input_hook:
        input_hook = add_frame_hook(detect_input, ∅, ∞, "all")
    
    if not time_hook:
        time_hook = add_frame_hook(_update_frame_utc_now, ∅, ∞, "all")
        
    if not resolution_hook:
        // Fill the screen even at non-quadplay aspect ratios
        // for a good mobile experience. See also `DEBUG.PORTRAIT`
        device_control("set_mouse_cursor", "pointer")
        
        if DEBUG.LANDSCAPE:
            set_screen_size(xy(384, 224))
        else if DEBUG.PORTRAIT:
            device_control("enable_feature", "custom_screen_size")
            set_screen_size(xy(224, 484))
        else:
            resolution_hook = continuously_set_screen_size_to_window("smaller", 224)



/* Cooldown used in `draw_timer()`. Reset in `Play.enter` */
let last_countdown_sound_time

/* Draws the count-down timer for `end_time` relative to the board, and handles
   the countdown beeping and flashing. Returns distored time left. */
def draw_timer(board_pos):
    // Real seconds
    const real_time_left = max(0, end_time - frame_utc_now)
    
    // Remapped to shorten midgame and extend endgame tension
    let time_left = real_time_left
    
    if not in_waiting_room:
        // Varies per player because they may have entered late
        const game_total_time = end_time - start_time
        
        // Real time at which we pivot to expanding time
        const pivot = TIMER.REMAP_SECONDS / TIMER.END_TIME_SCALE
        
        // How much to scale time before the pivot
        const begin_time_scale = (game_total_time - pivot) / (game_total_time - TIMER.REMAP_SECONDS)
        
        if time_left > pivot:
            time_left = (time_left - pivot) * begin_time_scale + TIMER.REMAP_SECONDS
        else:
            time_left *= TIMER.END_TIME_SCALE
        
    // Display slightly less time than is actually available
    // so it doesn't feel like we're ending too abruptly on 0
    time_left -= 3/60
    
    const pos = board_pos + xy(-½, -½) * get_board_pixel_size() - xy(-28, 16)
    draw_text({
        pos: pos,
        font: score_font,
        text: format_number(time_left, "timer"),
        color: if in_waiting_room then #0F0 else #FFF,
        y_align: "center",
        x_align: "right"})
        
    if time_left > 0.1 and time_left < TIMER.BEEP_SECONDS + 0.5:
        if |loop(time_left, -0.5, 0.5)| ≤ 3/60 and now() - last_countdown_sound_time > 0.25:
            // Play on the second turnover exactly (so it aligns with the global clock instead of local frames)
            // but ensure that we play only once per timeout, converting from time to frames
            last_countdown_sound_time = now()
            play_sound(timer_countdown_sound, 150%)
            // Pulse in case sound is off
            player.background_color = #FFF
        else:
            // Fade back towards normal
            player.background_color = lerp(player.background_color, BOARD_COLOR, 4%)
    
    return time_left
    


def draw_round_selection(pos, radius):
    draw_disk(pos - xy(0, 1), radius + 0.5, ∅, #FFF, 2)
    draw_disk(pos - xy(0, 1), radius + 1.5, CURSOR_COLOR, ∅, -0.5)
    draw_disk(pos - xy(0, 1), radius + 4.5, rgba(CURSOR_COLOR, 25%), ∅, -0.6)
    draw_disk(pos - xy(0, 1), radius + 7.5, rgba(CURSOR_COLOR, 15%), ∅, -0.7)



/* If `activate_callback` is ∅, then the button is drawn disabled.

   `name` is a unique identifier
   
   If `sprite` is ∅, do not draw the button
   
   Returns the button region. */
def handle_ability_button(index, name, caption, sprite, gamepad_button, activate_callback):
    
    const radius = 14
    const region = {
        pos: xy(radius + 4 + 48 index, SCREEN_SIZE.y - radius - 1),
        size: radius * xy(2, 2),
        shape: "disk"}
        
    const enabled = activate_callback
    
    // First call this frame for any button; deselect all on hover
    if touch.hover and game_frames > handle_ability_button.last_frame:
        handle_ability_button.selected_button = ∅
    handle_ability_button.last_frame = game_frames
    
    if enabled and touch.hover and overlaps(region, touch.hover) and not player.using_gamepad:
        handle_ability_button.selected_button = name
    
    if handle_ability_button.selected_button ≠ name:
        // NOT selected
        draw_disk(region.pos, radius, if sprite then (if enabled then #EEE else DISABLED_ABILITY_COLOR) else ∅, if not sprite then DISABLED_ABILITY_COLOR else ∅)
    
    draw_text({
        pos: region.pos - xy(0, ½ region.size.y + 7),
        font: leaderboard_font,
        color: if handle_ability_button.selected_button == name then #FFF else (if enabled then #EEE else DISABLED_ABILITY_COLOR),
        outline: if handle_ability_button.selected_button == name then rgba(CURSOR_COLOR, 50%) else ∅,
        text: caption})
    
    if sprite:     
        draw_sprite({sprite: sprite, pos: region.pos, opacity: (if enabled then 100% else 125% DISABLED_ABILITY_COLOR.a)})
    
    // Special case for the auto button, where the sprite itself shows a number
    if name == "Remix" and size(player.auto_list):
        // Save this position for later score animation
        player.auto_pos = region.pos
        draw_text({
            text: size(player.auto_list),
            pos: region.pos + 1,
            font: tile_font,
            color: if enabled then HIGHLIGHT_COLOR else rgba(HIGHLIGHT_COLOR, 40%),
            outline: if enabled then #FFF else #FFF5})
    
    if enabled:
        if player.using_gamepad:
            draw_text({
                pos: region.pos + xy(80% radius, 70% radius), 
                color: #fff,
                outline: #000,
                font: score_font,
                x_align: "left",
                z: 20,
                text: joy.prompt[gamepad_button]})
            
        if handle_ability_button.selected_button == name:
            draw_round_selection(region.pos, radius)
            
        if (mode_frames > 10 and 
            ((touch.pressed_a and overlaps(touch.xy, region))
            or joy.pressed_q)):
            activate_callback()

    return region

handle_ability_button.last_frame = 0



/* Renders and handles user input for the aux button next to the score and the
   ability buttons on the bottom of the screen.
   
   If `aux_allow_b` then the (b) button as well as the (f) button can activate
   the aux (used in Free Mode for keyboard backspace).
   
   Set a callback to ∅ for any button to render it disabled. */
def handle_buttons(
    free_sprite, free_caption, free_callback,
    auto_sprite, auto_callback,
    aux_sprite,  aux_callback, aux_allow_b default false):

    // No abilities except rotate when in the waiting room
    if not in_waiting_room:
        if player.has_ability["Free Mode"]:
            const region = handle_ability_button(0, "Free", free_caption, free_sprite, if free_callback then "(q)" else ∅, free_callback)
            if not player.has_achievement["Free Mode Word"]:
                if get_mode() ≠ FreeMode:
                    draw_tutorial(region.pos - xy(0, 20), "Enter\nFree Mode", ∅, "left")
            else if not player.has_achievement["Exit Free Mode"] and get_mode() == FreeMode:
                draw_tutorial(region.pos - xy(0, 20), "Leave\nFree Mode", ∅, "left")
                
        // The "Similar" display becomes the "Auto" button when active
        if player.has_ability["Scry Remixes"]:
            todo("Bug: Auto button disappears when used until mouse moves")
            handle_ability_button(
                1,
                "Remix",
                if player.has_ability["Remix × 2"] then "Remix × " + player.auto_uses_left else "Remix",
                if player.has_ability["Remix"] then auto_sprite else ∅,
                if player.has_ability["Remix"] and auto_callback then "(d)" else ∅,
                if player.has_ability["Remix"] then auto_callback else ∅)

    if player.has_ability["Rotate"] and aux_sprite:
        const region = {
            pos: get_board_pos() + xy(-4, -16) + xy(½, -½) get_board_pixel_size(), 
            size: 140% aux_sprite.size}

        if aux_callback and touch.hover and overlaps(region, touch.hover) and not player.using_gamepad:
            handle_ability_button.selected_button = "aux"

        draw_sprite({
            sprite: aux_sprite,
            pos: region.pos,
            override_color: if handle_ability_button.selected_button == "aux" then CURSOR_COLOR else ∅,
            opacity: if aux_callback then 100% else DISABLED_ABILITY_COLOR.a})

        if aux_callback:
            if aux_sprite == aux_icon.rotate and not player.has_achievement["Rotate Board"]:
                draw_tutorial(region.pos, "Rotate\nthe\nboard", 90°, "right")

            if player.using_gamepad:
                draw_text({font: button_prompt_font, text: player.gamepad.prompt["(f)"], x_align: "right", pos: region.pos + xy(-5, 7), color: #FFF, outline: #000, z: 10})

            // Slightly oversize the aux button touch area, as they are small
            if (touch.pressed_a and overlaps(region, touch.xy)) or (aux_allow_b and joy.pressed_b) or joy.pressed_f:
                aux_callback()



/* Draw a tutorial arrow. `pos` is the position of the target to highlight. */
def draw_tutorial(pos, text, angle default 270°, text_x_align, text_y_align):
    const bounce = ⌊mode_frames / 30⌋ mod 2

    if angle == 0°:
        text_x_align = text_x_align default "right"        
        text_y_align = text_y_align default "center"
    else if angle == 90°:
        text_x_align = text_x_align default "center"
        text_y_align = text_y_align default "top"
    else if angle == 180°:
        text_x_align = text_x_align default "left"
        text_y_align = text_y_align default "center"
    else if angle == 270°:
        text_x_align = text_x_align default "center"
        text_y_align = text_y_align default "bottom"

    const args = {
        sprite: tutorial_arrow[0][0],
        angle: angle,
        pos: pos - angle_to_xy(angle) * (20 + bounce),
        z: TUTORIAL_Z}
        
    // Drop shadow
    draw_sprite({
        …args,
        pos: args.pos + xy(0, 1),
        override_color: #000,
        opacity: 50%})
        
    draw_sprite(args)
        
    draw_text({
        font: score_font,
        text: text,
        pos: pos - angle_to_xy(angle) * (30 + bounce) + xy(if angle ≠ 0° then {left: -6, center: 0, right: +6}[text_x_align] else 0, 0),
        color: #FFF,
        outline: #000,
        shadow: #0008,
        x_align: text_x_align,
        y_align: text_y_align,
        z: TUTORIAL_Z})


//////////////////////////////////////////////////////////////////////////////////////////////////


// Initialize the background words
for y < 20:
    let s = random_safe_word()
    while size(s) < 250:
        s += " " + random_safe_word()
    background_word_array[y] = s

