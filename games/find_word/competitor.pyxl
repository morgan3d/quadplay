/* Information about other players online (or virtual ones) used by Intermission */

/* 
 
   See `make_competitor()` 
      
   */
const competitor_array = []

let player_competitor

/* Competitors winning each award */
const award_winner = {
    best_word: ∅,
    best_rare: ∅,
    longest: ∅,
    most_words: ∅,
    most_rare_words: ∅}


/* `word_list` is Q-encoded. `text` values are Q-decoded. */
def make_competitor():
    return {
        /////////////////////////////////////////////////
        // Properties that are immediately overridden on on construction
        avatar: ∅,
        score: 0,
        
        // Named "best" to align with stats
        best_freestyle_text: "",
        word_list: [],
        freestyle_word_list: [],
        
        // Evil characters do not give or receive aura XP
        enemy: false,

        remixes: 0,
        remix_words: 0,
        best_remix: 0,
        
        /////////////////////////////////////////////////
        // Computed by analyze
        best_word_points: 0,
        
        beat_vil_regular_match: 0,

        // This is for a SINGLE freestyle word
        best_freestyle_word_points: 0,
        best_freestyle_word_text: "",

        // This is for the entire freestyle sequence, including
        // wildcard if available. Named "best" to align with stats.
        // best_freestyle_text is defined above because it is not
        // computed by analyze
        best_freestyle_points: 0,

        best_rare_points: 0,
        best_rare_text: "",

        rare_word_list: [],
        
        badges: "",
        
        // Special properties for npc bots. These don't need to be transmitted,
        // they are only used on the machine that generated them
        npc: {}}
    
    

/* Are they a friend of the player_competitor */
def competitor_is_friend(competitor):
    todo("Remove when we have a friending UI")
    // For now, friend all humans, NPCs once unlocked, and the few bots who pretend to be human
    return ((competitor.avatar.id == NPC.MOO.ID and player.has_ability["Friend of Moo"]) or
            (competitor.avatar.id == NPC.CAF.ID and player.has_ability["Friend of caf"]) or    
            (competitor.avatar.id == NPC.MZK.ID and player.has_ability["Meet Mz. Kiwi"]) or    
            (competitor.avatar.id == NPC.DRQ.ID and player.has_ability["Meet Dr. Quandary"]) or
            (competitor.avatar.id == NPC.MSP.ID and player.has_ability["Meet Miss Pelican"]) or
            ((competitor ≠ player_competitor) and (player.friends[competitor.avatar.id] or
             competitor.avatar.appears_human or
             not competitor.avatar.bot)))
        


/* Convert the local player into a competitor */
def make_player_competitor():
    
    // Trim best_freestyle_text to the used length
    let max_free_len = 0
    for word in player.history.free:
        max_free_len = max(size(word), max_free_len)
        
    const competitor = {
        …make_competitor(),
        avatar: player.avatar,
        score: player.score,
        remixes: player.remixes,
        remix_words: player.remix_words,
        best_remix: player.best_remix,
        best_freestyle_text: q_decode(slice(player_free_row_pattern(player), 0, max_free_len))}

    for list in [
        [player.history.list, competitor.word_list],
        [player.history.free, competitor.freestyle_word_list]]:
        for entry in list[0]:
            push(list[1], {word: entry.word, points: entry.points})
    
    return competitor



/* Called from `Intermission.enter` */
def competitor_analyze(competitor_array):
    // How many players have each word; used for 
    // identifying rare words
    const count = {}
    
    const empty_template = make_competitor()
    
    // Compute everyone's best results
    for competitor in competitor_array:
        // Competitor data coming in over the network may be from clients that
        // are using an old version and so are missing some fields. Upgrade
        // those.
        for value at field in empty_template:
            if competitor[field] == ∅:
                competitor[field] = clone(value)
        
        // Censor names by slicing off the 2nd letter, if inappropriate,
        // and replacing common letter substitutions to prevent casual
        // looks-like thwarting
        const looks_like = lowercase(replace(competitor.avatar.name, LOOKS_LIKE))
        if offensive[looks_like] or sensitive[looks_like]:
            competitor.avatar.name = competitor.avatar.name[0] + competitor.avatar.name[2] + " "
        
        // Reset to recompute from word list
        competitor.best_freestyle_points = 0
        
        for prefix in ["", "freestyle_"]:
            for word, points in entry in competitor[prefix + "word_list"]:
                // Increment the count
                count[word] = (count[word] default 0) + 1                
                const text = q_decode(word)
                
                if points > competitor["best_" + prefix + "word_points"]:
                    competitor["best_" + prefix + "word_points"] = points
                    competitor["best_" + prefix + "word_text"] = text
                    
                if size(text) > size(competitor["longest_" + prefix + "text"]):
                    competitor["longest_" + prefix + "text"] = text

                if prefix == "freestyle_":                        
                    competitor.best_freestyle_points += points       

    
    // Count at which a word is rare
    const rare_threshold = max(1, ⌊⅙ size(competitor_array)⌋)

    // Find the best rare word for each competitor
    for competitor in competitor_array:          
        for word, points in entry in competitor.word_list:
            if count[word] ≤ rare_threshold:
                // This word has appeared very few times
                push(competitor.rare_word_list, entry)
                
                if points > competitor.best_rare_points:
                    competitor.best_rare_points = points
                    competitor.best_rare_text = q_decode(word)
    
    // Update the history rare fields for the player competitor
    // as these are used for display. We don't need this for others
    for entry in player.history.list:
        if count[entry.word] ≤ rare_threshold:
            entry.rare = true
    
    sort(competitor_array, "score", true)
    
    // Find VIL, and give everyone ahead of VIL credit for beating them
    let found_vil = 0
    for j < size(competitor_array):
        // Work backwards from the lowest to highest score--anyone ahead of 
        // VIL records a win
        const competitor = competitor_array[size(competitor_array) - 1 - j]
        competitor.beat_vil_regular_match += found_vil
        found_vil = if found_vil or (competitor.avatar.id == "BOT_VIL") then 1 else 0
    
    competitor_assign_awards(competitor_array)


    
/* Helper for `competitor_analyze()`. Sets the `_winner` globals
   and assigns the `competitor.badges` strings. Sorts the competitors
   by score. */
def competitor_assign_awards(competitor_array):
    const award_array = [
        {field: "best_word_points", award: "best_word",         measure: pass_through, field2: ∅},
        {field: "best_rare_points", award: "best_rare",         measure: pass_through, field2: ∅},
        {field: "longest_text",     award: "longest",           measure: size,         field2: ∅},
        {field: "word_list",        award: "most_words",        measure: size,         field2: "freestyle_word_list"},
        {field: "rare_word_list",   award: "most_rare_words",   measure: size,         field2: ∅}]
    
    // Find the winner in each category. Ties are broken
    // by total score by running in order after that sort
    for award in keys(award_winner):
        award_winner[award] = competitor_array[0]
    
    for competitor at i in competitor_array:
        competitor.rank = i + 1
        for field, field2, award, measure in entry in award_array:
            if measure(competitor[field]) + (if field2 then measure(competitor[field2]) else 0) > measure(award_winner[award][field]) + (if field2 then measure(award_winner[award][field2]) else 0):
                award_winner[award] = competitor
            
    // Now loop again and give badges, including for ties:
    for competitor in competitor_array:
        for field, field2, award, measure in entry in award_array:
            if measure(competitor[field]) + (if field2 then measure(competitor[field2]) else 0) == measure(award_winner[award][field]) + (if field2 then measure(award_winner[award][field2]) else 0):
                competitor.badges += BADGE_TABLE[award]
        