/* Information about other players online (or virtual ones) used by Intermission */

/* 
   ```
   {
        avatar
        text
        badges
   
        num_rare
        longest_size
        longest_text
        best_word_points
        best_word_text
        best_free_word_points
        best_free_word_text
        best_rare_points
        best_rare_text
        word_list
        free_word_list
        score
    }```
   
   
   `word_list` is Q-encoded. `text` values are Q-decoded.
   
   */
const competitor_array = []

let player_competitor

// Competitors winning each award
let best_word_winner
let best_rare_winner
let longest_winner
let most_words_winner


/* Are they a friend of the player_competitor */
def competitor_is_friend(competitor):
    todo("Remove when we have a friending UI")
    // For now, friend all humans. Bots have a `base_ability` property
    return ((competitor.avatar.id == MOO_ID and player.has_ability["Friend of Moo"]) or
            (competitor.avatar.id == CAF_ID and player.has_ability["Friend of caf"]) or    
            ((competitor ≠ player_competitor) and (player.friends[competitor.avatar.id] or
             not competitor.avatar.bot)))
        


/* Convert the local player into a competitor */
def make_player_competitor():
    const competitor = {
        avatar: player.avatar,
        score: player.score,
        word_list: [],
        free_list: []}

    for list in [
        [player.history.list, competitor.word_list],
        [player.history.free, competitor.free_list]]:
        for entry in list[0]:
            push(list[1], entry.word)
    
    return competitor



/* Called from `Intermission.enter` */
def competitor_analyze(competitor_array):    
    // How many players have each word; used for 
    // identifying rare words
    const count = {}
    
    const board_word_set = array_to_set(player.board.word_list)
        
    // Compute everyone's best results
    for competitor in competitor_array:
        competitor.badges = ""
        
        // Censor names by slicing off the 2nd letter, if inappropriate,
        // and replacing common letter substitutions to prevent casual
        // looks-like thwarting
        if offensive[lowercase(replace(competitor.avatar.name, LOOKS_LIKE))] or sensitive[lowercase(competitor.avatar.name)]:
            competitor.avatar.name = competitor.avatar.name[0] + competitor.avatar.name[2] + " "


        competitor.best_free_word_points = 0
        competitor.best_free_word_text = ""
        for word in competitor.free_list:
            const points = score_word(word)
            
            // If a competitor's free word depends on wild tiles and this player
            // doesn't have wild unlocked, then censor it
            if not board_word_set[word] and not player.has_ability["Wild"]:
                word = hide_text(word)

            if points > competitor.best_free_word_points:
                competitor.best_free_word_points = points
                competitor.best_free_word_text = q_decode(word)
            

        competitor.best_word_points = 0
        competitor.longest_size = 0
        for word in competitor.word_list:
            // Increment the count
            count[word] = (count[word] default 0) + 1
            
            const points = score_word(word)
            const text     = q_decode(word)
                        
            if points > competitor.best_word_points:
                competitor.best_word_points = points
                competitor.best_word_text = text
        
            if size(text) > competitor.longest_size:
                competitor.longest_size = size(text)
                competitor.longest_text = text

    // Count at which a word is rare
    const rare_threshold = max(1, ⌊⅙ size(competitor_array)⌋)

    // Find the best rare word for each competitor
    for competitor in competitor_array:
    
        competitor.num_rare = 0
        competitor.best_rare_points = 0
        competitor.best_rare_text = 0
    
        for word in competitor.word_list:
            if count[word] ≤ rare_threshold:
                const points = score_word(word)
                const text = q_decode(word)
                
                // This word has appeared very few times
                ++competitor.num_rare
                
                if points > competitor.best_rare_points:
                    competitor.best_rare_points = points
                    competitor.best_rare_text = text
    
            // If a competitor's free word depends on wild tiles and this player
            // doesn't have wild unlocked, then censor it
            if not board_word_set[word] and not player.has_ability["Wild"]:
                word = hide_text(word)
                const text = q_decode(word)
                if competitor.best_rare_text == text:
                    competitor.best_rare_text = hide_text(competitor.best_rare_text)
                if competitor.best_word_text == text:
                    competitor.best_word_text = hide_text(competitor.best_word_text)
                if competitor.longest_text == text:
                    competitor.longest_text = hide_text(competitor.longest_text)

    
    // Update the history rare fields for the player competitor
    // as these are used for display. We don't need this for others
    for entry in player.history.list:
        if count[entry.word] ≤ rare_threshold:
            entry.rare = true
    
    competitor_assign_awards(competitor_array)


    
/* Helper for `competitor_analyze()`. Sets the `_winner` globals
   and assigns the `competitor.badges` strings. Sorts the competitors
   by score. */
def competitor_assign_awards(competitor_array):
    // Rank all competitors by score
    sort(competitor_array, "score", true)
    
    // Find the winner in each category. Ties are broken
    // by total score by running in order after that sort
    best_word_winner  = competitor_array[0]
    best_rare_winner  = competitor_array[0]
    longest_winner    = competitor_array[0]
    most_words_winner = competitor_array[0]
    
    for competitor in competitor_array:
        if competitor.best_word_points > best_word_winner.best_word_points:
            best_word_winner = competitor
            
        if competitor.best_rare_points > best_rare_winner.best_rare_points:
            best_rare_winner = competitor

        if competitor.longest_size > longest_winner.longest_size:
            longest_winner = competitor
            
        if size(competitor.word_list) > size(most_words_winner.word_list):
            most_words_winner = competitor

    // Now loop again and give badges, including for ties:
    for competitor in competitor_array:
        // Put in the same order as the award stages
        if competitor.best_word_points == best_word_winner.best_word_points:
            competitor.badges += BADGE_TABLE.best_word
        
        if competitor.best_rare_points == best_rare_winner.best_rare_points:
            competitor.badges += BADGE_TABLE.best_rare

        if competitor.longest_size == longest_winner.longest_size:
            competitor.badges += BADGE_TABLE.longest

        if size(competitor.word_list) == size(most_words_winner.word_list):
            competitor.badges += BADGE_TABLE.most_words
    
