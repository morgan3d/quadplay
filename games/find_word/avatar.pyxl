/* Total number of avatar sprites available. In the actual 
   spritesheet, the last few are unused, so we stop this 
   count early. Note that there are other restrictions
   on which avatars can be used. */
const AVATAR_SPRITE_COUNT = avatar_sprite.size_in_sprites.x * ½ avatar_sprite.size_in_sprites.y - 8

def avatar_save(avatar):
    // Other properties are recomputed on load
    save_local("avatar", {
        name: avatar.name,
        id: avatar.id,
        sprite_index: avatar_sprite_to_linear_index(avatar.sprite)})



def make_bot_avatar(descriptor):
    return {
        // Bots face left
        sprite: evaluate_constant_expression(descriptor.sprite).x_flipped,
        name: descriptor.name,
        bot: true,
        evil: descriptor.npc and descriptor.npc.evil,
        appears_human: descriptor.appears_human default false,
        id: "BOT_" + descriptor.name}
        
        
        
def avatar_load():
    let avatar_data = load_local("avatar")
    
    if not avatar_data:
        avatar_data = {
            sprite_index: random_integer(0, AVATAR_SPRITE_COUNT - 1),
            id: "U" + round(1000 utc_now()),
            name: "?  "}
        
        // Persist the random avatar        
        save_local("avatar", avatar_data)

    const sprite = avatar_sprite_from_linear_index(avatar_data.sprite_index)
    
    return {
        sprite: sprite,
        // level will be computed from player stats when they are loaded
        level: ∅,
        id: avatar_data.id default "U" + round(1000 utc_now()),
        color: avatar_compute_color(sprite),
        name: avatar_data.name}
        
    

def avatar_compute_color(sprite):
    const color = hsv(sprite.mean_color)
    return rgb({h: color.h, s: 130% color.s, v: max(color.v, 70%)})


        
/* Draws an avatar sprite with the specified arguments. The args object should contain
   an `avatar` field and any arguments accepted by draw_sprite() such as `pos`, `scale`, 
   `opacity`, `z`, `override_color`, etc. If `sprite` is provided in args, it will 
   override the avatar's default sprite. 
   
   Accepts an extra "outline" argument that is the color of an outline to draw. */
def avatar_draw(args):
    const scale = args.scale default 100%
    let sprite = args.sprite default args.avatar.sprite

    // Idle animation for avatar
    const toggle = ⌊mode_frames / 30⌋ mod 2
    if toggle:
        sprite = sprite_transfer_orientation(sprite, sprite.spritesheet[sprite.tile_index.x][sprite.tile_index.y + 1])
        
    // Aura effect. Minimize the animation aspect when in-game to avoid thwarting the frame sleeper
    if args.avatar.level ≥ ABILITY_TABLE.Aura.level:
        
        const aura_highlight = if args.avatar.evil then #000 else #fff
        const aura_z = (args.z default 0) - ε
        
        const pulse = (
            if get_mode() == Play or get_mode() == Freestyle or get_mode() == Rotate
            then 15%
            // Round to the nearest ¼ so that the animation does not increase the frame rate
            else (20% oscillate(floor(mode_frames / 60, ¼), 0, 1)))
            
        draw_sprite({
            …args, 
            sprite: sprite, 
            override_color: aura_highlight, 
            scale: (112% + ½ pulse) * scale, 
            z: aura_z})
            
        draw_sprite({
            …args, 
            sprite: sprite, 
            override_color: lerp(args.avatar.color, aura_highlight, 20%),
            scale: (130% + pulse) * scale, 
            opacity: 40%, 
            z: aura_z})
            
        if args.avatar.level ≥ ABILITY_TABLE["Enhanced Aura"].level:   
            draw_sprite({
                …args, 
                sprite: avatar_sprite[36][16 + toggle].y_flipped, 
                override_color: args.avatar.color,
                scale: (140% + pulse) * scale * (if args.avatar.evil then 110% else 100%), 
                opacity: 75%, 
                z: aura_z})
                
            draw_sprite({
                …args, 
                sprite: avatar_sprite[36][16 + toggle].y_flipped, 
                override_color: aura_highlight,
                scale: (130% + ¾ pulse) * scale * (if args.avatar.evil then 115% else 100%), 
                opacity: 70%, 
                z: aura_z})
            
    if args.outline:
        for -1 ≤ d ≤ +1:
            draw_sprite({…args, pos: args.pos + xy(d, 0), sprite: sprite, override_color: args.outline})
            draw_sprite({…args, pos: args.pos + xy(0, d), sprite: sprite, override_color: args.outline})
            
    draw_sprite({…args, sprite: sprite})



def avatar_draw_large(avatar, pos, background default true, color, shadow default #000, spin default false, facing default 1):
    draw_text({
        font: score_font,
        text: trim_spaces(avatar.name),
        color: color default (if background then avatar.color else player.selection_color),
        shadow: shadow,
        pos: pos + xy(0, 26),
        z: 5})

    avatar_draw({
        avatar: avatar,
        sprite: if spin and (⌊(game_frames + 15) / 30⌋ mod 2) then avatar.sprite.x_flipped else ∅,
        pos: pos + xy(0, -1),
        scale: 200% xy(facing, 1),
        z: 5})



/* Computes an index of this sprite so that we can get the "next" and "previous". */
def avatar_sprite_to_linear_index(sprite):
    const index = sprite.tile_index.x + ⌊½ sprite.tile_index.y⌋ * sprite.spritesheet.size_in_sprites.x
    assert(index ≥ 0 and index < AVATAR_SPRITE_COUNT)
    return index



/* Inverse of `avatar_sprite_to_linear_index()` */
def avatar_sprite_from_linear_index(index):
    assert(index ≥ 0 and index < AVATAR_SPRITE_COUNT)

    const x = index mod avatar_sprite.size_in_sprites.x
    const y = 2 ⌊index / avatar_sprite.size_in_sprites.x⌋
    
    assert(x < avatar_sprite.size_in_sprites.x and x ≥ 0)
    assert(y < avatar_sprite.size_in_sprites.y - 1 and y ≥ 0)
    
    return avatar_sprite[x][y]



def avatar_next_sprite(sprite, dir default +1):
    // Advance one
    sprite = avatar_sprite_from_linear_index(loop(avatar_sprite_to_linear_index(sprite) + dir, AVATAR_SPRITE_COUNT))
    
    if contains(AVATAR.RESTRICTED_INDEXES, sprite.tile_index, equivalent) or contains(AVATAR.FAMILIAR_INDEXES, sprite.tile_index, equivalent):
        return avatar_next_sprite(sprite, dir)
    else:
        return sprite



def avatar_next_name_letter(letter, dir default +1):
    const i = loop(find(AVATAR.NAME_ALPHABET, letter) + dir, size(AVATAR.NAME_ALPHABET))
    return AVATAR.NAME_ALPHABET[i]

    
    