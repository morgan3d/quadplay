/* Total number of avatar sprites available. In the actual 
   spritesheet, the last few are unused, so we stop this 
   count early. Note that there are other restrictions
   on which avatars can be used. */
const AVATAR_SPRITE_COUNT = avatar_sprite.size_in_sprites.x * ½ avatar_sprite.size_in_sprites.y - 9

def avatar_save(avatar):
    // Other properties are recomputed on load
    save_local("avatar", {
        name: avatar.name,
        id: avatar.id,
        sprite_index: avatar_sprite_to_linear_index(avatar.sprite)})



def avatar_load():
    let avatar_data = load_local("avatar")
    
    if not avatar_data:
        avatar_data = {
            sprite_index: random_integer(0, AVATAR_SPRITE_COUNT - 1),
            id: "U" + round(1000 utc_now()),
            name: "?  "}
        
        // Persist the random avatar        
        save_local("avatar", avatar_data)

    const sprite = avatar_sprite_from_linear_index(avatar_data.sprite_index)
    
    return {
        sprite: sprite,
        // level will be computed from player stats when they are loaded
        level: ∅,
        id: avatar_data.id default "U" + round(1000 utc_now()),
        color: avatar_compute_color(sprite),
        name: avatar_data.name}
        
    

def avatar_compute_color(sprite):
    const color = hsv(sprite.mean_color)
    return rgb({h: color.h, s: 130% color.s, v: max(color.v, 70%)})


        
/* Draws an avatar sprite with the specified arguments. The args object should contain
   an `avatar` field and any arguments accepted by draw_sprite() such as `pos`, `scale`, 
   `opacity`, `z`, `override_color`, etc. If `sprite` is provided in args, it will 
   override the avatar's default sprite. */
def avatar_draw(args):
    let sprite = args.sprite default args.avatar.sprite
    
    const scale = args.scale default 100%

    // Idle animation for avatar
    if ⌊mode_frames / 30⌋ mod 2:
        sprite = sprite_transfer_orientation(sprite, sprite.spritesheet[sprite.tile_index.x][sprite.tile_index.y + 1])
        
    // Aura effect. Don't play in game to avoid thwarting the frame sleeper
    if args.avatar.level ≥ ABILITY_TABLE.Aura.level and get_mode() ≠ Play and get_mode() ≠ Freestyle and get_mode() ≠ Rotate:
        const aura_z = (args.z default 0) - ε
        const pulse = 20% oscillate(mode_frames / 45, 0, 1)
        draw_sprite({…args, sprite: sprite, override_color: #FFF, scale: (115% + ½ pulse) * scale, opacity: 50%, z: aura_z})
        draw_sprite({…args, sprite: sprite, override_color: #FF0, scale: (140% + pulse) * scale, opacity: 20%, z: aura_z})
        
        if args.avatar.level ≥ ABILITY_TABLE["Enhanced Aura"].level:            
            for i < 2:
                const dir = random_on_circle()
                particles_spawn(particle_array, args.pos + 6 dir * scale, random(0.08, 0.17) * dir, lerp(args.avatar.color, #FFF, ξ), aura_z - ε, 49 ‖scale‖)
        
    draw_sprite({…args, sprite: sprite})



def avatar_draw_large(avatar, pos, background default true, color, shadow default #000, spin default false, facing default 1):
    draw_text({
        font: score_font,
        text: trim_spaces(avatar.name),
        color: color default (if background then avatar.color else player.board.selection_color),
        shadow: shadow,
        pos: pos + xy(0, 26),
        z: 5})

    avatar_draw({
        avatar: avatar,
        sprite: if spin and (⌊(game_frames + 15) / 30⌋ mod 2) then avatar.sprite.x_flipped else ∅,
        pos: pos + xy(0, -1),
        scale: 200% xy(facing, 1),
        z: 5})



/* Computes an index of this sprite so that we can get the "next" and "previous". */
def avatar_sprite_to_linear_index(sprite):
    const index = sprite.tile_index.x + ⌊½ sprite.tile_index.y⌋ * sprite.spritesheet.size_in_sprites.x
    assert(index ≥ 0 and index < AVATAR_SPRITE_COUNT)
    return index



/* Inverse of `avatar_sprite_to_linear_index()` */
def avatar_sprite_from_linear_index(index):
    assert(index ≥ 0 and index < AVATAR_SPRITE_COUNT)

    const x = index mod avatar_sprite.size_in_sprites.x
    const y = 2 ⌊index / avatar_sprite.size_in_sprites.x⌋
    
    assert(x < avatar_sprite.size_in_sprites.x and x ≥ 0)
    assert(y < avatar_sprite.size_in_sprites.y - 1 and y ≥ 0)
    
    return avatar_sprite[x][y]



def avatar_next_sprite(sprite, dir default +1):
    // Advance one
    sprite = avatar_sprite_from_linear_index(loop(avatar_sprite_to_linear_index(sprite) + dir, AVATAR_SPRITE_COUNT))
    
    if contains(AVATAR.RESTRICTED_INDEXES, sprite.tile_index, equivalent):
        return avatar_next_sprite(sprite, dir)
    else:
        return sprite



def avatar_next_name_letter(letter, dir default +1):
    const i = loop(find(AVATAR.NAME_ALPHABET, letter) + dir, size(AVATAR.NAME_ALPHABET))
    return AVATAR.NAME_ALPHABET[i]

    
    