/* Total number of avatar sprites available. In the actual 
   spritesheet, the last few are unused, so we stop this 
   count early. Note that there are other restrictions
   on which avatars can be used. */
const AVATAR_SPRITE_COUNT = avatar_sprite.size_in_sprites.x * ½ avatar_sprite.size_in_sprites.y - 9

    
def avatar_save(avatar):
    // Other properties are recomputed on load
    save_local("avatar", {
        name: avatar.name,
        id: avatar.id,
        sprite_index: avatar_sprite_to_linear_index(avatar.sprite)})



def avatar_load():
    let avatar_data = load_local("avatar")
    
    if not avatar_data:
        avatar_data = {
            sprite_index: random_integer(0, AVATAR_SPRITE_COUNT - 1),
            id: "U" + round(1000 utc_now()),
            name: "?  "}
        
        // Persist the random avatar        
        save_local("avatar", avatar_data)

    const sprite = avatar_sprite_from_linear_index(avatar_data.sprite_index)
    
    return {
        sprite: sprite,
        // level will be computed from player stats when they are loaded
        level: ∅,
        id: avatar_data.id default "U" + round(1000 utc_now()),
        color: avatar_compute_color(sprite),
        name: avatar_data.name}
        
    

def avatar_compute_color(sprite):
    const color = hsv(sprite.mean_color)
    return rgb({h: color.h, s: 130% color.s, v: max(color.v, 70%)})


        
def avatar_draw_large(avatar, pos, background default true, color, shadow default #000, spin default false):
    
    draw_text({
        font: score_font,
        text: trim_spaces(avatar.name),
        color: color default (if background then avatar.color else player.board.selection_color),
        shadow: shadow,
        pos: pos + xy(0, 27),
        z: 5})

    let sprite = avatar.sprite
    
    if ⌊(game_frames + 15) / 30⌋ mod 2:
        sprite = sprite.spritesheet[sprite.tile_index.x][sprite.tile_index.y + 1]
        sprite = sprite_transfer_orientation(avatar.sprite, sprite)
        if spin: sprite = sprite.x_flipped

    draw_outlined_sprite({
        sprite: sprite.x_flipped, 
        scale: 200%, 
        pos: pos + xy(0, -1),
        z: 5})



/* Computes an index of this sprite so that we can get the "next" and "previous". */
def avatar_sprite_to_linear_index(sprite):
    const index = sprite.tile_index.x + ⌊½ sprite.tile_index.y⌋ * sprite.spritesheet.size_in_sprites.x
    assert(index ≥ 0 and index < AVATAR_SPRITE_COUNT)
    return index



/* Inverse of `avatar_sprite_to_linear_index()` */
def avatar_sprite_from_linear_index(index):
    assert(index ≥ 0 and index < AVATAR_SPRITE_COUNT)

    const x = index mod avatar_sprite.size_in_sprites.x
    const y = 2 ⌊index / avatar_sprite.size_in_sprites.x⌋
    
    assert(x < avatar_sprite.size_in_sprites.x and x ≥ 0)
    assert(y < avatar_sprite.size_in_sprites.y - 1 and y ≥ 0)
    
    return avatar_sprite[x][y]



def avatar_next_sprite(sprite, dir default +1):
    // Advance one
    sprite = avatar_sprite_from_linear_index(loop(avatar_sprite_to_linear_index(sprite) + dir, AVATAR_SPRITE_COUNT))
    
    if contains(AVATAR.RESTRICTED_INDEXES, sprite.tile_index, equivalent):
        return avatar_next_sprite(sprite, dir)
    else:
        return sprite



def avatar_next_name_letter(letter, dir default +1):
    const i = loop(find(AVATAR.NAME_ALPHABET, letter) + dir, size(AVATAR.NAME_ALPHABET))
    return AVATAR.NAME_ALPHABET[i]
    


def idle_animate_avatar(sprite, alt):
    return (
        if alt
        then sprite_transfer_orientation(sprite, sprite.spritesheet[sprite.tile_index.x][sprite.tile_index.y + 1])
        else sprite)

    
    