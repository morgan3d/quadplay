AnimateXP
════════════════════════════════════════════════════════════════════════

let last_level_displayed
let prev_xp
let prev_level
let new_xp
let xp_audio

/* For notifications */
let bonus

    
def notify_badge_bonus()
& if bonus.badge_xp > 0:
    
    const title_array = []
    for badge in player_competitor.badges:
        // Convert the badge back into a title
        let title = replace(find(BADGE_TABLE, badge), "_", " ")
        if not contains(title, "word"):
            title += " word"
        
        push(title_array, uppercase(title))

    notify_xp_bonus(
        bonus.badge_xp,
        "winning " + join(title_array, ", ", ", and ", " and ") + " in a " + size(competitor_array) + "-player match!")



def notify_word_bonus()
& if bonus.word_xp > 0:
    assert(bonus.unique_word_list ≠ ∅)
    
    let decoded = []
    for word in bonus.unique_word_list:
        push(decoded, q_decode(word))
    
    const text = (if size(bonus.unique_word_list) ≤ 7
        then join(decoded, ", ", ", and ", " and ")
        else ("" + size(bonus.unique_word_list) + " words including " + join(slice(decoded, 0, 6), ", ", ", and ")))

    notify_xp_bonus(
        bonus.word_xp,
        "discovering " + text + "!")        


enter
────────────────────────────────────────────────────────────────────────

last_level_displayed = prev_level
set_background(#000)


prev_xp = player.stats.lifetime.xp + player.stats[today_date_string()].xp
prev_level = player.avatar.level

bonus = stats_update(player.stats, player_competitor, size(competitor_array), joined_late)

// Avoid recomputing every frame during the XP animation
new_xp = player.stats.lifetime.xp + player.stats[today_date_string()].xp

// Update level based on the new total XP, as this is part of the 
// avatar computed at load and not part of the stats. Do this now 
// because we're about to save stats
player.avatar.level = xp_to_level(new_xp)

// Update the net vocabulary. Vocabulary was originally computed on load of stats
// so is not updated by stats_update.
array_to_set(bonus.unique_word_list, 1, player.vocabulary)

// Save the updated stats. Unlocked abilities are stored as part
// of the ability notification process.
if not DEBUG.INTERMISSION and not DEBUG.ANIMATE_XP:
    stats_save(player.stats)
    
notify_badge_bonus()
notify_word_bonus()


frame
────────────────────────────────────────────────────────────────────────

    
// Animation time between 0% and 100%
const τ = clamp((mode_frames - ANIMATE_XP.PRE_FRAMES) / ANIMATE_XP.FRAMES, 0%, 100%)

// Currently-displayed XP
const xp = round(lerp(prev_xp, new_xp, τ))

// Currently-displayed level
const level = xp_to_level(xp)

// Lower bound for xp bar
const xp_lo = level_to_xp(level)

// Upper bound for xp bar
const xp_hi = level_to_xp(level + 1)

// Progress bar value
const α = clamp((xp - xp_lo) / (xp_hi - xp_lo), 0%, 100%)

// Play the glissando sound
if mode_frames == ANIMATE_XP.PRE_FRAMES - 2 and player.score > 0:
    xp_audio = play_sound({sound: xp_sound, playback_rate: 10%, pitch: 200%})

if mode_frames > 1 and (last_level_displayed ≠ level):
    // Level up
    play_sound(level_up_sound)
    
    // Give the abilities after the sound has finished
    delay(grant_new_abilities, 30)

last_level_displayed = level

const flash = (level ≠ prev_level) and (⌊mode_frames / 15⌋ mod 2) and (player.score > 0)

preserving_transform:
    set_transform(½ SCREEN_SIZE)
    
    // Flash and turn pink on level up
    draw_text({
        color:   if flash then HIGHLIGHT_COLOR else #FFF,
        outline: if flash then #FFF else ∅,
        font:    leaderboard_font,
        text:    "Level " + level,
        pos:     xy(0, -26)})
        
    avatar_draw_large(player.avatar, xy(0, 0), false, #FFF)

    // XP bar outline
    const xp_rect = {corner: xy(-100, 50), size: xy(200, 10)}
    
    draw_text({font: history_font,
        color: #FFF,
        text: "New XP Earned +" + (new_xp - prev_xp),
        pos: xy(0, xp_rect.corner.y - 5),
        color: #FFF})
    
    draw_corner_rect(xp_rect.corner + xy(0, 1), xp_rect.size)
    
    // Progress bar
    draw_corner_rect(
        xp_rect.corner + 1,
        xy(α * (xp_rect.size.x - 2), xp_rect.size.y - 2), 
        HIGHLIGHT_COLOR)
    
    draw_text({font: history_font,
        color: #FFF,
        shadow: #0008,
        font: history_font,
        text: format_number(xp, "commas") + " XP",
        x_align: "right",
        y_align: "baseline",
        pos: xp_rect.corner + ½ xp_rect.size + xy(17, 2)})
        
    draw_corner_rect(xp_rect.corner, xp_rect.size, ∅, #FFF)

if frame_utc_now ≥ end_time - 1.5:
    const pos = SCREEN_SIZE - xy(24, 18)
    draw_sprite({sprite: shapes.gear, pos: pos, angle: -1.5° mode_frames, override_color: #888, scale: 50%})
    draw_text({font: history_font, text: "Saving", pos: pos + xy(0, 14), color: #888})

if frame_utc_now ≥ end_time:
    set_mode(GenerateBoard) because "Timer"
