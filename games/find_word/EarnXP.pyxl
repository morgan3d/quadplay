EarnXP
════════════════════════════════════════════════════════════════════════

let last_xp_row_displayed
let last_level_displayed
let prev_xp
let prev_level
let new_xp

/* {text, xp} objects shown sequentially to explain the XP awards  */
let xp_array

let scroll_offset

def draw_xp_table()
& preserving_transform:
    const rect_height = SCREEN_SIZE.y - EARN_XP.BAR_SECTION_HEIGHT
    
    set_clip(xy(0, 0), xy(SCREEN_SIZE.x, rect_height))
    set_transform(xy(½ SCREEN_SIZE.x - 100, scroll_offset))
    
    const τ = clamp((mode_frames - EARN_XP.TIMING.PRE_FRAMES) / EARN_XP.TIMING.TABLE_FRAMES, 0%, 100%)
    
    let y = 0
    for i < τ * size(xp_array):
        const row = xp_array[i]
        
        // Extra spacing
        // Note: Leave extra space for header row, and last line
        y += if i == last_key(xp_array) then 10 else (if row.color ≠ TABLE_ALT_ROW_COLOR then 7 else (if row.xp then 6 else 3))

        // Audio as each new XP entry is first displayed
        if i > last_xp_row_displayed:
            last_xp_row_displayed = i
            play_sound(select_tile_sound, 80%)
            
        if i == last_key(xp_array):
            // Final row
            draw_line(xy(0, y - 5), xy(200, y - 5), TABLE_ALT_ROW_COLOR)
        
        if row.xp:
            draw_text({
                text: "+" + format_number(row.xp, "commas") + " XP" default "", 
                font: leaderboard_font, 
                color: row.color,
                x_align: "right", 
                y_align: "top",
                pos: xy(180, y)})
                
        y += draw_text({
            text: row.text,
            font: row.font default leaderboard_font,
            color: row.color,
            x_align: "left",
            y_align: "top",
            wrap_width: 145,
            pos: xy(if row.xp or row.font then 16 else 0, y)}).height
            

    scroll_offset = rect_height - (y + 10)
    


def draw_xp_bar()
& preserving_transform:

    // Animation time between 0% and 100% for the bar
    const τ = clamp((mode_frames - EARN_XP.TIMING.PRE_FRAMES - EARN_XP.TIMING.TABLE_FRAMES - EARN_XP.TIMING.POST_TABLE_FRAMES - EARN_XP.TIMING.MID_FRAMES) / EARN_XP.TIMING.BAR_FRAMES, 0%, 100%)
    
    // Currently-displayed XP
    const xp = round(lerp(prev_xp, new_xp, τ))
    
    // Currently-displayed level
    const level = xp_to_level(xp)
    
    // Lower bound for xp bar
    const xp_lo = level_to_xp(level)
    
    // Upper bound for xp bar
    const xp_hi = level_to_xp(level + 1)
    
    // Progress bar value
    const α = clamp((xp - xp_lo) / (xp_hi - xp_lo), 0%, 100%)
    
    // Play the glissando sound
    if mode_frames == EARN_XP.TIMING.PRE_FRAMES + EARN_XP.TIMING.TABLE_FRAMES + EARN_XP.TIMING.POST_TABLE_FRAMES + EARN_XP.TIMING.MID_FRAMES - 2 and player.score > 0:
        play_sound({sound: xp_sound, playback_rate: 10%, pitch: 200%})
    
    if mode_frames > 1 and (last_level_displayed ≠ level):
        // Level up
        play_sound(level_up_sound)
        
        // Give the abilities after the sound has finished
        delay(grant_new_abilities, 30)
    
    last_level_displayed = level
    
    const flash = (level ≠ prev_level) and (⌊mode_frames / 15⌋ mod 2) and (player.score > 0)
    
    set_transform(xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - ½ EARN_XP.BAR_SECTION_HEIGHT))
        
    draw_sprite({sprite: player.avatar.sprite, pos: xy(-16, 3), scale: 200%})
    draw_text({text: player.avatar.name, pos: xy(8, -4), font: score_font, x_align: "left", color: #FFF})
    // Flash and turn pink on level change
    draw_text({
        color:   if flash then HIGHLIGHT_COLOR else #FFF,
        outline: if flash then #FFF else ∅,
        font:    leaderboard_font,
        text:    "Level " + level,
        x_align: "left",
        pos:     xy(8, 10)})

    // Don't draw the bar at first
    if mode_frames < EARN_XP.TIMING.PRE_FRAMES + EARN_XP.TIMING.TABLE_FRAMES + EARN_XP.TIMING.POST_TABLE_FRAMES: return
    
    // XP bar outline
    const xp_rect = {corner: xy(-100, -30), size: xy(200, 10)}
        
    draw_corner_rect(xp_rect.corner + xy(0, 1), xp_rect.size)
    
    // Progress bar
    draw_corner_rect(
        xp_rect.corner + 1,
        xy(α * (xp_rect.size.x - 2), xp_rect.size.y - 2), 
        HIGHLIGHT_COLOR)
    
    draw_text({font: history_font,
        color: #FFF,
        shadow: #0008,
        font: history_font,
        text: format_number(xp, "commas") + " XP",
        x_align: "right",
        y_align: "baseline",
        pos: xp_rect.corner + ½ xp_rect.size + xy(17, 2)})
        
    draw_corner_rect(xp_rect.corner, xp_rect.size, ∅, #FFF)
    

    
enter
────────────────────────────────────────────────────────────────────────
set_background(#000)
scroll_offset = 0

prev_xp = player.stats.lifetime.xp + player.stats[today_date_string()].xp
prev_level = player.avatar.level
last_level_displayed = prev_level
last_xp_row_displayed = 0

const discovered_word_list = stats_update(player.stats, player_competitor, size(competitor_array), joined_late)

// Compute the XP awards
xp_array = [
    {text: "Score", header: true, color: #FFF}, 
    {text: format_number(player_competitor.score, "commas") + " Points", xp: ⌈player_competitor.score * XP.VALUE.point⌉, color: TABLE_ALT_ROW_COLOR}]


if size(discovered_word_list) and player.has_ability["Discovery XP"]:
    push(xp_array, {text: "Discovered Words", color: #FFF})
    
    // To keep the length of this list managable, we group 
    // words of the same length.
    const words_by_tile_length = make_array(17, [], clone)
    for word in discovered_word_list:
        push(words_by_tile_length[size(word)], q_decode(word))

    for word_list at num_tiles in words_by_tile_length:
        if size(word_list):
            push(xp_array, {
                text: "" + size(word_list) + " × " + num_tiles + "-tile Words",
                xp: (num_tiles - 2) * XP.VALUE.unique_word_per_tile,
                color: TABLE_ALT_ROW_COLOR})
                
            push(xp_array, {
                text: join(word_list, ", "),
                font: history_font,
                color: TABLE_ALT_ROW_COLOR})
        
        
if player_competitor.badges and player.has_ability["Award XP"]:
    push(xp_array, {text: "Awards (" + size(competitor_array) + "-Player Match)", color: #FFF})

    const badge_xp = XP.VALUE.badge_per_competitor * min(size(competitor_array) - 1, 10)

    // There isn't an explicit badge for winning the match
    if player_competitor == competitor_array[0]:
        push(xp_array, {text: "Highest score", xp: badge_xp, color: TABLE_ALT_ROW_COLOR})
        
    for badge in player_competitor.badges:
        // Convert the badge back into text
        const text = replace(find(BADGE_TABLE, badge), "_", " ")
        push(xp_array, {text: capitalize(text + (if contains(text, "word") then "" else " word")), xp: badge_xp, color: TABLE_ALT_ROW_COLOR})


// Only give streak awards for games where the player
// actually earned points, otherwise it could have been
// running unmonitored in the background
if player.score > 0 and not joined_late:
    const streak = []
    
    if player.stats[today_date_string()].matches == 1:
        push(streak, {text: "First Match Today", xp: XP.VALUE.first_match_today, color: TABLE_ALT_ROW_COLOR})
    
    else if player.stats[today_date_string()].matches mod 10 == 0:
        push(streak, {
            text: "" + player.stats[today_date_string()].matches + "ᵗʰ Match Today", 
            xp: XP.VALUE.decimatch_today + 10 ⌊player.stats[today_date_string()].matches / 10 - 1⌋, 
            color: TABLE_ALT_ROW_COLOR})
    
    if size(streak):
        push(xp_array, 
            {text: "Streak", color: #FFF},
            …streak)
        
todo("Give XP for rare words")

for row in xp_array:
    player.stats[today_date_string()].xp += row.xp default 0

// Avoid recomputing every frame during the XP animation
new_xp = player.stats.lifetime.xp + player.stats[today_date_string()].xp

// Summary row
push(xp_array, {text: "Match Total", xp: new_xp - prev_xp, color: HIGHLIGHT_COLOR})
    

// Update level based on the new total XP, as this is part of the 
// avatar computed at load and not part of the stats. Do this now 
// because we're about to save stats
player.avatar.level = xp_to_level(new_xp)

// Update the net vocabulary. Vocabulary was originally computed on load of stats
// so is not updated by stats_update.
array_to_set(discovered_word_list, 1, player.vocabulary)

// Save the updated stats. Unlocked abilities are stored as part
// of the ability notification process.
if not DEBUG.INTERMISSION and not DEBUG.EARN_XP:
    stats_save(player.stats)


frame
────────────────────────────────────────────────────────────────────────

todo("Remove network debugging code")
draw_rect(xy(½ SCREEN_SIZE.x, 10), xy(224, 15), #B0FA, ∅, ∅, 100)
draw_text({
    text: "Test: " + debug_network_status,
    font: leaderboard_font,
    color: #CCC,
    outline: #000,
    shadow: #000,
    pos: xy(½ SCREEN_SIZE.x, 5),
    y_align: "top",
    z: 101})


draw_xp_table()
draw_xp_bar()


if frame_utc_now ≥ end_time - 1.5:
    const pos = SCREEN_SIZE - xy(24, 18)
    draw_sprite({sprite: shapes.gear, pos: pos, angle: -1.5° mode_frames, override_color: #888, scale: 50%})
    draw_text({font: history_font, text: "Saving", pos: pos + xy(0, 14), color: #888})

if frame_utc_now ≥ end_time:
    set_mode(GenerateBoard) because "Timer"
    
