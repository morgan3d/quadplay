EarnXP
════════════════════════════════════════════════════════════════════════
let last_xp_row_displayed
let last_level_displayed
let prev_xp
let prev_level
let new_xp

/* {text, xp, color, avatar} objects shown sequentially to explain the XP awards  */
let xp_array

/* For the xp_array. Automatically updated as words scroll off screen */
let scroll_offset


todo("Match design of the stats view for the avatar")
def draw_xp_bar()
& preserving_transform:
    set_transform(xy(½ SCREEN_SIZE.x, 0))

    // Animation time between 0% and 100% for the bar
    const τ = clamp((mode_frames - EARN_XP.TIMING.PRE_FRAMES - EARN_XP.TIMING.TABLE_FRAMES - EARN_XP.TIMING.POST_TABLE_FRAMES - EARN_XP.TIMING.MID_FRAMES) / EARN_XP.TIMING.BAR_FRAMES, 0%, 100%)
    
    // Currently-displayed XP
    const xp = round(lerp(prev_xp, new_xp, τ))
    
    // Currently-displayed level
    const level = xp_to_level(xp)
    
    // Lower bound for xp bar
    const xp_lo = level_to_xp(level)
    
    // Upper bound for xp bar
    const xp_hi = level_to_xp(level + 1)
    
    // Progress bar value
    const α = clamp((xp - xp_lo) / (xp_hi - xp_lo), 0%, 100%)
    
    // Play the glissando sound
    if mode_frames == EARN_XP.TIMING.PRE_FRAMES + EARN_XP.TIMING.TABLE_FRAMES + EARN_XP.TIMING.POST_TABLE_FRAMES + EARN_XP.TIMING.MID_FRAMES - 2 and player.score > 0:
        play_sound({sound: xp_sound, playback_rate: 10%, pitch: 200%})
    
    if mode_frames > 1 and (last_level_displayed ≠ level):
        // Level up
        play_sound(level_up_sound)
        
        // Give the abilities after the sound has finished
        delay(grant_new_abilities, 30)
    
    last_level_displayed = level
    
    const flash = (level ≠ prev_level) and (⌊mode_frames / 15⌋ mod 2) and (player.score > 0) and mode_frames < EARN_XP.TIMING.PRE_FRAMES + EARN_XP.TIMING.TABLE_FRAMES + EARN_XP.TIMING.POST_TABLE_FRAMES + EARN_XP.TIMING.MID_FRAMES + EARN_XP.TIMING.BAR_FRAMES + ½ EARN_XP.TIMING.POST_FRAMES
    
    avatar_draw({avatar: player.avatar, sprite: player.avatar.sprite.x_flipped, pos: xy(-20, 16), scale: 200%, z: 5})
    draw_text({text: player.avatar.name, pos: xy(8, 10), font: score_font, x_align: "left", color: #FFF})

    // Flash and turn pink on level change
    draw_text({
        color:   if flash then HIGHLIGHT_COLOR else #FFF,
        outline: if flash then #FFF else ∅,
        font:    leaderboard_font,
        text:    "Level " + level,
        x_align: "left",
        pos:     xy(8, 22)})

    // Progress bar
    todo("Tweak colors on XP bar to separate new vs previous")
    draw_corner_rect(EARN_XP.xp_rect.corner + xy(0, 1), EARN_XP.xp_rect.size)
    
    draw_corner_rect(
        EARN_XP.xp_rect.corner + 1,
        xy(α * (EARN_XP.xp_rect.size.x - 2), EARN_XP.xp_rect.size.y - 2), 
        HIGHLIGHT_COLOR)
    
    draw_text({font: history_font,
        color: #FFF,
        shadow: #0008,
        font: history_font,
        text: format_number(xp, "commas") + " XP",
        x_align: "right",
        y_align: "baseline",
        pos: EARN_XP.xp_rect.corner + ½ EARN_XP.xp_rect.size + xy(17, 2)})
        
    draw_corner_rect(EARN_XP.xp_rect.corner, EARN_XP.xp_rect.size, ∅, #FFF)
    
    
    
def draw_xp_table()
& preserving_transform:
    // -20 is for the timer bar
    const rect_height = SCREEN_SIZE.y - EARN_XP.BAR_SECTION_HEIGHT - 20
    
    set_clip(xy(0, EARN_XP.BAR_SECTION_HEIGHT), xy(SCREEN_SIZE.x, rect_height))
    set_transform(xy(½ SCREEN_SIZE.x - 100, scroll_offset + EARN_XP.BAR_SECTION_HEIGHT))
    
    const τ = clamp((mode_frames - EARN_XP.TIMING.PRE_FRAMES) / EARN_XP.TIMING.TABLE_FRAMES, 0%, 100%)
    
    let y = 0
    for i < τ * size(xp_array):
        const row = xp_array[i]
        
        // Extra spacing
        // Note: Leave extra space for header row, and last line
        y += if i == last_key(xp_array) then 10 else (if row.color ≠ TABLE_ALT_ROW_COLOR then 7 else (if row.xp then 6 else 3))

        // Audio as each new XP entry is first displayed
        if i > last_xp_row_displayed:
            last_xp_row_displayed = i
            play_sound(select_tile_sound, 80%)
            
        if i == last_key(xp_array):
            // Final row
            draw_line(xy(0, y - 5), xy(200, y - 5), TABLE_ALT_ROW_COLOR)
        
        if row.xp:
            draw_text({
                text: "+" + format_number(row.xp, "commas") + " XP" default "", 
                font: leaderboard_font, 
                color: row.xp_color default row.color,
                x_align: "right", 
                y_align: "top",
                pos: xy(180, y)})
        
        if row.avatar:
            avatar_draw({avatar: row.avatar, pos: xy(22, y + 5)})
            
        y += draw_text({
            text: row.text,
            font: row.font default leaderboard_font,
            color: row.color default #FFF,
            x_align: "left",
            y_align: "top",
            wrap_width: 145,
            markup: true,
            pos: xy(if row.avatar then 34 else (if row.header then 0 else 16), y)}).height
            
    scroll_offset = min(0, rect_height - y)
    


def draw_timer():
    const time_left = max(end_time - frame_utc_now, 0)
    const β = clamp(time_left / EARN_XP_SECONDS, 0%, 100%)

    // Progress bar. This is larger than it was on the intermission screen,
    // so we need to scale the remainder over EARN_XP_SECONDS
    draw_corner_rect(xy(0, SCREEN_SIZE.y - 20), xy(SCREEN_SIZE.x, 20), #000, #FFF)
    draw_corner_rect(xy(0, SCREEN_SIZE.y - 20) + 1, xy(SCREEN_SIZE.x - 2 - 34 β, 18), #0F0)
    
    draw_text({
        font: score_font,
        text: "New match in " + format_number(time_left, "timer"),
        outline: #0009,
        pos: xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 9),
        color: #FFF}) 
        
    
enter
────────────────────────────────────────────────────────────────────────
set_background(#000)
scroll_offset = 0

prev_xp = player.stats.lifetime.xp + player.stats[today_date_string()].xp
prev_level = player.avatar.level
last_level_displayed = prev_level
last_xp_row_displayed = 0

const discovered_word_list = stats_update(player.stats, player_competitor, size(competitor_array), player.joined_late)

// Compute the XP awards
xp_array = [
    {text: "Score", header: true}, 
    {text: format_number(player_competitor.score, "commas") + " Points", xp: ⌈player_competitor.score * XP.VALUE.point⌉, color: TABLE_ALT_ROW_COLOR}]


// Presence bonuses
const affinity_array = []

// Don't receive any bonus if we have aura ourselves
if not player.has_ability["Aura"] and player.score > 0:
    for competitor in competitor_array:
        if not competitor.enemy and competitor.avatar.level ≥ ABILITY_TABLE.Aura.level and competitor.score > 0:
            push(affinity_array, {
                text: trim_spaces(competitor.avatar.name) + "'s Aura",
                avatar: competitor.avatar,
                color: competitor.avatar.color,
                xp: max(5, ⌈(if competitor.avatar.level ≥ ABILITY_TABLE["Enhanced Aura"].level then XP.VALUE.enhanced_aura_point else XP.VALUE.aura_point) * competitor.score⌉)})

for competitor in competitor_array:
    if competitor.avatar.id == BOT.CAF.ID and player.has_ability["Friend of caf"] and player.score > 0:
        push(affinity_array, {
            text: competitor.avatar.name + "'s Affection",
            avatar: competitor.avatar,
            color: competitor.avatar.color,
            xp: XP.VALUE.caf_affection})

if size(affinity_array):
    push(xp_array,
        {text: "Affinity", header: true},
        …affinity_array)


// Show who your aura helped
if player.has_ability["Aura"] and player.score > 0:  
    const aura_array = []
        
    for competitor in competitor_array:
        if (not competitor.avatar.bot or competitor.avatar.appears_human) and competitor.avatar.level < ABILITY_TABLE.Aura.level and competitor.score > 0 and not competitor.enemy:
            push(aura_array, {avatar: competitor.avatar, text: competitor.avatar.name, color: TABLE_ALT_ROW_COLOR})

    if size(aura_array):
        push(xp_array, {text: "Your Aura Boosted", header: true}, …aura_array)


// Your words
if size(discovered_word_list) and player.has_ability["Discovery XP"]:
    push(xp_array, {text: "Discovered Words", header: true})
    
    // To keep the length of this list managable, we group 
    // words of the same length.
    const words_by_tile_length = make_array(17, [], clone)
    for word in discovered_word_list:
        push(words_by_tile_length[size(word)], q_decode(word))

    for word_list at num_tiles in words_by_tile_length:
        if size(word_list):
            const xp_per_word = ⌈(num_tiles - 2)² * XP.VALUE.unique_word_per_tile⌉
            push(xp_array,
            {
                text: "" + size(word_list) + " × " + xp_per_word + " xp / " + 
                    (if num_tiles > 4 then "{color: HIGHLIGHT_COLOR " else "") + num_tiles  + 
                    "-tile" + (if num_tiles > 4 then "}" else "") + " Word" + 
                    (if size(word_list) > 1 then "s" else ""),
                xp: size(word_list) * xp_per_word,
                xp_color: if num_tiles > 4 then HIGHLIGHT_COLOR else ∅,
                color: TABLE_ALT_ROW_COLOR},
            {
                text: join(word_list, ", "),
                font: history_font,
                color: TABLE_ALT_ROW_COLOR})
        
        
if player_competitor.badges and player.has_ability["Award XP"]:
    push(xp_array, {text: "Awards (" + size(competitor_array) + "-Player Match)", header: true})

    const badge_xp = XP.VALUE.badge_per_competitor * min(size(competitor_array) - 1, 10)

    // There isn't an explicit badge for winning the match
    if player_competitor == competitor_array[0]:
        push(xp_array, {text: "Highest score", xp: badge_xp, color: TABLE_ALT_ROW_COLOR})
        
    for badge in player_competitor.badges:
        // Convert the badge back into text
        const text = replace(find(BADGE_TABLE, badge), "_", " ")
        push(xp_array, {text: badge + " " + titlecase(text + (if contains(text, "word") then "" else " word")), xp: badge_xp, color: TABLE_ALT_ROW_COLOR})


// Only give streak awards for games where the player
// actually earned points, otherwise it could have been
// running unmonitored in the background
if player.score > 0 and not player.joined_late:
    const streak = []
    
    if player.stats[today_date_string()].matches == 1:
        push(streak, {text: "First Match Today", xp: XP.VALUE.first_match_today, color: TABLE_ALT_ROW_COLOR})
    
    else if player.stats[today_date_string()].matches mod 10 == 0:
        push(streak, {
            text: "" + player.stats[today_date_string()].matches + "ᵗʰ Match Today", 
            xp: XP.VALUE.decimatch_today + 10 ⌊player.stats[today_date_string()].matches / 10 - 1⌋, 
            color: TABLE_ALT_ROW_COLOR})
    
    if size(streak):
        push(xp_array, 
            {text: "Streak", header: true},
            …streak)

for row in xp_array:
    player.stats[today_date_string()].xp += row.xp default 0

// Avoid recomputing every frame during the XP animation
new_xp = player.stats.lifetime.xp + player.stats[today_date_string()].xp

// Summary row
push(xp_array, {text: "Match Total", xp: new_xp - prev_xp, color: HIGHLIGHT_COLOR})
    

// Update level based on the new total XP, as this is part of the 
// avatar computed at load and not part of the stats. Do this now 
// because we're about to save stats
player.avatar.level = xp_to_level(new_xp)

// Update the net vocabulary. Vocabulary was originally computed on load of stats
// so is not updated by stats_update.
array_to_set(discovered_word_list, 1, player.vocabulary)

// Save the updated stats. Unlocked abilities are stored as part
// of the ability notification process.
if not DEBUG.INTERMISSION and not DEBUG.EARN_XP:
    stats_save(player.stats)


frame
────────────────────────────────────────────────────────────────────────

if DEBUG_NETWORK_ON_SCREEN:
    preserving_transform:
        set_transform(xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 16))
        draw_rect(xy(0, 10), xy(224, 15), #B0FA, ∅, ∅, 100)
        draw_text({
            text: "Test: " + debug_network_status,
            font: leaderboard_font,
            color: #CCC,
            outline: #000,
            shadow: #000,
            pos: xy(0, 5),
            y_align: "top",
            z: 101})


draw_xp_table()
draw_xp_bar()
draw_timer()

if frame_utc_now ≥ end_time - 1.75:
    const pos = xy(SCREEN_SIZE.x - 24, 12)
    draw_sprite({sprite: shapes.gear, pos: pos, angle: -1.5° mode_frames, override_color: #888, scale: 50%})
    draw_text({font: history_font, text: "Saving", pos: pos + xy(0, 14), color: #888})

if frame_utc_now ≥ end_time:
    set_mode(GenerateBoard) because "Timer"
    
