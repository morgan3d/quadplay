Play
════════════════════════════════════════════════════════════════════════


def enter_freestyle():
    board_deselect_all(player.board, player)
    push_mode(Freestyle) because "Button"



def execute_remix():
    player_achieve(player, "Use Remix")
    play_sound({sound: remix_sound, volume: 50%, playback_rate: 200%})
    sort(player.remix_list, size_comparator)
    
    for word at w in player.remix_list:
        const points = score_word(word)
        player_add_to_history(player, word, points)
        player_spawn_score_animation(player, "Remix")
        
        // Per-word sound
        if w < 7: delay(play_points_sound, 7 w, points)
    
    --player.remix_uses_left
    player.remix_list = ∅
    
    
    
def enter_rotate_mode():
    push_mode(Rotate) because "button"
    


def npc_suggestions():
    iterate(competitor_array, npc_maybe_make_suggestion)



enter
────────────────────────────────────────────────────────────────────────
assert(not in_waiting_room)

// Create bots at the start of the match so that they can interact
remove_all(competitor_array)
insert_bots(competitor_array, NUM_BOTS)

play_sound(start_sound)

last_countdown_sound_time = now()

// Compute end_time
if game_type == SOLO_GAME:
    start_time = frame_utc_now
    end_time = start_time + (if player.has_achievement["Play Solo Match"] then 60 SOLO_GAME.PLAY_MINUTES else TUTORIAL.FIRST_PLAY_SECONDS)
else:
    assert(game_type == GLOBAL_GAME)    
    start_time = prev_global_game_utc_start_time()
    end_time = start_time + GLOBAL_GAME.PLAY_SECONDS

// Allow NPC suggestions at ⅓ and ⅔ of the way through the match
for 1 ≤ i ≤ 2:
    delay(npc_suggestions, max(0, round(i * (if DEBUG.MZK then 10% else ⅓) * (end_time - frame_utc_now) * 60)))


set_background(game_type.BACKGROUND_COLOR)

// Started more than 10s late, do not affect
// ratio stats
player.joined_late = (frame_utc_now > start_time + 10)

board_deselect_all(player.board, player)


frame
────────────────────────────────────────────────────────────────────────
const time_left = end_time - frame_utc_now   

// Disallow rotation if the mode is about to end
const allow_rotate = (60 time_left) > (90° / ROTATION_SPEED)

player_update(player, get_board_pos(), ∅, allow_rotate)

handle_buttons(
    ability_icon.freestyle, "Freestyle", enter_freestyle,
    ability_icon.remix, if player.remix_uses_left and size(player.remix_list) then execute_remix else ∅,
    aux_icon.rotate, enter_rotate_mode)


if time_left ≤ GRACE_SECONDS:
    // Make a few frames black at the end so that a player can
    // still trace a little further but can't see. This makes
    // it feel like they squeezed in one more word and weren't
    // "robbed" if in the process of selecting. Without this
    // it always feels like "I was just about to finish my word"
    set_post_effects({color: #000})
    
    
if time_left ≤ 0 or DEBUG.INTERMISSION or DEBUG.EARN_XP:
    board_deselect_all(player.board, player)
    if game_type == SOLO_GAME:
        set_mode(SoloSummary) because "SOLO and timer"
    else:
        set_mode(GatherGlobalResults) because "GLOBAL and timer"


leave
────────────────────────────────────────────────────────────────────────
clear_npc_message()

// If any remixes left, automatically use one
if player.has_achievement["Use Remix"] and player.remix_uses_left and size(player.remix_list):
    execute_remix()

reset_post_effects()
play_sound(times_up_sound)
if game_type == GLOBAL_GAME:
    if not player.has_achievement["Play Global Match"]:
        // Completed first game (ok to keep giving this)
        player_achieve(player, "Play Global Match")
    else:
        // Completed second game
        player_achieve(player, "Play Second Global Match")
    
else if (game_type == SOLO_GAME and
    player.has_achievement["Spell EAT"] and 
    player.has_achievement["Spell SEAT"] and 
    player.has_achievement["Spell TIDE"] and 
    player.has_achievement["Spell EXIST"]):
        
    player_achieve(player, "Play Solo Match")
    

// Accumulate the free mode points into the score
// now that they're locked in
for points in entry in player.history.free:       
    player.score += points
    

// Reset the scroll position because layout differs
// from the main game during intermission
player.history.scroll.offset = xy(0, 0)

// Sort words by final score
sort(player.history.list, "points", true)
sort(player.history.free, "points", true)
