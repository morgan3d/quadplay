def make_tile(letter default "?"):
    return {
        // uppercase, Q means Qu, otherwise the letter to add 
        // to the word when chosen
        letter: letter,
        
        // Last position rendered to in screen space
        pos: ∅,
        
        // Has this been consumed for free word construction?
        // If so, draw as missing.
        used: false,
                        
        // mode_frame at which this was selected
        selected: 0}
        
        

/* Draws a tile, adjusting fonts appropriately for the size */
def tile_draw(tile, pos, is_cursor_tile, angle, selection_color, tile_size, force_background default false):
    // Shrink by 5 at 44
    const inset = if tile_size.x > 10 then ⌊tile_size.x / 9⌋ else 0
    const center_size_x = ceil(tile_size.x - inset, ½)
    const subscript_offset = angle_to_xy(-45° - angle) * ⅓ center_size_x
    let radius = ½ center_size_x
    
    if tile.selected:
        // Bounce if just selected
        if tile.selected > game_frames - 12:
            radius += ⅕ oscillate(tile.selected - game_frames, 0, 6) + 0.8
    
    if not tile.selected or is_cursor_tile or force_background:
        // Background rect
        draw_rect(pos, tile_size, if is_cursor_tile then CURSOR_COLOR else TILE.COLOR, if is_cursor_tile then #0C0 else ∅) 
    
    draw_disk(
        pos,
        radius,
        if tile.selected then selection_color else TILE.CENTER_COLOR,
        ∅, 
        TILE.CENTER_Z)

    let text_color = if tile.selected then TILE.SELECTED_TEXT_COLOR else TILE.TEXT_COLOR
    if equivalent(text_color, selection_color):
        // Won't be able to see
        text_color = HIGHLIGHT_COLOR

    const font = (
        if tile_size.x > 25
        then tile_font
        else (
            if tile_size.x > 12
            then tile_small_font  
            else tile_tiny_font))
            
    const MIN_VISIBLE_POINTS_SIZE = 17
    
    // Letter label. Slide left at small sizes so that there's
    // room for the points
    draw_text({
        pos: if tile_size.x ≥ MIN_VISIBLE_POINTS_SIZE and tile_size.x < 21 then pos - xy(½, 0) else pos, 
        font: font, 
        text: if tile.letter == "Q" then "Qu" else tile.letter,
        color: text_color,
        z: TILE.LETTER_Z})
    
    // Points
    if not tile.selected and tile_size.x ≥ MIN_VISIBLE_POINTS_SIZE:
        draw_text({
            pos: pos + subscript_offset, 
            font: if tile_size.x > 20 then tile_point_font else tile_small_point_font, 
            text: LETTER_POINT_TABLE[tile.letter], 
            color: #AAA,
            z: TILE.LETTER_Z})
            

            
/* Given an unordered array of tile indices into `player.tile[][]`, finds all words that can be
   made from those tiles such that the words:
       
   - Trace through the tiles using adjacency in the board
   - Have of length between `DICTIONARY.MIN_WORD_LENGTH` and `max_word_length` 
     tiles
   - Are words the player found in previous games (are in their vocabulary, which is a subset of dictionary[])
   - Are words the player has not yet found in this game

   The words are returned q-encoded.
   
   Used to implement Remix.
*/
def find_short_words_from_selection(max_word_length default 4):
    // Precompute adjacency. Parallel array to tile_array 
    // in which each element is an array of neighbor INDICES
    // into player.selection.
    const neighborhood_array = []
    for A in player.selection:
        const neighbor_array = []
        for B at t in player.selection:
            if A ≠ B and ‖A - B‖ < 1.5:
                push(neighbor_array, t)
        push(neighborhood_array, neighbor_array)
    
    const word_set = []
    
    def search(last_index, word, used_mask):
        if size(word) ≥ DICTIONARY.MIN_WORD_LENGTH:
            if player.vocabulary[word] and not player.already_found[word]:
                // Found a new word, record it
                word_set[word] = 1
        
        if size(word) < max_word_length:
            // Try to visit each unused neighbor next
            const neighbor_array = neighborhood_array[last_index]
         
            for n < size(neighbor_array):
                const t = neighbor_array[n]
                if not ((used_mask bitshr t) ∩ 1):
                    // This tile has not been used yet for this search path,
                    // so recursively explore it
                    const tile_index = player.selection[t]
                    search(t, word + player.tile[tile_index.x][tile_index.y].letter, used_mask ∪ (1 bitshl t))
    

    // Start with each letter in turn
    for tile_index at t in player.selection:
        search(t, player.tile[tile_index.x][tile_index.y].letter, 1 bitshl t, player.selection, neighborhood_array, word_set, max_word_length)

    return keys(word_set)
    
            
    

            