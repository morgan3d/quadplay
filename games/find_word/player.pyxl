/* UI state for  for manipulating a game board of `ROWS` x `COLS` *tiles*.
   The board includes information about the current selection. 
   
   A tile `index` is an integer `xy()` position, where `(0, 0)` is the
   upper left and `(COLS, ROWS)` is the lower right.  */


/* Grant this achievement */
def player_achieve(player, name, make_notification default false):
    if not player.has_achievement[name]:
        player.has_achievement[name] = true
        save_local("has_achievement", player.has_achievement)



/* Constructs a new player with an uninitialized board. Loads
   their avatar from local storage or creates a random one.  */
def make_player():
    const stats = stats_load()    
    
    return {
        // The tiles
        tile: make_array(xy(COLS, ROWS), make_tile(), deep_clone),
                
        // The UI selection as xy() indices, in order of selection
        selection: [],
        
        // Chosen based on the point value of the current word in _check
        selection_color: TILE.CENTER_SELECTED_COLOR,
        
        // Tiles for the free word construction
        free_row: [],

        stats: stats,
        
        // Q-encoded dictionary of all words this player has ever
        // found
        vocabulary: array_to_set([…stats.lifetime.word_list, …stats[today_date_string()].word_list], 1),
        
        // The words that the Remix ability will find if activated.
        // Updated when the player completes a word. When ∅ the 
        // auto button is not available.        
        remix_list: ∅,
        remix_uses_left: 0,
        // Button position, computed during rendering and then used
        // for score animation
        remix_pos: xy(0,0),
        
        // For stats
        remixes: 0,
        remix_words: 0,
        best_remix: 0,
        
        avatar: {…avatar_load(), level: xp_to_level(stats.lifetime.xp + stats[today_date_string()].xp)},
        
        // Maps names of abilities from ABILITY_TABLE to 1 if present.
        // We do this instead of testing the player level so that during playtesting
        // save files don't have to be updated; instead upgrades are sticky
        // and automatically appear on level up retroactively
        has_ability: ability_load(),
        
        has_achievement: load_local("has_achievement") default {},
        
        // Maps player GUIDs to their most recent name.
        // The names are only for debugging.
        friends: load_local("friends") default {},
        
        score: 0,
        
        background_color: BOARD_COLOR,
        
        gamepad: gamepad_array[0],
                        
        // Q-encoded upper case words that have already been found
        // and are represented in history.list. This does NOT include
        // history.free. use `player_already_found()` to test both.
        already_found: {},
        
        // Used for display.
        history: make_history(),
        
        // Set by `Play.enter`. Used to track games that should not affect stats
        joined_late: false,
        
        wild_tile: make_tile(WILDCARD_CHARACTER),

        // Determined by most recent input method.
        // Show button prompts and cursor when using gamepad
        using_gamepad: false,
        
        // Where the cursor is
        cursor_tile_index: xy(0, 0)}



/* Returns a selection array [xy(), …] that matches the word, or ∅ if the word 
   does not appear in this board. The word is all caps and NOT Q-encoded */
def player_find_unencoded_word(player, unencoded_word):
    // Workaround bug
    if not unencoded_word: return ∅

    let path = ∅
    const encoded = q_encode(unencoded_word)

    def visit(word, index, base16_path):
        if not starts_with(encoded, word):
            return true
        else if word == encoded:
            path = []
            // Convert the base36 path into an xy() path
            for d in base16_path:
                const i = HEX_TO_DEC[d]
                push(path, xy(i mod COLS, ⌊i / COLS⌋))
                
            return true
            
    board_string_visit_subpaths(player_board_to_string(player), visit)
    
    return path



def player_free_contains(player, word):
    return contains(player.history.free, {word: word}, "word")



def player_board_to_string(player, line_suffix default ""):
    let s = ""
    for y < ROWS:
        for x < COLS:
            s += player.tile[x][y].letter
        if y ≠ ROWS - 1:
            s += line_suffix
    return s
   
    

/* True if these xy() tile integer indices are adjacent */
def _adjacent(A, B):
    return XY_DISTANCE(A, B) < 1.5
    
    

/* Returns the center of the tile at index in pixels relative to the
   grid upper left corner */
def _index_to_pos(index):
    return (index * (TILE.GUTTER * xy(min(index.x, 1), min(index.y, 1)) + TILE.EXTENT)
           - ½ xy(COLS - 1, ROWS - 1) * (TILE.EXTENT + TILE.GUTTER))


/* Return the word, maybe including a wildcard character, represented
   by the player's current `free_row` tiles */
def player_free_row_pattern(player):
    let pattern = ""
    
    for tile at t in player.free_row:
        pattern += tile.letter
        
    return pattern



/* Creates animation going from the selection (if source == "board") or 
   remix button (if source == "Remix") to the last word in the history */
def player_spawn_score_animation(player, source default "board"):
    let target
    
    // Capture the entry at the time of the animation spawn from
    // the history list
    const entry = last_value(player.history.list)

    let letter_array = []
    let start_array = []
    
    if source == "Remix":
        for letter in entry.word:
            push(letter_array, q_decode(letter))
    else:
        for tile_index in player.selection:  
            with pos, letter in player.tile[tile_index.x][tile_index.y]:
                push(start_array, xy(pos))
                push(letter_array, q_decode(letter))
    
    def callback(frames_left, total_frames):
        // Have to wait a frame for this so that the 
        // target actually gets rendered and assigned a pos first
        if not entry.pos: return
    
        const target = entry.pos + xy(4 size(entry.word), 4)
        
        const α = linstep(total_frames, 0, frames_left)^1.5
        for i < size(letter_array):
            const pos = lerp(if source == "Remix" then player.remix_pos else start_array[i], target, α)
            draw_disk(pos, ½ (TILE.EXTENT - 4) * (1 - α), entry.color, ∅, 9)
            draw_text({font: score_font, x_align: "center", y_align: "center", text: letter_array[i], pos: pos, color: rgba(1, 1, 1, 1 - α³), z: 10})
        
    sequence({callback: callback, frames: HISTORY.POINTS_ANIMATION_FRAMES})



def player_find_good_board(player, game_type):
    // Construct the rng based on the time. This will
    // cause players within the same window to be more likely
    // to have the same board. Temporary prior to investing
    // multiplayer servers.
    const rng_seed = (if in_waiting_room or game_type == SOLO_GAME or DEBUG.BOARD_SEARCH then 
            (10 utc_now())
        else
            // Use the seed for the curent game period, but look a few
            // seconds into the future in case this player is joining early
            // to make it robust
            ⌊1 + (utc_now() + 10) / GLOBAL_PERIOD⌋)
    
    const {board_string, word_array, seed} = make_good_board_string(make_random(rng_seed))
    
    // Convert to board object
    board = make_board(seed, board_string, word_array)
    
    for x < COLS:
        for tile at y in player.tile[x]:
            tile.letter = board_string[x + y * COLS]
            tile.selected = 0
            tile.used = false


/* Called by the board after changing selection. 
   Returns true if there was a new word. As a side effect,
   plays a sound and sets the state for visualizing the word
   if there is one. */
def player_selection_change_callback(player):
    
    const word   = player_selected_word(player)
    const points = score_word(word)

    // Reset selection color
    player.selection_color = TILE.CENTER_SELECTED_COLOR
    
    if player.already_found[word]:
        
        // Show that we've already seen this word by
        // finding and emphasizing it
        player_emphasize_history_word(player, word)
        return true

    else if points > 0:
        // Note that words can also be added by the Auto ability
        // implemented in Play.
        
        // Score the word, even without the player releasing their touch
        player.selection_color = player_add_to_history(player, word, points)
        player_spawn_score_animation(player)
        play_points_sound(points, last_value(player.selection))    
        
        // Update the auto button's list. Do this after player_add_to_history
        // so that the full word isn't found again
        if player.has_ability["Scry Remixes"] and not in_waiting_room:
            const previously_available = size(player.remix_list)
            player.remix_list = find_short_words_from_selection()            
            if player.remix_uses_left and size(player.remix_list) > 5 and not previously_available:
                delay(play_sound, 5, {sound: remix_recommended_sound, volume: min(70% + 10% size(player.remix_list), 170%)})

        return true



/* Does not update the score. Returns the color */
def player_add_to_free(player, word, points):
    return history_add(player.history, "free", word, points)
    
    

/* Returns the color. Updates the score. Does not verify that the word has
   not been found previously. `word` is Q-encoded */ 
def player_add_to_history(player, word, points):
    const i = find(player.history.free, {word: word}, ∅, "word")
    
    if i ≠ ∅:
        // This word was made in free mode unnecessarily. Steal it
        // so that it is locked in if they later change the free row            
        remove_key(player.history.free, i)
        
    player.already_found[word] = true
    player.score += points
    return history_add(player.history, "list", word, points)
    


/* Make this q-encoded word that is already in the history 
   appear emphasized for a few frames to make it obvious 
   to the player */
def player_emphasize_history_word(player, word, duration default 30):
    for list in [player.history.list, player.history.free]:
        for entry in list:
            if entry.word == word:
                entry.emphasize_frame = game_frames + duration
                play_sound({sound:select_tile_sound, volume:150%, pitch:40%})
                return
        
    assert(false, "Could not find " + word + " which should already be in history")




/* Also draws button prompts */
def player_draw_score(player, board_pos, time_left)
& with gamepad, score in player:
    
    const score_pos = board_pos + xy(+½, -½) * get_player_board_pixel_size() - xy(18, 16)
    
    let width = 0
    
    if in_waiting_room:
        draw_text({
            pos: score_pos + xy(0, -7),
            font: button_prompt_font,
            text: "WARM UP HERE. THE NEXT\nGLOBAL MATCH STARTS SOON!",
            x_align: "right",
            y_align: "top",
            color: #0F0,
            z: TILE.LETTER_Z})
            
    else:
        let score_text = format_number(score, "commas")

        // Extend the score with the free points, color
        // coded to make it more obvious this is coming
        // from the free points
        if player.has_ability["Freestyle"]:
            let free_score = 0
            for points in entry in player.history.free:
                free_score += points
                
            let free_text = "" + free_score
            
            // Add color markup
            const best_entry = last_value(player.history.free)
            if best_entry:
                free_text = "{color:" + unparse(best_entry.color) + free_text + "}"
                if best_entry.outline:
                    free_text = "{outline:" + unparse(best_entry.outline) + free_text + "}"
                    
            score_text += "+" + free_text
        
        width = draw_text({
            pos: score_pos,
            font: if player.using_gamepad and size(score_text) > 5 then leaderboard_font else score_font,
            text: score_text + " pts",
            color: #FFF,
            markup: true,
            y_align: "center",
            x_align: "right"}).size.x 
    
    // Button prompts (no space during Freestyle mode for this)
    if player.using_gamepad:
        if get_mode() ≠ Freestyle:
            draw_text({
                pos: score_pos + xy(-136, -7),
                font: button_prompt_font,
                text: replace("(a) SELECT" + (if size(player.selection) > 1 then "\n(b) CANCEL" else ""), gamepad.prompt),
                x_align: "left",
                y_align: "top",
                color: #FFF,
                z: TILE.LETTER_Z})
    else if not in_waiting_room:
        // Gamepad prompts go in this space, so only draw the avatar in mouse/touch mode
        avatar_draw({avatar: player.avatar, sprite: if size(player.history.list) mod 2 then ∅ else player.avatar.sprite.x_flipped, pos: score_pos - xy(width + 10, 1)})
      
        


/*
  Moves the cursor. When there is a selection in progress, restricts
  to within 1 tile of the last selected value. 
 */
def _player_update_cursor(player)
& with cursor_tile_index, gamepad in player:

    // Move on discrete input
    const target = cursor_tile_index + gamepad.xy * |sign(gamepad.dxy)|
    
    // Bounds are initially the whole board
    let lo = xy(0, 0)    
    let hi = xy(COLS, ROWS) - 1

    // Constrain movement to adjacent tiles when a selection is active
    const selection = player.selection
    if size(selection) > 0:
        const last = last_value(selection) 
        lo = max(lo, last - 1)
        hi = min(hi, last + 1)
    
    cursor_tile_index = clamp(target, lo, hi)

    // Buttons
    if gamepad.pressed_a:
        if (equivalent(cursor_tile_index, last_value(player.selection)) or
            equivalent(cursor_tile_index, penultimate_value(player.selection))):
            // Remove from selection. Allow this to happen by re-selecting
            // the penultimate or de-selecting the ultimate
            player_deselect_last(player)
        else if not contains(player.selection, cursor_tile_index, equivalent):
            // Add to selection
            player_select(player, cursor_tile_index)
    
    if gamepad.pressed_b:
        // End selection
        player_deselect_all(player)
            


/* Run UI for this player and draw their board */
def player_update(player, board_pos, angle default 0°, allow_selection default false):
    
    maybe_connect_to_network()
    
    // Track most recent UI method
    if touch.pressed_a:
        player.using_gamepad = false
    else if player.gamepad.pressed_a or player.gamepad.pressed_b or player.gamepad.dx or player.gamepad.dy:
        player.using_gamepad = true
    
    if not player.using_gamepad and not touch.a and size(player.selection) > 0:
        player_deselect_all(player)

    // Move the gamepad controlled cursor
    _player_update_cursor(player)
    
    if (touch.released_a or 
    
        // Tap B to cancel selection
        player.gamepad.pressed_b or
        
        // If not selecting, make sure it is empty
        not allow_selection):
        
        player_deselect_all(player)    

    player_draw_board(player, board_pos, angle, allow_selection)

    const time_left = draw_timer(board_pos)
    player_draw_score(player, board_pos, time_left)
    
    history_update(player.history, get_history_rect())
    
    


/* Compute the position of the center of the board based on the screen size */
def get_player_board_pos():    
    // Our board has some content at the top, so don't switch
    // to portrait until all of the UI will be visible
    if landscape():
        // Landscape. Put at the bottom right (feel "closer" to a right handed mouse player)
        return xy(SCREEN_SIZE.x - ½ get_player_board_pixel_size().x - 8, ½ SCREEN_SIZE.y + 8)
    else:
        // Portrait. Put at the bottom, centered, unless the screen is not very high
        // Slide up a little on narrow screens so that it is easier to swipe on a phone
        return xy(½ SCREEN_SIZE.x,
            SCREEN_SIZE.y - ½ get_player_board_pixel_size().y - 18
            - ⅓ max(SCREEN_SIZE.y - (get_player_board_pixel_size().y + 60), 0))
        


/* Draw the board and manage UI state changes.
 
   `pos`
   : Center of the grid in pixels
 
   `angle`
   : Rotate by this amount
   
   `allow_selection`
   : If true show and permit selection via touch/gamepad
     
*/
def player_draw_board(player, pos, angle, allow_selection)
& preserving_transform
& with gamepad, background_color in player:
    
    const grid_size = get_player_board_pixel_size()
    const tile_size = xy(TILE.EXTENT, TILE.EXTENT)
    
    // Make the selection target slightly small to make 
    // it easier to select diagonals without hitting
    // the sides. If this is the first letter, make the
    // selection radius extra large instead
    const selection_size = tile_size + (if size(player.selection) == 0 then -2 else -6)
    
    set_transform(pos)
    set_camera(xy(0, 0), -angle)

    draw_rect(xy(0, 0), grid_size + ¼ TILE.EXTENT, background_color, player.selection_color)
    draw_rect(xy(0, 0), grid_size + ¼ TILE.EXTENT + 2, ∅, player.selection_color)
    draw_rect(xy(0, 0), grid_size + ¼ TILE.EXTENT + 4, ∅, player.selection_color)
    
    // Store store this before selection changes so that the same
    // button can be used to start and end selection
    const cancel_gamepad_selection = gamepad.pressed_b        
    
    // Save the selection color before iteration so that
    // it does not change within a frame, as this is modified
    // based on the value of the word but should be consistent
    // for a single frame.
    const selection_color = player.selection_color
    
    for col at i in player.tile:
        for tile at j in col:
            
            const index = xy(i, j)
            const pos = _index_to_pos(index)
            const is_cursor_tile = player.using_gamepad and player.cursor_tile_index.x == i and player.cursor_tile_index.y == j and get_mode() ≠ Title
            
            tile.pos = transform_ws_to_ss(pos)
            // This is only for touch purposes, not rendering
            const tile_center = {pos: pos, shape: "disk", size: selection_size}

            if allow_selection:
                // Touch selection                
                if touch.a and overlaps(tile_center, touch.xy):
                    player.cursor_tile_index = xy(index)
                    if touch.pressed_a and (size(player.selection) == 0):
                        
                        // Start selection
                        player_select(player, index)
                        
                    else if (touch.a and
                            size(player.selection) > 0 and
                            _adjacent(index, last_value(player.selection))):
    
                        if tile.selected:
                            // Undo selection, backtracked
                            if equivalent(index, penultimate_value(player.selection)):
                                player_deselect_last(player)
                                
                        else:
                            // Continue selection
                            player_select(player, index)
    
            tile_draw(tile, pos, is_cursor_tile, angle, selection_color, tile_size)
            
    
    // Draw the connectors between selected letters
    if size(player.selection) > 1:
        let prev_pos = _index_to_pos(player.selection[0]) 
        for 0 < s < size(player.selection):
            let pos = _index_to_pos(player.selection[s])
            draw_line(prev_pos, pos, selection_color, TILE.CENTER_Z, ¼ TILE.EXTENT)
            prev_pos = pos



/* If `board_space_string` is specified it should be of the form "AAAA BBBB CCCC DDDD" 

   `skip_word_search` = for the title screen, save time on startup and don't bother
   searching for all possible words in the title.
*/
def player_reset_match(player, game_type, board_space_string default ∅, skip_word_search default false):
    assert(not board_space_string or board_space_string[4] == " ", "board_space_string must have rows separated by spaces")
    player.background_color = BOARD_COLOR
    
    remove_all(player.free_row)
    remove_all(player.already_found)
    remove_all(player.history.list)
    remove_all(player.history.free)
    
    player.score = 0
    player.history.scroll.offset = xy(0, 0)
    player.history.scroll_history_size = 0
    player.wild_tile.used = false
    player.remixes = 0
    player.remix_words = 0
    player.best_remix = 0
    player.remix_list = ∅
    
    player.remix_uses_left = (
        if player.has_ability["Remix × 10"] then 10
        else (if player.has_ability["Remix × 8"] then 8
        else (if player.has_ability["Remix × 6"] then 6
        else (if player.has_ability["Remix × 5"] then 5
        else (if player.has_ability["Remix × 4"] then 4
        else (if player.has_ability["Remix × 3"] then 3
        else (if player.has_ability["Remix × 2"] then 2
        else (if player.has_ability["Remix"] then 1 else 0))))))))
    
    // Tutorial, title screen, or debugging
    if board_space_string:
        for y < ROWS:
            for x < COLS:
                // COLS + 1 because there are spaces in the board_space_string
                player.tile[x][y].letter = board_space_string[x + y * (COLS + 1)]
        
        // Collapse out the spaces and store that as the seed
        board.board_string = replace(board_space_string, " ", "")
        board.seed = board.board_string
        
        assert(not skip_word_search or get_mode() == Title or DEBUG.OFFLINE, "Should not skip word search in regular matches")
        board.word_list = if skip_word_search then [] else board_string_find_all_words(board.seed)
        board.word_set = array_to_set(board.word_list)
    else:
        player_find_good_board(player, game_type)
    
    player_deselect_all(player)



/* Rendered size of the board */
def get_player_board_pixel_size():
    return xy(COLS, ROWS) * TILE.EXTENT + xy(COLS - 1, ROWS - 1) * TILE.GUTTER
    


/* Rotates the board and cursor */
def player_rotate_board(player):
    player_rotate(player)
    player.cursor_tile_index = xy(COLS - player.cursor_tile_index.y - 1, player.cursor_tile_index.x)


/* Add the `xy()` value `index` to the current selection, playing sounds
   as appropriate.  */
def player_select(player, index):
    push(player.selection, index)
    player.tile[index.x][index.y].selected = game_frames

    if size(player.selection) == 1:
        // This is a new selection starting, so disable the auto list
        player.remix_list = ∅

    // Pan sound with position
    if not player_selection_change_callback(player):
        _board_play_sound(select_tile_sound, 85%, 100%, index)



def player_deselect_last(player):
    player.selection_color = TILE.CENTER_SELECTED_COLOR
    
    const index = pop(player.selection)
    player.tile[index.x][index.y].selected = false
    
    if not player_selection_change_callback(player):
        // Could play a deselect sound here



def player_deselect_all(player):
    player.selection_color = TILE.CENTER_SELECTED_COLOR

    for index in player.selection:
        player.tile[index.x][index.y].selected = false

    resize(player.selection, 0)
    // Could play a deselect sound here
        
        

/* Adjusts the pan for the index */
def _board_play_sound(sound, volume, pitch, index):
    play_sound({
        sound: sound,
        volume: volume,
        pan: if index then (index.x + 1) / (COLS + 1) else ∅,
        pitch: pitch})
    


/* Swaps tiles as if the board were rotated 90 degrees CW */
def player_rotate(player):
    assert(size(player.selection) == 0)
    assert(ROWS == COLS)
    
    const old = player.tile
    
    player.tile = make_array(xy(COLS, ROWS))
    for i < COLS:
        for j < ROWS:
            player.tile[i][j] = old[j][ROWS - i - 1]



/* 90° CCW */
def player_reverse_rotate(player):
    assert(size(player.selection) == 0)
    assert(ROWS == COLS)
    
    const old = player.tile
    
    player.tile = make_array(xy(COLS, ROWS))
    for i < COLS:
        for j < ROWS:
            player.tile[i][j] = old[ROWS - j - 1][i]



/* Returns the Q-encoded upper-case text word that is selected, 
   or "" if no selection */
def player_selected_word(player):
    let word = ""

    for s in player.selection:
        word += player.tile[s.x][s.y].letter
        
    return word
    


/* Draw a mini version of the game board on the intermission modes. 
   See also `player_draw_board()` */
def player_draw_mini(player, pos)
& preserving_transform:
    compose_transform(pos)
            
    for y < ROWS:
        for x < COLS:
            const tile = player.tile[x][y]
            const letter = if tile.letter == "Q" then "Qu" else tile.letter
            
            tile.pos = 12 xy(x - 1.5, y - 1.5)
            
            // Pulse when just selected
            const radius = if tile.selected and (tile.selected ≥ game_frames - 16) then 6 else 5
            draw_disk(tile.pos, radius, if tile.selected then (if |game_frames - tile.selected - 6| ≤ 7 then #FFF else player.selection_color) else #FFF)
            
            draw_text({
                pos: tile.pos,
                font: history_font,
                color: if tile.selected then #FFF else #000,
                text: letter})
    
    if size(player.selection) > 0:
        const word = q_decode(player_selected_word(player))
        
        // Draw word
        draw_text({
            font: leaderboard_font,
            text: word,
            pos: xy(0, -31),
            shadow: #000,
            color: player.selection_color})
            
        // Draw connectors
        for 1 ≤ i < size(player.selection):
            const prev = player.selection[i - 1]
            const curr = player.selection[i]
            draw_line(player.tile[prev.x][prev.y].pos, player.tile[curr.x][curr.y].pos, player.selection_color, -1, 2)



/* Force a selection in the intermission modes.
   `word` is Q-decoded. Does not select if already selected,
   so that pulse animation works */
def player_select_word(player, word, color default HIGHLIGHT_COLOR):
    assert(word)
    // In the case of a word that is not findable (because it uses wild card tiles
    // for example), becomes []
    const selection = player_find_unencoded_word(player, word)
    if not selection or q_decode(player_selected_word(player)) == word: return

    player_deselect_all(player)
    player.selection = selection
    player.selection_color = color
    
    // Select these letters
    for index at i in player.selection:
        player.tile[index.x][index.y].selected = game_frames + 2 i
    
    play_sound({sound: blip_sound, pan: player.pos})
    