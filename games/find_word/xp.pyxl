def xp_to_level(xp):
    assert(xp ≠ ∅ and not is_nan(xp))
    // Invert level_to_xp
    let approx = floor(floor(xp / XP.LEVEL_DIVISOR, ½)^XP.LEVEL_EXPONENT) + 1
    if level_to_xp(approx) > xp or xp ≥ level_to_xp(approx + 1):
        ++approx
        
    return approx



/* XP needed to reach this level */
def level_to_xp(level):
    return max(0, floor((level - 1)^(1 / XP.LEVEL_EXPONENT), ½) * XP.LEVEL_DIVISOR)



def notify_xp_bonus(xp_value, text):
    notify(
        notify_icon.xp,
        "XP Bonus",
        "+" + format_number(xp_value, "commas") + " XP for " + text,
        play_sound,
        {sound: award_sound, playback_rate: 150%})

    

// Testing levels
/*
for 0 < i < 30:
    const xp = 100 i + 20
    const level = xp_to_level(xp)
    debug_print(level, ":", level_to_xp(level), "≤", xp, "<", level_to_xp(level + 1))
    assert(level_to_xp(level) ≤ xp)
    assert(xp < level_to_xp(level + 1)) 
  */

/*
local:
    for 0 < level ≤ 50:
        debug_print(level, "|", format_number(level_to_xp(level), "commas"))
*/


        