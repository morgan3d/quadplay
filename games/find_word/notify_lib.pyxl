/* 
@url notify_lib.pyxl
@license © 2025 Sʜᴍᴜᴇʟ. Open source under the [MIT license](https://opensource.org/licenses/MIT)
@summary Popup notification system 

Configure by mutating the fields of NOTIFY.

Only shows one at a time and enqueues the rest of the notifications.
This is intended to be generalized towards
eventually becoming a library independent of the game. 
   
*/


// The notification at the front of the queue is currently displayed
const _notification_queue = []

/* Override these global options to configure the library */
const NOTIFY = {
    BACKGROUND_COLOR: #EEE,
    TITLE_FONT:       score_font,
    DESCRIPTION_FONT: leaderboard_font,
    HIGHLIGHT_COLOR:  HIGHLIGHT_COLOR,

    // These count against duration_seconds
    ENTER_DURATION_SECONDS:   0.17,
    EXIT_DURATION_SECONDS:    0.17,
    
    // If not ∅, 
    CLOSE_BUTTON: "c",

    Z: 110,
    
    SPRITE_WIDTH: 32,
    PADDING: 7}
    
    
def notify(sprite, title, description, begin_callback default ∅, callback_data default ∅, duration_seconds default 7):
    assert(begin_callback == ∅ or type(begin_callback) == "function")
    
    push(_notification_queue, {
        sprite:         sprite,
        title:          title,
        description:    description,
        begin_callback: begin_callback,
        callback_data:  callback_data,
        // Real time of display
        first_shown:    ∅,
        duration_seconds: duration_seconds})
    

    
def notifications_pending():
    return size(_notification_queue)    
    
    

/* Hook to process notification animation every frame */
def update_notifications()
& preserving_transform:

    // Draw way on top of everything in Z
    set_transform(xy(½ SCREEN_SIZE.x, 44), ∅, NOTIFY.Z)
    
    // Nothing to do
    if not notifications_pending(): return

    // Peek the queue
    const notification = _notification_queue[0]
    with first_shown, duration_seconds, sprite, begin_callback in notification:
        // Does not count against duration_seconds
        const delay_after_seconds = clamp(25% duration_seconds, 0.6, 1.2)
        
        const time_now = now()
        
        if first_shown == ∅:
            first_shown = time_now
            if begin_callback:
                begin_callback(notification.callback_data)

        const relative_time = time_now - first_shown
        
        // Size fraction
        let α = 100%        
        if relative_time < NOTIFY.ENTER_DURATION_SECONDS:
            // Grow
            α = clamp(relative_time / NOTIFY.ENTER_DURATION_SECONDS, 0%, 100%)
        else if relative_time > NOTIFY.EXIT_DURATION_SECONDS:
            // Shrink
            α = clamp((duration_seconds - relative_time) / NOTIFY.EXIT_DURATION_SECONDS, 0%, 100%)

        const rect = {pos: xy(0, 0), size: α * xy(204, 80)}
        
        if α > 0%:
            // Drop shadow
            draw_rect(rect.pos + xy(0, 4), rect.size + 4, #0008, ∅, ∅, -1)
    
            // Window
            draw_rect(rect.pos, rect.size, NOTIFY.BACKGROUND_COLOR, NOTIFY.HIGHLIGHT_COLOR)
            draw_rect(rect.pos, rect.size - 2, ∅, NOTIFY.HIGHLIGHT_COLOR)
            draw_rect(rect.pos, rect.size + 2, ∅, #000)
            
            // Show contents when the window reaches full size
            if α == 100%:
                if notification.sprite:
                    draw_sprite({
                        sprite: notification.sprite,
                        pos: xy(-½ rect.size.x + NOTIFY.PADDING + ½ NOTIFY.SPRITE_WIDTH, 0),
                        override_color: if equivalent(rgb(notification.sprite.mean_color), #FFF) then #000 else ∅,
                        scale: NOTIFY.SPRITE_WIDTH / notification.sprite.size.x})
        
                draw_text({
                    text: "{font:" + NOTIFY.TITLE_FONT + " {color:" + unparse(NOTIFY.HIGHLIGHT_COLOR) + " " + notification.title + "}{br}}" + notification.description,
                    pos: xy(-½ rect.size.x + NOTIFY.SPRITE_WIDTH + 2 NOTIFY.PADDING, -10),
                    font: NOTIFY.DESCRIPTION_FONT,
                    color: #000,
                    markup: true,
                    wrap_width: rect.size.x - NOTIFY.SPRITE_WIDTH - 2.5 NOTIFY.PADDING,
                    x_align: "left",
                    y_align: "center"})
                    
                if player.using_gamepad and NOTIFY.CLOSE_BUTTON:
                    draw_text({
                        pos: rect.pos + ½ rect.size - 4,
                        text: joy.prompt["(" + NOTIFY.CLOSE_BUTTON + ")"],
                        x_align: "right",
                        y_align: "bottom",
                        color: #666})                        

        // Only allow cancel during the full size window to ensure
        // the player didn't click mistakenly
        const cancel = (α == 100%) and ((NOTIFY.CLOSE_BUTTON and joy["pressed_" + NOTIFY.CLOSE_BUTTON]) or (touch.pressed_a and overlaps(rect, touch.xy)))
        
        if (relative_time > duration_seconds + delay_after_seconds) or cancel:
            // Done! remove
            pop_front(_notification_queue)
