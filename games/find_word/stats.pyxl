/* A `stats` object contains `{lifetime: stats_entry, <date>: stats_entry, …, word_list: []}` */
def make_empty_stats_entry():
    return {
        badge_count: {
            best_rare: 0,
            longest: 0,
            best_word: 0,
            highest_score: 0,
            most_words: 0,
        },

        longest_text: "",

        best_word_text: "", 
        best_word_points: 0,

        best_freestyle_word_text: "",
        best_freestyle_word_points: 0,
        
        // Includes the wildcard
        best_wild_word_text: "",
        best_wild_word_points: 0,

        best_score: 0,

        most_words: 0,

        words: 0,

        points: 0,
        
        freestyle_points: 0,

        matches: 0,

        xp: 0,

        word_list: []}
        
        

def stats_total_xp(stats):
    let xp = 0
    for stats_entry in stats:
        xp += stats_entry.xp
    return xp
    
    

/* Assumes the input is a list of q-encoded, all-caps words. 
   Returns a string packing them into a form that serializes
   efficiently.
   
   quadplay limits the length of serialized save_local values, so
   compress by:
   
   - Using a single string, eliminating an extra comma and quote from each word
   - Using suffix encoding for variants with trivial plurals:
       - § = + ES
       - $ = + S
       
   followed by string_compress()
   */
def compress_word_list(array):
    if size(array) == 0: return ""
    
    const PRESENT = 2
    const ALREADY_SAVED = 1
    
    // Start with words sorted from longest to shortest
    // (so we see prefixes first), and then mark all present
    array = sorted(array, size_comparator, true)

    // Maps each word to PRESENT or ALREADY_SAVED
    let set = {}
    for i < size(array):
        set[array[i]] = PRESENT
        
    // Encode the words of array. Process in order from longest
    // to shortest so that suffix encodings work
    let dest = []
    
    for i < size(array):
        const text = array[i]
        if set[text] ≠ ALREADY_SAVED:
            // Technically unnecessary; we won't return to this word
            set[text] = ALREADY_SAVED
            
            // Because of the way that the game scores words,
            // it is actually impossible to have found the suffix
            // plural without the singular. However, this logic is good
            // for later generalizing to other suffixes
            // and prefixes.
            const strip2 = slice(text, 0, size(text) - 2)
            const strip1 = slice(text, 0, size(text) - 1)
            if ends_with(text, "ES") and set[strip2] == PRESENT:
                set[strip2] = ALREADY_SAVED
                push(dest, strip2 + "&")
            else if ends_with(text, "S") and set[strip1] == PRESENT:
                set[strip1] = ALREADY_SAVED
                push(dest, strip1 + "$")
            else:
                push(dest, text)
    
    // Allow the set to be garbage collected before we compute a giant
    // string.
    set = ∅
    array = ∅

    dest = join(dest, ",")
    
    const lz = string_compress(dest)
    
    // Because the array was not empty, the output
    // must have at least 3 characters
    assert(size(lz) ≥ 3)
    
    assert(string_decompress(lz) == dest)        
    
    return lz
    
    

/* Returns an array of Q-encoded words */
def decompress_word_list(string):
    assert(string ≠ ∅)
    
    if string == "": return []
    
    // Compressed with LZ as well as plural-specific compression of the list.
    string = string_decompress(string)
    
    const result = []
    const array = split(string, ",")
    for i < size(array):
        let text = array[i]
        if ends_with(text, "$"):
            text = slice(text, 0, size(text) - 1)
            push(result, text + "S")
        else if ends_with(text, "&") or ends_with(text, "§"):
            // § is legacy support. Avoiding unicode characters
            // increases our compression options
            text = slice(text, 0, size(text) - 1)
            push(result, text + "ES")
            
        push(result, text)
    
    return result
    


def stats_save(stats):
    const s = deep_clone(stats)
    for day in s:
        day.xp = encode_xp(day.xp)
        
        // This may improve compression under LZW
        sort(day.word_list)
        day.word_list = compress_word_list(day.word_list)
    save_local("stats", s)
    
    

/* Returns a new stats object loaded from storage. */
def stats_load():
    let stats = load_local("stats")

    if stats:
        // Template for missing fields
        const empty = make_empty_stats_entry()
        
        // Decode all entries
        for day at date in stats:
            day.xp = decode_xp(day.xp)
            day.word_list = decompress_word_list(day.word_list default "")
            
            // Apply defaults for upgrading any fields on old save files
            for v at k in empty:
                day[k] = day[k] default deep_clone(v)
            
            todo("This can be removed after August or when the format stabilizes")
            // Remove unused fields on old save files
            let valid = keys(empty)
            for k in keys(day):
                if not contains(valid, k):
                    debug_print("Removing unused key", k)
                    remove_key(day, k)
                
        // Everything is decoded now. Merge any
        // days before today into lifetime
        stats_merge_previous_days(stats)
    else:
        stats = {lifetime: make_empty_stats_entry()}

    if DEBUG.FORCE_LEVEL:
        stats.lifetime.xp = level_to_xp(DEBUG.FORCE_LEVEL)
        
    // Ensure an entry for today
    stats[today_date_string()] = stats[today_date_string()] default make_empty_stats_entry()
        
    return stats



/* Roll up every day other than today into the lifetime stats, and
   then delete those days. */
def stats_merge_previous_days(stats)
& with lifetime in stats:
    const today_date = today_date_string(true)
    
    // Ensure there is a stats entry for today
    stats[today_date] = stats[today_date] default make_empty_stats_entry()
                
    for date in keys(stats):
        // Skip the two elements we are not modifying: the new day and 
        // the lifetime stats
        if date == "lifetime" or date == today_date: continue
    
        const day = stats[date]
                    
        for ignore at field in lifetime.badge_count:
            lifetime.badge_count[field] += day.badge_count[field]
            
        if size(day.longest_text) > size(lifetime.longest_text):
            lifetime.longest_text = day.longest_text
        
        for field in ["best_word", "best_freestyle_word", "best_wild_word"]:
            if day[field + "_points"] > lifetime[field + "_points"]:
                lifetime[field + "_points"] = day[field + "_points"]
                lifetime[field + "_text"] = day[field + "_text"]

        for field in ["best_score", "most_words"]:
            lifetime[field] = max(lifetime[field], day[field])
        
        for field in ["words", "points", "matches", "xp"]:
            lifetime[field] += day[field]
            
        push(lifetime.word_list, …day.word_list)
        
        // Remove this old day now that it is rolled up into lifetime
        remove_key(stats, date)
    
    
    
/* Used for lightly protecting the saved value from casual abuse via a checksum */
def encode_xp(xp):
    return slice("" + hash(xp), 2) + "." + xp
        
        
        
/* Used for lightly protecting the saved value from casual abuse via a checksum */
def decode_xp(str):
    if type(str) ≠ "string":
        // Was not properly encoded
        return 0

    // Decode and then re-encode and verify match
    const xp = parse(split(str, ".")[1])
    return if (encode_xp(xp) == str) then xp else 0
    
    

/* Don't let the value change except when stats are updated in
   `stats_merge_previous_days()`, otherwise we'll access uncollected data. */
def today_date_string(update default false):
    if update or not today_date_string.today_date:
        const date = local_time()
        today_date_string.today_date = "" + date.year + "-" + (date.month + 1) + "-" + date.day
    return today_date_string.today_date



/* 
    Update the player's stats and level given the results in 
    competitor from a global match. Does not save.
    
    Returns a list of new unique words and the XP for badges and words.
*/
def stats_update(stats, competitor, num_competitors, joined_late):

    // We may have passed midnight, so roll up any previous days
    // if needed before updating today's entry
    stats_merge_previous_days(stats)

    assert(stats)
    
    const stats_entry = stats[today_date_string()]

    if size(competitor.longest_text) > size(stats_entry.longest_text):
        stats_entry.longest_text = competitor.longest_text

    for field in ["best_word", "best_freestyle_word", "best_wild_word"]:
        if competitor[field + "_points"] > stats_entry[field + "_points"]:
            stats_entry[field + "_points"] = competitor[field + "_points"]
            stats_entry[field + "_text"]   = competitor[field + "_text"] 
    
    stats_entry.best_score = max(competitor.score, stats_entry.best_score)
    
    stats_entry.freestyle_points += competitor.freestyle_points
    
    const N = size(competitor.word_list) + size(competitor.freestyle_list)
    if N > stats_entry.most_words:
        stats_entry.most_words = N
    
    if not joined_late:
        stats_entry.words += N
        stats_entry.points += competitor.score
        ++stats_entry.matches
    
    todo("Abstract the badge system to allow iteration")
    if competitor == competitor_array[0]:
        ++stats_entry.badge_count.highest_score
        
    if competitor == best_word_winner:
        ++stats_entry.badge_count.best_word
    
    if competitor == best_rare_winner:
        ++stats_entry.badge_count.best_rare

    if competitor == longest_winner:
        ++stats_entry.badge_count.longest
        
    if competitor == most_words_winner:
        ++stats_entry.badge_count.most_words
 
    // XP for score
    stats_entry.xp += ⌈competitor.score * XP.VALUE.point⌉
    
    // XP for badges
    const badge_xp = if player.has_ability["Badge XP"] then (XP.VALUE.badge_per_competitor * min(num_competitors - 1, 10) * size(competitor.badges)) else 0
    stats_entry.xp += badge_xp

    // Accumulate the words previously found by this player
    const previously_found = array_to_set([…stats.lifetime.word_list, …stats_entry.word_list], 1)
    
    // Add the new words
    const unique = []
    for list in [competitor.word_list, competitor.freestyle_list]:
        for word in entry in list:
            if not previously_found[word]:
                push(stats_entry.word_list, word)
                push(unique, word)
    
    
    const word_xp = if player.has_ability["Discovery XP"] then size(unique) * XP.VALUE.unique_word else 0
    stats_entry.xp += word_xp
    
    return {unique_word_list: unique, badge_xp: badge_xp, word_xp: word_xp}
    
    

/* Returns the region */
def draw_stats_button(pos, selected, radius):
    const sprite_args = {sprite: stats_sprite[0][0], pos: pos, z: 10, scale: radius / 20}
    
    if selected:
        draw_round_selection(pos, radius)
        draw_outlined_sprite({…sprite_args, override_color: #EEE}, #090)
    else:
        // Background
        draw_disk(pos, radius, #FFFC, #DDD, 9)
        draw_sprite(sprite_args)    
        
    draw_text({
        font: score_font, 
        text: "Stats", 
        color: if selected then #FFF else #EEE,
        outline: if selected then rgba(CURSOR_COLOR, 50%) else ∅,
        shadow: #000, 
        pos: pos + xy(0, 27),
        z: 100})

    if not player.has_achievement["Check Stats"]:
        draw_tutorial(pos - xy(0, radius), "Check\nStats", 270°, "left")

    return {pos: pos, shape: "disk", size: radius * xy(2, 2)}        
  

    