
/* A `stats` object contains `{lifetime: stats_entry, <date>: stats_entry, …, word_list: []}` */
def make_empty_stats_entry():
    return {
        badge_count: {
            best_rare: 0,
            longest: 0,
            best_word: 0,
            highest_score: 0,
            most_words: 0,
            most_rare_words: 0
        },

        longest_text: "",
        longest_freestyle_text: "",

        best_word_text: "", 
        best_word_points: 0,

        // See note in competitor.pyxl
        best_freestyle_word_text: "",
        best_freestyle_word_points: 0,
        
        // See note in competitor.pyxl
        // Includes the wildcard
        //
        // Was "best_wild_word_points/text"
        best_freestyle_points: 0,
        best_freestyle_text: "",

        best_score: 0,

        most_words: 0,
        
        // Number of times remix was hit
        remixes: 0,
        
        // Total number of words captured by remix
        remix_words: 0,
        
        // Max words captured by a single remix
        best_remix: 0,
        
        words: 0,

        points: 0,
        
        // Total freestyle points, vs. max
        freestyle_points: 0,
        
        // Needed for normalizing freestyle correctly
        freestyle_matches: 0,

        matches: 0,
        
        // Intentionally 1, so that each day is counted
        days: 1,

        xp: 0,

        word_list: []}
        
        

def stats_total_xp(stats):
    let xp = 0
    for stats_entry in stats:
        xp += stats_entry.xp
    return xp
    
    

/* Assumes the input is a list of q-encoded, all-caps words. 
   Returns a string packing them into a form that serializes
   efficiently.
   
   quadplay limits the length of serialized save_local values, so
   compress by:
   
   - Using a single string, eliminating an extra comma and quote from each word
   - Using suffix encoding for variants with trivial plurals:
       - § = + ES
       - $ = + S
       
   followed by string_compress()
   */
def compress_word_list(array):
    if size(array) == 0: return ""
    
    const PRESENT = 2
    const ALREADY_SAVED = 1
    
    // Start with words sorted from longest to shortest
    // (so we see prefixes first), and then mark all present
    array = sorted(array, size_comparator, true)

    // Maps each word to PRESENT or ALREADY_SAVED
    let set = array_to_set(array, PRESENT)
        
    // Encode the words of array. Process in order from longest
    // to shortest so that suffix encodings work
    let dest = []
    
    for i < size(array):
        const text = array[i]
        if set[text] ≠ ALREADY_SAVED:
            // Technically unnecessary; we won't return to this word
            set[text] = ALREADY_SAVED
            
            // Because of the way that the game scores words,
            // it is actually impossible to have found the suffix
            // plural without the singular. However, this logic is good
            // for later generalizing to other suffixes
            // and prefixes.
            const strip2 = slice(text, 0, size(text) - 2)
            const strip1 = slice(text, 0, size(text) - 1)
            if ends_with(text, "ES") and set[strip2] == PRESENT:
                set[strip2] = ALREADY_SAVED
                push(dest, strip2 + "&")
            else if ends_with(text, "S") and set[strip1] == PRESENT:
                set[strip1] = ALREADY_SAVED
                push(dest, strip1 + "$")
            else:
                push(dest, text)
    
    // Allow the set to be garbage collected before we compute a giant
    // string.
    set = ∅
    array = ∅
    
    return string_compress(join(dest, ","))
    
    

/* Returns an array of Q-encoded words */
def decompress_word_list(string):
    assert(string ≠ ∅)
    
    if string == "": return []
    
    // Compressed with LZ as well as plural-specific compression of the list.
    string = string_decompress(string)
    
    const result = []
    const array = split(string, ",")
    for i < size(array):
        let text = array[i]
        if ends_with(text, "$"):
            text = slice(text, 0, size(text) - 1)
            push(result, text + "S")
        else if ends_with(text, "&"):
            text = slice(text, 0, size(text) - 1)
            push(result, text + "ES")
            
        push(result, text)
    
    return result
    


def stats_save(stats):
    const s = deep_clone(stats)
    for day in s:
        day.xp = encode_xp(day.xp)
        
        // This may improve compression under LZW
        sort(day.word_list)
        day.word_list = compress_word_list(day.word_list)
        
    save_local("stats", s)
    
    

/* Returns a new stats object loaded from storage. */
def stats_load():
    let stats = load_local("stats")

    if stats:
        // Template for missing fields
        const empty = make_empty_stats_entry()
        
        // Decode all entries (this includes date = "lifetime")
        for day at date in stats:
            day.xp = decode_xp(day.xp)
            day.word_list = decompress_word_list(day.word_list default "")
            
            // Apply defaults for upgrading any fields on old save files
            for v at k in empty:
                day[k] = day[k] default deep_clone(v)
            
            // Upgrade
            todo("Legacy upgrade: Remove after September")
            if is_nan(day.freestyle_points):
                day.freestyle_points = 0               
            if day.best_wild_word_points ≠ ∅:
                day.best_freestyle_points = day.best_wild_word_points
                remove_key(day, "best_wild_word_points")
            if day.best_wild_word_text ≠ ∅:
                day.best_freestyle_text = day.best_wild_word_text
                remove_key(day, "best_wild_word_text")
            /*            
            // Remove unused fields on old save files
            let valid = keys(empty)
            for k in keys(day):
                if not contains(valid, k):
                    debug_print("Removing unused key", k)
                    remove_key(day, k)
                    */
                
        // Everything is decoded now. Merge any
        // days before today into lifetime
        stats_merge_previous_days(stats)
    else:
        stats = {lifetime: make_empty_stats_entry()}

    if DEBUG.FORCE_LEVEL:
        stats.lifetime.xp = level_to_xp(DEBUG.FORCE_LEVEL)
        
    // Ensure an entry for today
    stats[today_date_string()] = stats[today_date_string()] default make_empty_stats_entry()
        
    return stats



/* Roll up every day other than today into the lifetime stats, and
   then delete those days. */
def stats_merge_previous_days(stats)
& with lifetime in stats:
    
    const today_date = today_date_string(true)
    
    // Ensure there is a stats entry for today
    stats[today_date] = stats[today_date] default make_empty_stats_entry()
                
    for date in keys(stats):
        // Skip the two elements we are not modifying: the new day and 
        // the lifetime stats
        if date == "lifetime" or date == today_date: continue
    
        const day = stats[date]
                    
        for ignore at field in lifetime.badge_count:
            lifetime.badge_count[field] += day.badge_count[field]

        for field in ["longest_text", "longest_freestyle_text"]:            
            if size(day[field]) > size(lifetime[field]):
                lifetime[field] = day[field]
        
        for field in ["best_word", "best_freestyle_word", "best_freestyle"]:
            if day[field + "_points"] > lifetime[field + "_points"]:
                lifetime[field + "_points"] = day[field + "_points"]
                lifetime[field + "_text"] = day[field + "_text"]

        for field in ["best_score", "most_words"]:
            lifetime[field] = max(lifetime[field], day[field])
        
        for field in ["words", "points", "matches", "freestyle_matches", "xp", "days", "freestyle_points"]:
            lifetime[field] += day[field]
            
        push(lifetime.word_list, …day.word_list)
        
        // Remove this old day now that it is rolled up into lifetime
        remove_key(stats, date)
    
    
    
/* Used for lightly protecting the saved value from casual abuse via a checksum */
def encode_xp(xp):
    return slice("" + hash(xp), 2) + "." + xp
        
        
        
/* Used for lightly protecting the saved value from casual abuse via a checksum */
def decode_xp(str):
    if type(str) ≠ "string":
        // Was not properly encoded
        return 0

    // Decode and then re-encode and verify match
    const xp = parse(split(str, ".")[1])
    return if (encode_xp(xp) == str) then xp else 0
    
    

/* Don't let the value change except when stats are updated in
   `stats_merge_previous_days()`, otherwise we'll access uncollected data. */
def today_date_string(update default false):
    if update or not today_date_string.today_date:
        const date = local_time()
        today_date_string.today_date = "" + date.year + "-" + (date.month + 1) + "-" + date.day

    return today_date_string.today_date



/* 
    Update the player's stats and level given the results in 
    competitor from a global match. Does not save.

    Returns a list of new unique words and the XP for badges and words.
*/
def stats_update_after_match(stats, competitor, num_competitors, joined_late):

    // We may have passed midnight, so roll up any previous days
    // if needed before updating today's entry
    stats_merge_previous_days(stats)

    assert(stats)
    
    const stats_entry = stats[today_date_string()]
    
    stats_entry["remixes"] += competitor.remixes
    stats_entry["remix_words"] += competitor.remix_words
    stats_entry["best_remix"] = max(stats_entry["best_remix"], competitor.best_remix)

    for field in ["longest_text", "longest_freestyle_text"]:
        if size(competitor[field]) > size(stats_entry[field]):
            stats_entry[field] = competitor[field]

    for field in ["best_word", "best_freestyle_word", "best_freestyle"]:
        if competitor[field + "_points"] > stats_entry[field + "_points"]:
            stats_entry[field + "_points"] = competitor[field + "_points"]
            stats_entry[field + "_text"]   = competitor[field + "_text"] 
    
    stats_entry.best_score = max(competitor.score, stats_entry.best_score)
        
    const N = size(competitor.word_list) + size(competitor.freestyle_word_list)
    if N > stats_entry.most_words:
        stats_entry.most_words = N
    
    if not joined_late:
        stats_entry.words += N
        stats_entry.points += competitor.score
        stats_entry.freestyle_points += competitor.best_freestyle_points
                
        if competitor.score:
            // Don't count if they didn't score
            ++stats_entry.matches
        
        if competitor.best_freestyle_points:
            // Don't count the match against normalization if they didn't score freestyle points
            ++stats_entry.freestyle_matches

    // Update badge tracking    
    for pair in [
        [competitor_array[0],           "highest_score"],
        [award_winner.best_word,        "best_word"],
        [award_winner.best_rare,        "best_rare"],
        [award_winner.longest,          "longest"],
        [award_winner.most_words,       "most_words"],
        [award_winner.most_rare_words,  "most_rare_words"]]:
        if competitor == pair[0]:
            ++stats_entry.badge_count[pair[1]]        
 
    // Accumulate the words previously found by this player
    const previously_found = array_to_set([…stats.lifetime.word_list, …stats_entry.word_list], 1)
    
    // Add the new words
    const unique = []
    for list in [competitor.word_list, competitor.freestyle_word_list]:
        for word in entry in list:
            if not previously_found[word]:
                push(stats_entry.word_list, word)
                push(unique, word)
    
    return unique
    
    

/* Returns the region */
def draw_stats_button(pos, selected, radius):
    const sprite_args = {sprite: stats_sprite[0][0], pos: pos, z: 10, scale: radius / 20}
    
    if selected:
        draw_round_selection(pos, radius)
        draw_outlined_sprite({…sprite_args, override_color: #EEE}, #090)
    else:
        // Background
        draw_disk(pos, radius, #FFFC, #DDD, 9)
        draw_sprite(sprite_args)    
        
    draw_text({
        font: score_font, 
        text: "Stats", 
        color: if selected then #FFF else #EEE,
        outline: if selected then rgba(CURSOR_COLOR, 50%) else ∅,
        shadow: #000, 
        pos: pos + xy(0, 27),
        z: 100})

    if not player.has_achievement["Check Stats"]:
        draw_tutorial(pos - xy(0, radius), "Check\nStats", 270°, "left")

    return {pos: pos, shape: "disk", size: radius * xy(2, 2)}        
  

    