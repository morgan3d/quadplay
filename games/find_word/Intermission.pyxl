Intermission
════════════════════════════════════════════════════════════════════════

todo("Favoriting UI + save")
todo("Send emotes?!")

/* Used to prevent multiple VIL effects per intermission */
let played_vil_sound

/* Cycle through the award stages. See `INTERMISSION.STAGE` */
let stage

/* `stage` from the previous frame, used for detecting `stage`
   changes to play sounds */
let prev_stage

let first_frame_this_stage

let selection_index

const STATS_BUTTON_INDEX = 1

let leaderboard_scroll

let intermission_end_time


/* Draw and animate awards in stages */
def draw_awards()
& preserving_transform:
    set_transform(
        if landscape() then xy(SCREEN_SIZE.x - INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, 0)
        else xy(0, INTERMISSION.LAYOUT.HISTORY_PORTRAIT_HEIGHT + 2))
    
    if stage ≠ prev_stage and mode_frames > 10:
        play_sound({sound: word_sound, pan: xy(0, 0)})

    // Find the appropriate function for the stage
    for field in ["SUMMARY", "BEST_WORD", "MOST_WORDS", "LONGEST", "BEST_RARE", "MOST_RARE_WORDS"]:
        if stage == INTERMISSION.STAGE[field]:
            const func = (
                if field == "SUMMARY" then draw_award_summary 
                else (if last_value(field) == "S" then draw_most_words_award 
                else draw_word_award))
                
            func(titlecase(replace(field, "_", " ")), lowercase(field))
                



/* Special sounds for player, Moo, VIL, and caf winning awards */
def maybe_play_award_sound(winner):
    if stage == prev_stage: return
    
    if winner.avatar.id == player_competitor.avatar.id:
        play_sound(award_sound)
    else if winner.avatar.id == NPC.MOO.ID:
        play_sound(moo_00_sound)
    else if winner.avatar.id == NPC.CAF.ID:
        play_sound({sound: moo_01_sound, playback_rate: 200%})
    else if winner.avatar.id == NPC.VIL.ID and not played_vil_sound:
        played_vil_sound = true
        play_sound({sound: vil_00_sound, time: max(random(-1, 1), 0), pitch: random(90%, 150%)})



def draw_award_background(field, avatar, title)
& preserving_transform:
    // Title
    draw_text({text: title, font: leaderboard_font, color: HIGHLIGHT_COLOR, shadow: #000, x_align: "left", pos: xy(5, 7), z: 2})
    
    // This will be within the clipped region, but is drawn 
    // first to avoid clipping the name
    avatar_draw_large(avatar, xy(28, 32), false, ∅, ∅, true)
    
    set_clip(transform_cs_to_ss(xy(4, 13)), xy(52, 36))

    // Background
    draw_text({
        font: leaderboard_font,
        color: 90% avatar.color,
        text: replace("xxxxxxxxx\nxxxxxxxxx\nxxxxxxxxx\nxxxxxxxxx", "x", BADGE_TABLE[field]),
        pos: xy(2, 9),
        y_align: "top",
        x_align: "left"})



/* Called from `draw_awards()` when `stage` == `INTERMISSION.STAGE.SUMMARY` */
def draw_award_summary():
    player_deselect_all(player)    
    draw_corner_rect(xy(0, 0), xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, INTERMISSION.LAYOUT.AWARD_HEIGHT), player.avatar.color)
        
    const shadow = 70% player.avatar.color

    draw_text({
        color:   #FFF,
        shadow:  shadow,
        font:    history_font,
        text:    "Level " + player.avatar.level,
        pos:     xy(21, 9)})
        
    avatar_draw_large(player.avatar, xy(25, 32), false, #FFF, shadow)

    const args = {
        font: history_font,
        x_align: "left",
        y_align: "baseline",
        shadow: shadow,
        color: #FFF}

    // Score
    draw_text({ …args, text: format_number(player.score, "commas") + " {font:leaderboard_font pts}", font: score_font, pos: xy(28, 2) + xy(105, 12), x_align: "right", markup: true})

    for pair at i in [
        ["Words", size(player_competitor.word_list) + size(player_competitor.freestyle_word_list)], 
        ["Rare Words", size(player_competitor.rare_list)],
        ["Awards", player_competitor.badges or "None"],
        ["Rank", "" + player_competitor.rank + "/" + size(competitor_array)]]:
                
        draw_text({…args, text: pair[0], pos: xy(64, 26 + 10i)})
        draw_text({…args, text: pair[1], pos: xy(142, 26 + 10i), x_align: "right"})

    // draw_text({…args, text: "Longest", pos: xy(x, 24)})
    // draw_text({…args, text: player_competitor.longest_text, font: history_font, pos: xy(30, 24), x_align: "right"})

    player_draw_mini(player, xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 27, 33))
    


/* Used for best_word, longest, The title is used to compute the field */
def draw_word_award(title, field):
    const text = award_winner[field][field + "_text"]

    if text:
        maybe_play_award_sound(award_winner[field])
        
        draw_award_background(field, award_winner[field].avatar, title)
        
        if award_winner[field] == player_competitor or not offensive[lowercase(text)]:
            player_select_word(player, text)
            player_draw_mini(player, xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 33, 38))
    


def draw_most_words_award(title, field):
    maybe_play_award_sound(award_winner[field])
    ++draw_most_words_award.frames
    player.selection_color = HIGHLIGHT_COLOR

    const list = award_winner[field][slice(field, size("most_"), last_key(title)) + "_list"]
    if not size(list): return

    draw_award_background(field, award_winner[field].avatar, title + ": " + size(list))

    let word
    // Find a non-offensive word, but give up after four tries instead of locking up
    for i < 4:
        word = array_value(list, (draw_most_words_award.frames / INTERMISSION.MOST_WORDS_AWARD_FRAMES_PER_WORD) + draw_most_words_award.skip, "loop").word
        if award_winner[field] ≠ player_competitor and offensive[lowercase(q_decode(word))]:
            // Skip over this word
            ++draw_most_words_award.skip

    // List of words
    for i < min(12, size(list)):
        draw_text({
            text: if i == 11 then "..." else censor(q_decode(list[i].word)),
            font: history_font,
            color: #888,
            x_align: "left",
            y_align: "top",
            pos: xy(62 + 55 ⌊i / 6⌋, 9 (i mod 6) + 12)})
    
    if award_winner[field] == player_competitor or not offensive[lowercase(q_decode(word))]:
        player_select_word(player, word)
        player_draw_mini(player, xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 33, 38))



/* Draw the ranked competitors and perform UI logic */
def draw_leaderboard()
& preserving_transform:
    
    // Dimension of the scroll rectangle on the screen
    const leaderboard_corner = (
        if landscape() then xy(SCREEN_SIZE.x - INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, INTERMISSION.LAYOUT.AWARD_HEIGHT)
        else xy(0, INTERMISSION.LAYOUT.HISTORY_PORTRAIT_HEIGHT + INTERMISSION.LAYOUT.AWARD_HEIGHT + 2)) + xy(0, INTERMISSION.LAYOUT.LEADERBOARD.HEADER_HEIGHT)

    const leaderboard_size = SCREEN_SIZE - leaderboard_corner - xy(0, 22)
    
    set_transform(leaderboard_corner - xy(0, INTERMISSION.LAYOUT.LEADERBOARD.HEADER_HEIGHT))

    // Line at top of leaderboard against the awards
    draw_corner_rect(xy(0, 0), xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, 2), #000, ∅, 20)
    
    // Header
    const args = {x_align: "right", font: history_font, color: HIGHLIGHT_COLOR, shadow: #000}
    draw_text({…args, text: "Player", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.AVATAR_X - 6, 7), x_align: "left"})
    draw_text({…args, text: "Lvl", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.LEVEL_X, 7)})
    //    draw_text({…args, text: "Award", x_align: "left", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.BADGE_X - 6, 7)})
    draw_text({…args, text: "Score", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.SCORE_X, 7)})
    draw_text({…args, text: "Words", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.COUNT_X, 7)})
    
    if player.has_ability["Freestyle"]:
        draw_text({…args, text: "Freestyle", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.FREESTYLE_X + 18, 7)})
    draw_text({…args, text: "Best Word", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 2, 7)})

    // Content
    scroll_tracker_update(
        leaderboard_scroll,
        xy(0, size(competitor_array) * INTERMISSION.LAYOUT.LEADERBOARD.ROW_SPACING + 2),
        {corner: leaderboard_corner, size: leaderboard_size})
        
    set_clip(leaderboard_corner, leaderboard_size)
    set_transform(leaderboard_corner - leaderboard_scroll.offset)
    // Alternating animation frames for avatar idle animations
    const alt = ⌊mode_frames / 30⌋ mod 2
    const show_freestyle_word = ⌊mode_frames / (60*4.5)⌋ mod 2
    
    for competitor at i in competitor_array:
        // Center of avatar
        const pos = xy(0, i * INTERMISSION.LAYOUT.LEADERBOARD.ROW_SPACING + 9)
                
        const me = (competitor == player_competitor)
        const friend = competitor_is_friend(competitor)
        
        // Highlight
        const highlight_color = if friend then lerp(competitor.avatar.color, #333, 75%) else (if me then competitor.avatar.color else ∅)
        draw_corner_rect(pos - xy(0, 9), xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, 18), highlight_color, ∅, ∅, -3)

        const text_args = {
            font: leaderboard_font,
            shadow: if me then 60% competitor.avatar.color else ∅,
            x_align: "left",
            color: if me or friend then #FFF else #999}
        
        if friend:
            draw_text({…text_args,
                pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.AVATAR_X - 14, 0),
                text: if competitor.avatar.bot and not competitor.avatar.appears_human then "♡" else "♥"})
                
        avatar_draw({avatar: competitor.avatar, sprite: competitor.avatar.sprite.x_flipped, pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.AVATAR_X, 0), z: 10})
        
        draw_text({…text_args,
            text: competitor.avatar.level,
            font: history_font,
            x_align: "right",
            pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.LEVEL_X, 1),
            color: if me then #FFF else competitor.avatar.color})
                        
        draw_text({…text_args,
            text: competitor.avatar.name,
            outline: if competitor.avatar.level ≥ ABILITY_TABLE.Aura.level then rgba(1, 1, 1, 40% ceil(oscillate(mode_frames / 60, 0.1, 1.0), ¼)) else ∅,
            pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.NAME_X, 0),
            color: if me then #FFF else competitor.avatar.color})
        
        // Score
        draw_text({…text_args, text: format_number(competitor.score, "commas"), pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.SCORE_X, 0), x_align: "right"})

        // Awards
        if size(competitor.badges) > 2:
            draw_text({…text_args,
                text: slice(competitor.badges, 0, 2),
                pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1 - 4)})
            draw_text({…text_args,
                text: slice(competitor.badges, 2),
                pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1 + 4)})
        
        else if size(competitor.badges) > 0:
            draw_text({…text_args,
                text: competitor.badges,
                pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1)})
        
        // Words
        draw_text({…text_args, text: size(competitor.word_list) + size(competitor.freestyle_word_list), pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.COUNT_X, 0), x_align: "right"})

        // Freestyle points
        if player.has_ability["Freestyle"] and competitor.best_freestyle_points:
            draw_text({…text_args, text: format_number(competitor.best_freestyle_points, "commas"), pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.FREESTYLE_X, 0), x_align: "right"})

        // Best word
        const freestyle_word = (show_freestyle_word and size(competitor.freestyle_word_list))
        let text = (
            if freestyle_word then 
                (if player.has_ability["Wild"] then
                    // Show the real pattern
                    competitor.best_freestyle_text else
                    // Show the best word resulting from the pattern
                    q_decode(competitor.freestyle_word_list[0].word))
            else 
                q_decode((competitor.word_list[0] default {word: "∅"}).word))

        if competitor ≠ player_competitor:
            text = censor(text)
            
        draw_text({
            …text_args, 
            font: history_font, 
            text: enquote_if(freestyle_word, text), 
            x_align: "right", 
            pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 2, 0)})



def draw_intermission_countdown():
    const time_left = if DEBUG.EARN_XP then 0 else (if DEBUG.INTERMISSION then 21 else max(intermission_end_time - frame_utc_now, 0))
    const α = clamp(100% - time_left / INTERMISSION.SECONDS, 0%, 100%)
    
    const countdown_rect = {
        corner: xy(34, SCREEN_SIZE.y - 20),
        size: xy(SCREEN_SIZE.x - 68, 20)}
    
    // Separator bar
    draw_corner_rect(xy(0, SCREEN_SIZE.y - 22), xy(SCREEN_SIZE.x, 2), #000, ∅, -1)
    
    // Stats button
    const stats_region = {pos: xy(16, SCREEN_SIZE.y - 10), size: 10 xy(2, 2), shape: "disk"}
    if touch.hover:
        selection_index = if overlaps(touch.hover, stats_region) then STATS_BUTTON_INDEX else 0
    else if player.using_gamepad:
        selection_index = 0
        draw_text({font: leaderboard_font, pos: stats_region.pos + xy(-12, 4), text: joy.prompt["(q)"], color: #DDD, outline: #000, z: 10})

    if get_mode() == DisplayStats:
        draw_disk(stats_region.pos, 10, #FFF)
        draw_sprite({sprite: ability_icon.cancel, pos: stats_region.pos, scale: 75%})
        if mode_frames > 20 and ((touch.pressed_a and overlaps(touch.xy, stats_region)) or joy.pressed_q):
            pop_mode()

    else if player.has_ability["Stats Tracker"]:

        draw_stats_button(stats_region.pos, selection_index == STATS_BUTTON_INDEX, ½ stats_region.size.x)
        
        if (touch.pressed_a and overlaps(touch.xy, stats_region)) or joy.pressed_q:
            push_mode(DisplayStats, draw_intermission_countdown) because "Button"

    // Progress bar
    draw_corner_rect(countdown_rect.corner, countdown_rect.size, #000, #FFF)
    draw_corner_rect(countdown_rect.corner + 1, xy(round(α * (countdown_rect.size.x - 2)), countdown_rect.size.y - 2), if α < 95% then HIGHLIGHT_COLOR else #0F0)
    
    // Show the additional EARN_XP_SECONDS time so that players don't feel like
    // the level up animation counts against their play time
    draw_text({
        font: score_font,
        text: "New match in " + format_number(time_left + EARN_XP_SECONDS, "timer"),
        outline: #0009,
        pos: xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 9),
        color: #FFF})

    // Check box
    const autostart_rect = {pos: SCREEN_SIZE - xy(15, 10), size: xy(20, 20)}
    draw_rect(autostart_rect.pos - xy(0, 5), autostart_rect.size - 9, #000, #FFF)
    
    if touch.pressed_a and overlaps(touch.xy, autostart_rect):
        play_sound(select_tile_sound)
        draw_intermission_countdown.ready = not draw_intermission_countdown.ready
        save_local("autostart", draw_intermission_countdown.ready)
        
    if draw_intermission_countdown.ready:
        draw_text({
            pos: autostart_rect.pos + xy(0, -4),
            color: #0F0,
            outline: #000,
            shadow: #0008,
            font: score_font,
            text: "✓"})
            
    draw_text({
        pos: autostart_rect.pos + xy(0, 6),
        color: #FFF,
        font: history_font,
        text: "Ready"})    
        
    if α ≥ 100% and (draw_intermission_countdown.ready or touch.pressed_a and overlaps(countdown_rect, touch.xy)):
        set_mode(EarnXP) because "Timer and Ready"
        
draw_intermission_countdown.ready = load_local("autostart") default true   
   


pop_mode from DisplayStats
────────────────────────────────────────────────────────────────────────
selection_index = 0



enter
────────────────────────────────────────────────────────────────────────
set_background(#333)

selection_index = 0
leaderboard_scroll = make_scroll_tracker()
played_vil_sound = false
stage = 0
prev_stage = stage
first_frame_this_stage = 0

// End time of the post-game sequence INCLUDING the EarnXP mode
end_time = next_global_game_utc_start_time()
if DEBUG.EARN_XP:
    end_time = frame_utc_now + EARN_XP_SECONDS + 1
    
intermission_end_time = end_time - EARN_XP_SECONDS

// See if NPS have any commentary

const competitor_table = {}
for competitor in competitor_array:
    competitor_table[competitor.avatar.id] = competitor
    
if competitor_table[NPC.CAF.ID] and competitor_table[NPC.CAF.ID].score == 0 and not DEBUG.EARN_XP:
    set_npc_message(caf_avatar, "too hard!!!!!", 0, {sound: caf_too_hard_sound}, 60 * 4)

if competitor_table[NPC.VIL.ID]:
    if player_competitor.beat_vil_regular_match:
        // Player won
        if not player.has_achievement["Beat VIL Once"]:
            player_achieve(player, "Beat VIL Once", false)
            set_npc_message(vil_avatar, "You beat ME?! It is a perversion of nature to be vanquished by your intellectual paucity. I demand a rematch!", 6, {sound: vil_00_sound}, 60 * 10)
    else if ξ < 8%:
        if size(competitor_table[NPC.VIL.ID].badges) > 0 and size(player_competitor.badges) == 0:
            // VIL won and blocked the player from badges
            set_npc_message(vil_avatar, "No award XP for you!", 1, {sound: vil_00_sound}, 60 * 8)
        else:
            // VIL won, but didn't beat the player on badges
            set_npc_message(vil_avatar, random_value([
                "Ignoramus.", 
                "You have a vegetal cerebrum.", 
                "So sorry.", 
                "How unfortunate for you.", 
                "Go lacrimate with your cattle.",
                "Your orthographic abilities are profoundly insufficient.",
                "I detest the cacophonous squawking of that zealous avian.",
                "Observe the vacant expression on your cud-chewing friend.",
                "These animals form a menagerie of the unintelligent, led by the inadequate.",
                "Your ornithological allies possess a rudimentary intellect, at best.",
                "Your lexicon appears as limited as your prospects."]), 1, {sound: vil_00_sound}, 60 * 8)

todo("Make multi-message npc API")
todo("Test npc messages above")
todo("VIL-MzK interaction")

if competitor_table[NPC.VIL.ID] and competitor_table[NPC.CAF.ID]:        
    todo("VIL-caf interaction")

   
frame
────────────────────────────────────────────────────────────────────────

prev_stage = stage
if not notifications_pending():
    // Cycle through awards, giving equal time to each. Don't advance
    // while notifications are appearing
    stage = min(⌊size(INTERMISSION.STAGE) * mode_frames / (60 INTERMISSION.SECONDS)⌋, size(INTERMISSION.STAGE) - 1)
    
    if stage == INTERMISSION.STAGE.MOST_WORDS2 or stage == INTERMISSION.STAGE.MOST_WORDS3:
        stage = INTERMISSION.STAGE.MOST_WORDS
    else if stage == INTERMISSION.STAGE.MOST_RARE_WORDS2:
        stage = INTERMISSION.STAGE.MOST_RARE_WORDS
        
    if prev_stage ≠ stage:
        first_frame_this_stage = mode_frames
        
        // Used to animate which word is being shown
        draw_most_words_award.frames = 0
        
        // Used to skip over offensive words
        draw_most_words_award.skip = 0


// Separator bars
if landscape():
    // Vertical separator
    draw_corner_rect(xy(SCREEN_SIZE.x - INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 2, 0), xy(2, SCREEN_SIZE.y), #000, ∅, -1)

// History
const history_rect = (
    if landscape() then {corner: xy(0, 0), size: xy(SCREEN_SIZE.x - INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 2, SCREEN_SIZE.y - 22)}
    else {corner: xy(0, 0), size: xy(SCREEN_SIZE.x, INTERMISSION.LAYOUT.HISTORY_PORTRAIT_HEIGHT)})

history_update(player.history, history_rect)
draw_corner_rect(history_rect.corner + xy(0, history_rect.size.y), xy(history_rect.size.x, 2), #000, ∅, -1)

draw_awards()

draw_leaderboard()

draw_intermission_countdown()



leave
────────────────────────────────────────────────────────────────────────
disconnect_from_network()
