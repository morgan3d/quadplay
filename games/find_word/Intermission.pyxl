Intermission
════════════════════════════════════════════════════════════════════════

todo("Favoriting UI + save")
todo("Send emotes?!")
todo("notify on personal best ever score > best free score > best wild > best daily")

/* Used to prevent multiple VIL effects per intermission */
let played_vil_sound

/* Cycle through the award stages. See `INTERMISSION.STAGE` */
let stage

/* `stage` from the previous frame, used for detecting `stage`
   changes to play sounds */
let prev_stage

let first_frame_this_stage

let selection_index

const STATS_BUTTON_INDEX = 1

let leaderboard_scroll

let intermission_end_time


/* Draw and animate Awards (Summary, Longest, Best Word, Best rare, High Score, Most Words) */
def draw_awards()
& preserving_transform:
    set_transform(
        if landscape() then xy(SCREEN_SIZE.x - INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, 0)
        else xy(0, INTERMISSION.LAYOUT.HISTORY_PORTRAIT_HEIGHT + 2))
    
    if stage ≠ prev_stage and mode_frames > 10:
        play_sound({sound: word_sound, pan: xy(0, 0)})

    if stage == INTERMISSION.STAGE.SUMMARY:
        draw_award_summary()
   
    else if stage == INTERMISSION.STAGE.BEST_WORD:
        draw_word_award("Best Word", best_word_winner)
   
    else if stage == INTERMISSION.STAGE.LONGEST:
        draw_word_award("Longest", longest_winner)
        
    else if stage == INTERMISSION.STAGE.BEST_RARE:
        draw_word_award("Best Rare", best_rare_winner)
    
    else if stage == INTERMISSION.STAGE.MOST_WORDS:
        draw_most_words_award(most_words_winner)



/* Called from `draw_awards()` when `stage` == `INTERMISSION.STAGE.SUMMARY` */
def draw_award_summary():
    board_deselect_all(player.board, player)    
    draw_corner_rect(xy(0, 0), xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, INTERMISSION.LAYOUT.AWARD_HEIGHT), player.avatar.color)
        
    const shadow = 70% player.avatar.color

    draw_text({
        color:   #FFF,
        shadow:  shadow,
        font:    history_font,
        text:    "Level " + player.avatar.level,
        pos:     xy(21, 9)})
        
    avatar_draw_large(player.avatar, xy(21, 30), false, #FFF, shadow)

    const args = {
        font: history_font,
        x_align: "left",
        y_align: "baseline",
        shadow: shadow,
        color: #FFF}

    // Score
    draw_text({ …args, text: format_number(player.score, "commas") + " {font:leaderboard_font pts}", font: score_font, pos: xy(28, 2) + xy(105, 12), x_align: "right", markup: true})

    draw_text({…args, text: "Rare Words", pos: xy(49, 26)})
    draw_text({…args, text: player_competitor.num_rare, pos: xy(135, 26), x_align: "right"})

    // draw_text({…args, text: "Longest", pos: xy(x, 24)})
    // draw_text({…args, text: player_competitor.longest_text, font: history_font, pos: xy(30, 24), x_align: "right"})

    board_draw_mini(player.board, xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 27, 26))
    


/* Special sounds for player, Moo, VIL, and caf winning awards */
def maybe_play_award_sound(winner):
    if stage == prev_stage: return
    
    if winner.avatar.id == player_competitor.avatar.id:
        play_sound(award_sound)
    else if winner.avatar.id == BOT.MOO.ID:
        play_sound(moo_00_sound)
    else if winner.avatar.id == BOT.CAF.ID:
        play_sound({sound: moo_01_sound, playback_rate: 200%})
    else if winner.avatar.id == BOT.VIL.ID and not played_vil_sound:
        played_vil_sound = true
        play_sound({sound: vil_00_sound, time: max(random(-1, 1), 0), pitch: random(90%, 150%)})



/* Used for best_word, longest, The title is used to compute the field */
def draw_word_award(title, winner):
 
    const field = replace(lowercase(title), {" ": "_"})
    const text = winner[field + "_text"]

    if text:
        maybe_play_award_sound(winner)
        
        draw_award_background({corner: xy(0, 12), size: xy(69, 37)}, field, winner.avatar.color)
    
        draw_text({font: history_font, text: title + "!", color: player.board.selection_color, shadow: #000, pos: xy(35, 7), z: 2})
        
        avatar_draw_large(winner.avatar, xy(35, 31), false, ∅, ∅, true)
        
        if winner == player_competitor or not offensive[lowercase(text)]:
            board_select_word(player.board, text)
            board_draw_mini(player.board, xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 33, 38))
    


def draw_award_background(rect, field, color)
& preserving_transform:
    
    let badge_background = BADGE_TABLE[field]
    for i < 4:
        badge_background += badge_background
    for i < 3:
        badge_background += "\n" + badge_background
    
    set_clip(transform_cs_to_ss(rect.corner), rect.size)
    draw_text({font: leaderboard_font, color: 90% color, text: badge_background, pos: xy(0, -2), y_align: "top", x_align: "left"})



def draw_most_words_award(winner)
& if size(winner.word_list):
    todo("** Show more words")
    todo("** Generalize to most rare words")

    maybe_play_award_sound(winner)
    ++draw_most_words_award.frames
    player.board.selection_color = HIGHLIGHT_COLOR

    draw_text({font: history_font, text: "Most Words: " + size(winner.word_list), color: player.board.selection_color, shadow: #000, pos: xy(35, 7), z: 2})
    draw_award_background({corner: xy(0, 12), size: xy(69, 37)}, "most_words", winner.avatar.color)
    avatar_draw_large(winner.avatar, xy(35, 31), false, player.board.selection_color, ∅, true)

    let word
    // Find a non-offensive word, but give up after four tries instead of locking up
    for i < 4:
        word = array_value(winner.word_list, (draw_most_words_award.frames / INTERMISSION.MOST_WORDS_AWARD_FRAMES_PER_WORD) + draw_most_words_award.skip, "loop").word
        if winner ≠ player_competitor and offensive[lowercase(q_decode(word))]:
            // Skip over this word
            ++draw_most_words_award.skip
            
    if winner == player_competitor or not offensive[lowercase(q_decode(word))]:
        board_select_word(player.board, word)
        board_draw_mini(player.board, xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 33, 38))



/* Draw the ranked competitors and perform UI logic */
def draw_leaderboard()
& preserving_transform:
    
    // Dimension of the scroll rectangle on the screen
    const leaderboard_corner = (
        if landscape() then xy(SCREEN_SIZE.x - INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, INTERMISSION.LAYOUT.AWARD_HEIGHT)
        else xy(0, INTERMISSION.LAYOUT.HISTORY_PORTRAIT_HEIGHT + INTERMISSION.LAYOUT.AWARD_HEIGHT + 2)) + xy(0, INTERMISSION.LAYOUT.LEADERBOARD.HEADER_HEIGHT)

    const leaderboard_size = SCREEN_SIZE - leaderboard_corner - xy(0, 22)
    
    set_transform(leaderboard_corner - xy(0, INTERMISSION.LAYOUT.LEADERBOARD.HEADER_HEIGHT))

    // Line at top of leaderboard against the awards
    draw_corner_rect(xy(0, 0), xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, 2), #000, ∅, 20)
    
    // Header
    const args = {x_align: "right", font: history_font, color: HIGHLIGHT_COLOR, shadow: #000}
    draw_text({…args, text: "Player", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.AVATAR_X - 6, 7), x_align: "left"})
    draw_text({…args, text: "Lvl", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.LEVEL_X, 7)})
    //    draw_text({…args, text: "Award", x_align: "left", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.BADGE_X - 6, 7)})
    draw_text({…args, text: "Score", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.SCORE_X, 7)})
    draw_text({…args, text: "Words", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.COUNT_X, 7)})
    
    if player.has_ability["Freestyle"]:
        draw_text({…args, text: "Free", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.FREESTYLE_X, 7)})
    draw_text({…args, text: "Best Word", pos: xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 2, 7)})

    // Content
    scroll_tracker_update(
        leaderboard_scroll,
        xy(0, size(competitor_array) * INTERMISSION.LAYOUT.LEADERBOARD.ROW_SPACING + 2),
        {corner: leaderboard_corner, size: leaderboard_size})
        
    set_clip(leaderboard_corner, leaderboard_size)
    set_transform(leaderboard_corner - leaderboard_scroll.offset)
    // Alternating animation frames for avatar idle animations
    const alt = ⌊mode_frames / 30⌋ mod 2
    const show_freestyle_word = ⌊mode_frames / (60*4.5)⌋ mod 2
    
    for competitor at i in competitor_array:
        // Center of avatar
        const pos = xy(0, i * INTERMISSION.LAYOUT.LEADERBOARD.ROW_SPACING + 9)
                
        const me = (competitor == player_competitor)
        const friend = competitor_is_friend(competitor)
        
        // Highlight
        const highlight_color = if friend then lerp(competitor.avatar.color, #333, 75%) else (if me then competitor.avatar.color else ∅)
        draw_corner_rect(pos - xy(0, 9), xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH, 18), highlight_color, ∅, ∅, -1)

        const text_args = {
            font: leaderboard_font,
            shadow: if me then 60% competitor.avatar.color else ∅,
            x_align: "left",
            color: if me or friend then #FFF else #999}
        
        if friend:
            draw_text({…text_args,
                pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.AVATAR_X - 14, 0),
                text: "♥"})
                
        draw_sprite(idle_animate_avatar(competitor.avatar.sprite.x_flipped, alt), pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.AVATAR_X, 0))
        
        draw_text({…text_args,
            text: competitor.avatar.level,
            font: history_font,
            x_align: "right",
            pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.LEVEL_X, 1),
            color: if me then #FFF else competitor.avatar.color})
            
        draw_text({…text_args,
            text: competitor.avatar.name,
            pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.NAME_X, 0),
            color: if me then #FFF else competitor.avatar.color})
        
        draw_text({…text_args, text: format_number(competitor.score, "commas"), pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.SCORE_X, 0), x_align: "right"})

        if size(competitor.badges) > 2:
            draw_text({…text_args,
                text: slice(competitor.badges, 0, 2),
                pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1 - 4)})
            draw_text({…text_args,
                text: slice(competitor.badges, 2),
                pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1 + 4)})
        
        else if size(competitor.badges) > 0:
            draw_text({…text_args,
                text: competitor.badges,
                pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1)})
        
        if player.has_ability["Freestyle"] and competitor.freestyle_points:
            draw_text({…text_args, text: format_number(competitor.freestyle_points, "commas"), pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.FREESTYLE_X, 0), x_align: "right"})

        draw_text({…text_args, text: size(competitor.word_list), pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.COUNT_X, 0), x_align: "right"})

        const freestyle_word = (show_freestyle_word and size(competitor.freestyle_word_list))
        let text = q_decode(if freestyle_word then competitor.freestyle_word_list[0].word else (competitor.word_list[0] default {word: "∅"}).word)

        if competitor ≠ player_competitor:
            text = censor(text)
            
        draw_text({
            …text_args, 
            font: history_font, 
            text: enquote_if(freestyle_word, text), 
            x_align: "right", 
            pos: pos + xy(INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 2, 0)})



def update_intermission_countdown():
    const time_left = if DEBUG.EARN_XP then 0 else (if DEBUG.INTERMISSION then 21 else max(intermission_end_time - frame_utc_now, 0))
    const timer_pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 10)
    const α = clamp(100% - time_left / INTERMISSION.SECONDS, 0%, 100%)
    
    const countdown_rect = {
        corner: xy(34, timer_pos.y - 10),
        size: xy(SCREEN_SIZE.x - 68, 20)}
    
    // Separator bar
    draw_corner_rect(xy(0, SCREEN_SIZE.y - 22), xy(SCREEN_SIZE.x, 2), #000, ∅, -1)
    
    // Stats button
    const stats_region = {pos: xy(16, SCREEN_SIZE.y - 10), size: 10 xy(2, 2), shape: "disk"}
    if touch.hover:
        selection_index = if overlaps(touch.hover, stats_region) then STATS_BUTTON_INDEX else 0
    else if player.using_gamepad:
        selection_index = 0
        draw_text({font: leaderboard_font, pos: stats_region.pos + xy(-12, 4), text: joy.prompt["(q)"], color: #DDD, outline: #000, z: 10})

    if get_mode() == DisplayStats:
        draw_disk(stats_region.pos, 10, #FFF)
        draw_sprite({sprite: ability_icon.cancel, pos: stats_region.pos, scale: 75%})
        if mode_frames > 20 and ((touch.pressed_a and overlaps(touch.xy, stats_region)) or joy.pressed_q):
            pop_mode()

    else if player.has_ability["Stats Tracker"]:

        draw_stats_button(stats_region.pos, selection_index == STATS_BUTTON_INDEX, ½ stats_region.size.x)
        
        if (touch.pressed_a and overlaps(touch.xy, stats_region)) or joy.pressed_q:
            push_mode(DisplayStats, update_intermission_countdown) because "Button"

    // Progress bar
    draw_corner_rect(countdown_rect.corner, countdown_rect.size, #000, #FFF)
    draw_corner_rect(countdown_rect.corner + 1, xy(α * (countdown_rect.size.x - 2), countdown_rect.size.y - 2), if α < 95% then HIGHLIGHT_COLOR else #0F0)
    
    // Show the additional EARN_XP_SECONDS time so that players don't feel like
    // the level up animation counts against their play time
    draw_text({
        font: score_font,
        text: if α < 100% then ("New match in " + format_number(time_left + EARN_XP_SECONDS, "timer")) else "New match now!",
        outline: #0009,
        pos: timer_pos + xy(0, 1),
        color: #FFF})

    // Check box
    const autostart_rect = {pos: SCREEN_SIZE - xy(15, 10), size: xy(20, 20)}
    draw_rect(autostart_rect.pos - xy(0, 5), autostart_rect.size - 9, #000, #FFF)
    
    if touch.pressed_a and overlaps(touch.xy, autostart_rect):
        play_sound(select_tile_sound)
        update_intermission_countdown.ready = not update_intermission_countdown.ready
        save_local("autostart", update_intermission_countdown.ready)
        
    if update_intermission_countdown.ready:
        draw_text({
            pos: autostart_rect.pos + xy(0, -4),
            color: #0F0,
            outline: #000,
            shadow: #0008,
            font: score_font,
            text: "✓"})
            
    draw_text({
        pos: autostart_rect.pos + xy(0, 6),
        color: #FFF,
        font: history_font,
        text: "Ready"})    
        
    if α ≥ 100% and (update_intermission_countdown.ready or touch.pressed_a and overlaps(countdown_rect, touch.xy)):
        set_mode(EarnXP) because "Timer and Ready"
        
update_intermission_countdown.ready = load_local("autostart") default true   
   


pop_mode from DisplayStats
────────────────────────────────────────────────────────────────────────
selection_index = 0



enter
────────────────────────────────────────────────────────────────────────
set_background(#333)

selection_index = 0
leaderboard_scroll = make_scroll_tracker()
played_vil_sound = false
stage = 0
prev_stage = stage
first_frame_this_stage = 0
// Used to animate which word is being shown
draw_most_words_award.frames = 0

// Used to skip over offensive words
draw_most_words_award.skip = 0

// End time of the post-game sequence INCLUDING the EarnXP mode
end_time = next_global_game_utc_start_time()
if DEBUG.EARN_XP:
    end_time = frame_utc_now + EARN_XP_SECONDS + 1
    
intermission_end_time = end_time - EARN_XP_SECONDS

    
// See if caf has any commentary. 
for competitor in competitor_array:
    if competitor.avatar.id == BOT.CAF.ID and competitor.score == 0 and not DEBUG.EARN_XP:
        notify(competitor.avatar.sprite, BOT.CAF.descriptor.name, "`too hard!!!!!'", play_sound, {sound: moo_03_sound, pitch: 150%})


frame
────────────────────────────────────────────────────────────────────────

prev_stage = stage
if not notifications_pending():
    // Cycle through awards, giving equal time to each. Don't advance
    // while notifications are appearing
    stage = min(⌊size(INTERMISSION.STAGE) * mode_frames / (60 INTERMISSION.SECONDS)⌋, size(INTERMISSION.STAGE) - 1)
        
    if stage == INTERMISSION.STAGE.MOST_WORDS2:
        // This is 2x as long
        --stage
        
    if prev_stage ≠ stage:
        first_frame_this_stage = mode_frames


// Separator bars
if landscape():
    // Vertical separator
    draw_corner_rect(xy(SCREEN_SIZE.x - INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 2, 0), xy(2, SCREEN_SIZE.y), #000, ∅, -1)

// History
const history_rect = (
    if landscape() then {corner: xy(0, 0), size: xy(SCREEN_SIZE.x - INTERMISSION.LAYOUT.LEADERBOARD.WIDTH - 2, SCREEN_SIZE.y - 22)}
    else {corner: xy(0, 0), size: xy(SCREEN_SIZE.x, INTERMISSION.LAYOUT.HISTORY_PORTRAIT_HEIGHT)})

history_update(player.history, history_rect)
draw_corner_rect(history_rect.corner + xy(0, history_rect.size.y), xy(history_rect.size.x, 2), #000, ∅, -1)

draw_awards()

draw_leaderboard()

update_intermission_countdown()



leave
────────────────────────────────────────────────────────────────────────
disconnect_from_network()

