/* Generate a stable set of bots with a range of abilities, and 
   produce their scores and word lists for the current `player.board`. 
   
   All players see the same bots doing the same things, but individual
   players might be able to see more of the bots based on what they
   have unlocked.
 */
def insert_bots(competitor_array, target_count, max_bots):
    assert(max_bots > 0)
    assert(size(player.board.word_set) == size(player.board.word_list) and size(player.board.word_list) > 0)
    if DEBUG.BOTS: debug_print("------------------------\ninsert_bots()")
   
    target_count = min(target_count, size(competitor_array) + max_bots)
    
    // Used for determining which players are active
    const hour = utc_time().hour
    const minute = utc_time().minute
    
    // Shift everybody's ability by this amount
    const match_shift = make_random(player.board.seed)(-10%, 0%)
    
    /* If vocabulary is specified, the bot is limited to that vocabulary (except for Moo) */
    def maybe_add_bot_competitor(descriptor):
        assert(descriptor and descriptor.sprite and descriptor.name)

        const bot_rng = make_random(descriptor.name + match_shift)
        const competitor = {
            avatar: {
                // Bots face left
                sprite: evaluate_constant_expression(descriptor.sprite).x_flipped,
                name: descriptor.name,
                bot: true,
                appears_human: descriptor.appears_human default false,
                id: "BOT_" + descriptor.name},
            score: 0,
            evil: descriptor.evil,
            best_wild_word_points: 0,
            best_wild_word_text: "",            
            word_list: [],
            freestyle_word_list: []}
    
        competitor.avatar.color = avatar_compute_color(competitor.avatar.sprite)
        competitor.avatar.level = descriptor.level default clamp(⌈140 descriptor.base_ability^(1.3)⌉, 1, 40)
        
        // Make stable how good this player is overall, and then add noise per game.
        // Apply that as a fraction of all words possible
        const find_percentage = min(28%, bot_rng(3%^⅓, 30%^⅓)³ + descriptor.base_ability)
        const words_found = clamp(⌊size(player.board.word_list) * find_percentage⌋, 5, 55)
        const short_word_preference = descriptor.short_word_preference
        
        // Is this particular competitor available right now?
        if ((descriptor.last_hour > descriptor.first_hour and
            (hour < descriptor.first_hour or hour > descriptor.last_hour)) or
        
            // Wraparound hours case
            (descriptor.last_hour ≤ descriptor.first_hour and
            hour > descriptor.last_hour and hour < descriptor.first_hour)):
                
            if DEBUG.BOTS: debug_print("Bot " + descriptor.name + " is not available now")
            return
        
        if DEBUG.BOTS: debug_print("Bot " + descriptor.name + ":")
        if DEBUG.BOTS: debug_print("  gathering up to " + words_found + " words")

        // Make a word list for this competitor and score it.
        // Higher chance of discovering shorter words via rejection sampling.
        
        const word_set = {}
        
        // Add word and its substrings to word_set if not sensitive
        def maybe_add_word(word):
            assert(word)
            if DEBUG.BOTS: debug_print("  considering " + word)
                        
            // Accept words that this competitor hasn't found with
            // decreasing probability as the word gets longer than 3 letters.
            // Players with higher base percentages also are better at long words.
            if (not word_set[word] 
                and bot_rng() ≤ (2.9 descriptor.base_ability + 23%) / pow(max(size(word) - 2, 1), 0.4 + 3 short_word_preference)):

                // If a word is found, all substrings are found.
                // Ensure that bots do not find sensitive words or
                // words that are not in their dictionary
                if DEBUG.BOTS: debug_print("  found " + word)
                for 3 ≤ len ≤ size(word):
                    const subword = slice(word, 0, len)
                    if player.board.word_set[subword] and not sensitive[lowercase(q_decode(subword))] and dictionary[descriptor.dictionary default "common"][word]:
                        word_set[subword] = 1


        /* Special case AI for the caf bot. `word_set` is the output found words */
        def caf_ai():
            // Randomly choose a fantastic word 10% of the time
            if bot_rng() < 10% or DEBUG.CAF:
                const word = player.board.word_list[random_integer(max(0, size(player.board.word_list) - 6), size(player.board.word_list) - 1, bot_rng)]
                if word: maybe_add_word(word)
                    
            // Look for short cow words. These can't be sensitive and don't have
            // substrings
            for word in BOT.MOO.descriptor.vocabulary:
                if size(word) ≤ 3 and player.board.word_set[word]:
                    word_set[word] = 1
        
            // Find all words with "CAF" as a substring, of any length
            for word in player.board.word_list:
                if contains(word, "CAF"):
                    maybe_add_word(word)
                    
            if size(word_set) == 0 and (bot_rng() < 50%):
                // caf has no words. Try to find another word so that caf doesn't complain too often
                for word in player.board.word_list:
                    if size(word) == 3:
                        // Add this word and exit (return value is ignored)
                        return maybe_add_word(word)
    
        def MzK_ai():       
            for word in player.board.word_list:
                if contains(word, "K") and bot_rng() < 50%:
                    maybe_add_word(word)
                    

        // Special case for bots with a vocabulary, who always find *all* of their words
        for word in (descriptor.vocabulary default []):
            if player.board.word_set[word]:
                word_set[word] = 1
                    
        let tries = 0        
        if descriptor == BOT.CAF.descriptor:
            // Special case for caf, who sometimes finds a great word, finds all
            // three-letter cow words, and with a low probability finds a terrible word
            caf_ai()
        else if descriptor == BOT.MZK.descriptor:
            // Special case for MzK
            MzK_ai()
            
        else if not descriptor.vocabulary or descriptor == BOT.MOO.descriptor:
            // Default AI + Moo's short words
            //
            // Pick up a bunch of cheap words first. For Moo these must be 3 letters.
            // For other bots they can be 3 or 4 letters
            const short_word_length = if descriptor == BOT.MOO.descriptor then 3 else 4
            
            if DEBUG.BOTS: debug_print("  looking for short words")
            while size(word_set) < clamp(2 short_word_preference, 10%, 90%) * words_found and tries < 2 words_found:
                ++tries
                const word = random_value(player.board.word_list, bot_rng)
                if size(word) ≤ short_word_length:
                    maybe_add_word(word)
    
            // Bots without a fixed vocabulary now look for random words
            if not descriptor.vocabulary and descriptor ≠ BOT.CAF.descriptor:
                if DEBUG.BOTS: debug_print("  looking for random words")
                tries = 0
                while size(word_set) < words_found and tries < 2 words_found:
                    ++tries
                    maybe_add_word(random_value(player.board.word_list, bot_rng))

        // Convert the set of words into a word list
        for word in keys(word_set):
            push(competitor.word_list, {word: word, points: score_word(word)})

        for list in [competitor.word_list, competitor.freestyle_word_list]:
            sort(list, "points", true)
            for points in entry in list:
                competitor.score += points

        // Only add bots if they found a word
        if descriptor.allow_zero_score or size(competitor.word_list):
            return push(competitor_array, competitor)
        else if DEBUG.BOT:
            debug_print("  left because they couldn't find words")


    // Moo is a special case
    // ALWAYS insert Moo if the player has the See Moo ability. Otherwise insert Moo if
    // it is an odd 10 minute interval right now. Process Moo after other bots
    // so that players who don't see Moo don't have their other results affected
    if player.has_ability["See Moo"] or (⌊minute / 10⌋ mod 2) or DEBUG.CAF:
        maybe_add_bot_competitor(BOT.MOO.descriptor)
    
        // caf only shows up if Moo is also there
        if (player.has_ability["See caf"] and ((hour + ⌊minute / 7⌋) mod 2 == 0)) or DEBUG.CAF:
            maybe_add_bot_competitor(BOT.CAF.descriptor)


    if (player.has_ability["See VIL"] and _VIL_is_online(utc_time().day, hour, minute)) or DEBUG.VIL:
        // VIL also cheats and always gets extra points. This allows them
        // to be on top of the leaderboard and annoy the player without also winning
        // every award every time (and thus being TOO annoying)
        maybe_add_bot_competitor(BOT.VIL.descriptor).score += 150

    // Boo arrives when at least one of their words is available
    maybe_add_bot_competitor(BOT.BOO.descriptor)
    
    if player.has_ability["See Mz. Kiwi"]:
        maybe_add_bot_competitor(BOT.MZK.descriptor)
    
    // Add random bots based on time of day
    let c = 0
    while size(competitor_array) < target_count and BOT_DESCRIPTOR_ARRAY[c]:
        maybe_add_bot_competitor(BOT_DESCRIPTOR_ARRAY[c])
        ++c
    
    if DEBUG.AURA:
        maybe_add_bot_competitor(BOT.aura_test_bot.descriptor)



def _VIL_is_online(day, hour, minute):
    // Can only see VIL at higher levels and on occasional half hours,
    // with the frequency increasing
    return player.has_ability["See VIL Always"] or (((day + hour) mod 2 == 0) and
        (if player.has_ability["See VIL More Frequently"] then true else
                (⌊(day + hour + minute) / 10⌋ mod
                    (if player.has_ability["See VIL Frequently"] then 3 else 6) == 0)))
        

if DEBUG.VIL:
    debug_print("\nVIL's Schedule:")
    let online = 0
    let total = 0
    for hour < 23:
        for m < 12:
            const minute = 5 m
            ++total
            let text = ""
            if _VIL_is_online(0, hour, minute):
                ++online
                text = "  ON"
            debug_print(format_number((60 hour + minute) * 60, "clock24"), text)
    debug_print("VIL is online " + format_number(online / total, "%") + "\n")



