const caf_avatar = make_bot_avatar(NPC.CAF.descriptor)
const moo_avatar = make_bot_avatar(NPC.MOO.descriptor)
const msp_avatar = make_bot_avatar(NPC.MSP.descriptor)
const vil_avatar = make_bot_avatar(NPC.VIL.descriptor)

const bot_descriptor_array = clone(BOT_DESCRIPTOR_ARRAY)
insert(bot_descriptor_array, 6, NPC.MSP.descriptor)


/* Generate a stable set of bots with a range of abilities, and 
   produce their scores and word lists for the current `match`. 
   
   All players see the same bots doing the same things, but individual
   players might be able to see more of the bots based on what they
   have unlocked.
   
 */
def insert_bots(competitor_array, max_non_npc_bots):
    // Verify that the match has been constructed correctly
    assert(size(board.word_set) == size(board.word_list) and size(board.word_list) > 10)
    assert(board.word_set[board.word_list[0]] and board.word_set[board.word_list[1]] and board.word_set[last_value(board.word_list)])
    assert(contains(board.board_string, board.word_list[0][0]) and contains(board.board_string, board.word_list[1][0]))
    if DEBUG.BOTS: debug_print("------------------------\ninsert_bots()")
    
    // Used for determining which players are active based on the match time.
    // Latch this off of the game start time to make it consistent across
    // all players
    const raw_seconds = prev_global_game_utc_start_time()
    const hour = ⌊raw_seconds / 360⌋ mod 24
    const minute = ⌊raw_seconds / 60⌋ mod 60
    
    // Shift everybody's ability by this amount
    const match_shift = make_random(board.seed)(-10%, 0%)
    
    /* If vocabulary is specified, the bot is limited to that vocabulary 
       (except for Moo).
       Returns the competitor. */
    def maybe_add_bot_competitor(descriptor):
        assert(descriptor and descriptor.sprite and descriptor.name)

        const competitor = {
            …make_competitor(),
            
            avatar: make_bot_avatar(descriptor),  
            
            enemy: descriptor.npc and descriptor.npc.evil,
            
            // NPC properties:
            npc: if not descriptor.npc then {} else {
                importance: descriptor.npc.importance,
                expert_tile: descriptor.npc.expert_tile,
                expert_prompt: descriptor.npc.expert_prompt,
                required_ability: descriptor.npc.required_ability,
                play_sound_args: if descriptor.npc.sound then evaluate_constant_expression(descriptor.npc.sound) else ∅,
            }}
    
        competitor.avatar.color = avatar_compute_color(competitor.avatar.sprite)
        competitor.avatar.level = descriptor.level default clamp(⌈300 descriptor.base_ability^(1.2)⌉, 1, ABILITY_TABLE.Aura.level - 1)
        
        const bot_rng = make_random(descriptor.name + match_shift)

        // Make stable how good this player is overall, and then add noise per game.
        // Apply that as a fraction of all words possible
        const find_percentage = min(30%, bot_rng(12%^⅓, 30%^⅓)³ + descriptor.base_ability)
        const words_found = clamp(⌊size(board.word_list) * find_percentage⌋, 5, 80)
        const short_word_preference = descriptor.short_word_preference
        
        // Is this particular competitor available right now?
        if ((descriptor.last_hour > descriptor.first_hour and
            (hour < descriptor.first_hour or hour > descriptor.last_hour)) or
        
            // Wraparound hours case
            (descriptor.last_hour ≤ descriptor.first_hour and
             hour > descriptor.last_hour and
             hour < descriptor.first_hour)
             
             or
             
             descriptor.minute_mask[⌊minute / 10⌋] ≠ "X"):
                        
            if DEBUG.BOTS: debug_print("Bot " + descriptor.name + " is not available now")
            return
        
        if DEBUG.BOTS: debug_print("Bot " + descriptor.name + ":")
        if DEBUG.BOTS: debug_print("  gathering up to " + words_found + " words")

        // Make a word list for this competitor and score it.
        // Higher chance of discovering shorter words via rejection sampling.
        
        const word_set = {}
        
        // Add word and its substrings to word_set if they are not sensitive
        def maybe_add_word(word, force default false):
            assert(word)
            if DEBUG.BOTS: debug_print("  considering " + word)
                        
            // Accept words that this competitor hasn't found with
            // decreasing probability as the word gets longer than 3 letters.
            // Players with higher base percentages also are better at long words.
            // We check word_set[word] at the start as an optimization; it would be
            //
            // fine to eliminate that as we're accumulating a set
            if (not word_set[word] and
                (force or
                     bot_rng() ≤ (3 descriptor.base_ability + 45%) / pow(max(size(word) - 2, 1), 15% + short_word_preference))):

                // If a word is found, all substrings are found.
                // Ensure that bots do not find sensitive words or
                // words that are not in their dictionary
                if DEBUG.BOTS: debug_print("  found " + word)
                for 3 ≤ len ≤ size(word):
                    const subword = slice(word, 0, len)
                    
                    if (
                        // Haven't already found on some other search branch (performance optimization)
                        not word_set[subword]
                    
                        // Actually a word in the board (performance optimization; we check the dictionary again below)
                        and board.word_set[subword]
                        
                        // Not a BAD word
                        and not sensitive[lowercase(q_decode(subword))]
                        
                        // Is a word in THIS bot's dictionary (vs. the full dictionary)
                        and dictionary[descriptor.dictionary default "common"][subword]):
                            
                        word_set[subword] = 1


        /* Special case AI for the caf bot. `word_set` is the output found words */
        def caf_ai():
            // Randomly choose a fantastic word 10% of the time
            if bot_rng() < 10% or DEBUG.CAF:
                const word = board.word_list[random_integer(max(0, size(board.word_list) - 6), size(board.word_list) - 1, bot_rng)]
                if word: maybe_add_word(word, true)
                    
            // Look for short cow words. These can't be sensitive
            for word in NPC.MOO.descriptor.vocabulary:
                if size(word) ≤ 3 and board.word_set[word]:
                    maybe_add_word(word, true)
        
            // Find all words with "CAF" as a substring, of any length
            for word in board.word_list:
                if contains(word, "CAF"):
                    maybe_add_word(word, true)
                    
            if size(word_set) == 0 and (bot_rng() < 50%):
                // caf has no words. Try to find another word so that caf doesn't complain too often
                for word in board.word_list:
                    if size(word) == 3:
                        // Add this word and exit (return value is ignored)
                        return maybe_add_word(word, true)
    
        def expert_npc_ai():
            for word in board.word_list:
                for tile in competitor.npc.expert_tile:
                    if contains(word, tile) and size(word_set) < words_found:
                        maybe_add_word(word, true)
                    

        // Special case for bots with a vocabulary, who always find *all* of their words
        for word in (descriptor.vocabulary default []):
            if board.word_set[word]:
                maybe_add_word(word, true)
                    
        let tries = 0        
        if descriptor == NPC.CAF.descriptor:
            // Special case for caf, who sometimes finds a great word, finds all
            // three-letter cow words, and with a low probability finds a terrible word
            caf_ai()
            
        else if descriptor.npc and descriptor.npc.expert_tile:

            expert_npc_ai()
            
        else if not descriptor.vocabulary or descriptor == NPC.MOO.descriptor:
            // Default AI + Moo's short words
            //
            // Pick up a bunch of cheap words first. For Moo these must be 3 letters.
            // For other bots they can be 3 or 4 letters
            const short_word_length = if descriptor == NPC.MOO.descriptor then 3 else 4
            
            if DEBUG.BOTS: debug_print("  looking for short words")
            while size(word_set) < clamp(2 short_word_preference, 10%, 90%) * words_found and tries < 2 words_found:
                ++tries
                const word = random_value(board.word_list, bot_rng)
                if size(word) ≤ short_word_length:
                    maybe_add_word(word)
    
            // Bots without a fixed vocabulary now look for random words
            if not descriptor.vocabulary and descriptor ≠ NPC.CAF.descriptor:
                if DEBUG.BOTS: debug_print("  looking for random words")
                tries = 0
                while size(word_set) < words_found and tries < 2 words_found:
                    ++tries
                    maybe_add_word(random_value(board.word_list, bot_rng))

        // Convert the set of words into a word list
        for word in keys(word_set):
            push(competitor.word_list, {word: word, points: score_word(word)})

        for list in [competitor.word_list, competitor.freestyle_word_list]:
            sort(list, "points", true)
            for points in entry in list:
                competitor.score += points

        // Only add bots if they found a word
        if descriptor.allow_zero_score or size(competitor.word_list) or descriptor == NPC.VIL.descriptor:
            return push(competitor_array, competitor)
        else if DEBUG.BOTS:
            debug_print("  left because they couldn't find words")

    
    // Add random bots based on time of day
    let c = 0
    while size(competitor_array) < max_non_npc_bots and bot_descriptor_array[c]:
        maybe_add_bot_competitor(bot_descriptor_array[c])
        ++c
    

    // Moo is a special case
    // ALWAYS insert Moo if the player has the See Moo ability. Otherwise insert Moo if
    // it is an odd 10 minute interval right now. Process Moo after other bots
    // so that players who don't see Moo don't have their other results affected
    if player.has_ability["See Moo"] or (⌊minute / 10⌋ mod 2) or DEBUG.CAF:
        maybe_add_bot_competitor(NPC.MOO.descriptor)
    
        // caf only shows up if Moo is also there
        if (player.has_ability["See caf"] and ((hour + ⌊minute / 7⌋) mod 2 == 0)) or DEBUG.CAF:
            maybe_add_bot_competitor(NPC.CAF.descriptor)

    if (player.has_ability["See VIL"] and _VIL_is_online(utc_time().day, hour, minute)) or DEBUG.VIL:
        maybe_add_bot_competitor(NPC.VIL.descriptor)

    // Boo arrives when at least one of their words is available
    maybe_add_bot_competitor(NPC.BOO.descriptor)
    
    const expert_array = [
        {
            descriptor: NPC.MZK.descriptor,
            ability: "See Mz. Kiwi"},
        
        {
            descriptor: NPC.DRQ.descriptor,
            ability: "See Dr. Quandary"}]
        
    for descriptor, ability in expert in expert_array:
        if player.has_ability[ability]:
            const bot = maybe_add_bot_competitor(descriptor)
            // Cheat their scores down so that they aren't intimidating
            if bot and bot.score > 250:
                bot.score = round(lerp(bot.score, 200, 80%))
        
    if DEBUG.AURA:
        maybe_add_bot_competitor(NPC.aura_test_bot.descriptor)



/* Letter expert NPC's `auto_close_condition()` callback for `set_npc_message()`.

   `args = {tile, hint}`*/
def _hinted_word_found_by_player(args):
    for word in keys(player.already_found):
        if word_to_hint_text(word, args.tile) == args.hint:
            return true
    return false



/* If the npc has a good in-game suggestion, make it with the npc's importance level.
   All npcs can make suggestions and only the best one will win. 
   
   Any bot with an "expert_tile" property will try to suggest from their vocabulary.
   VIL will offer taunts.
*/
def npc_maybe_make_suggestion(bot)
& if bot.npc.expert_tile or (bot.avatar.id == NPC.VIL.ID and ξ < 2%)
& with npc in bot
& if player.has_ability[npc.required_ability]:
    
    /* Returns true if it gives a hint */
    def give_hint(prompt, word, tile, importance):
        const data = {tile: tile, hint: word_to_hint_text(word, tile)}
        
        // The player may have not found the word the bot is suggesting, but MAY have found a different
        // word that matches the hint pattern. In that case, keep looking for a good hint
        if not _hinted_word_found_by_player(data):
            set_npc_message({
                avatar: bot.avatar, 
                text: prompt + data.hint, 
                importance: importance, 
                play_sound_args: npc.play_sound_args, 
                auto_close_condition: _hinted_word_found_by_player, 
                data: data,
                auto_close_play_sound_args: npc.play_sound_args})
            return true
                
    
    // Choose an 4+ tile word, prefering ones that the player
    // has never spelled themselves. This encourages the player to
    // learn and get the shorter words quickly so that the NPC will
    // help them with longer ones
    for j < size(bot.word_list):
        // Working backwards because word lists are sorted from best to worst.
        const word = bot.word_list[size(bot.word_list) - j - 1].word

        if bot.avatar.id == NPC.VIL.ID:
            // VIL taunts. Set low importance so that any other bot can override
            // Choose an insultingly short word the player has not gotten as a hint       
            if not player.already_found[word]:
                return give_hint(random_value(["Require aid? ", "Disgusting. Here: ", "Poor show. Try ", "I pity you. Try ", "Pathetic. Try "]), word, word[0], 0)
           
        else:
            // Letter bot
            const candidate_array = []
        
            // Iterate through all tiles that this npc knows. If multiple ones hit,
            // then they will prefer the earlier ones
            for tile in npc.expert_tile:
            
                // Because a bot must get sub-strings of their expertise words en route to their word,
                // we must check to make sure this word is actually in their expertise. We also
                // prefer words that the player has not themselves seen before, but not exclusively
                if size(word) ≥ 4 and contains(word, tile) and not player.already_found[word]:
                    push(candidate_array, {word: word, tile: tile})
            
            if size(candidate_array):
                // There are multiple candidate words for this tile.
                // Choose randomly among them, preferring slightly via rejection
                // sampling shorter words
                // that aren't in the player's vocabulary.
                const NUM_TRIES = 15
                for i < NUM_TRIES
                & with word, tile in random_value(candidate_array):
                    if not player.vocabulary[word] or ξ < 50% or i == NUM_TRIES - 1:
                        if give_hint(npc.expert_prompt[tile], word, tile, npc.importance): return
                    




def _VIL_is_online(day, hour, minute):
    // Can only see VIL at higher levels and on occasional half hours,
    // with the frequency increasing
    return player.has_ability["See VIL Always"] or (((day + hour) mod 2 == 0) and
        (if player.has_ability["See VIL More Frequently"] then true else
                (⌊(day + hour + minute) / 10⌋ mod
                    (if player.has_ability["See VIL Frequently"] then 3 else 6) == 0)))
        

if DEBUG.VIL:
    debug_print("\nVIL's Schedule:")
    let online = 0
    let total = 0
    for hour < 23:
        for m < 12:
            const minute = 5 m
            ++total
            let text = ""
            if _VIL_is_online(0, hour, minute):
                ++online
                text = "  ON"
            debug_print(format_number((60 hour + minute) * 60, "clock24"), text)
    debug_print("VIL is online " + format_number(online / total, "%") + "\n")



/*
  Shows a high-priority npc notification suggesting the correct spelling
  from Miss Pelican if:
  
  - The player has unlocked Miss Pelican
  - `word` appears to be mispelled according to `spell_check`
  - `word` has at least five letters
  - A Miss Pelican notification has not been visible for at least 15 seconds
  - The game has at least 12 seconds left
  - The notification for this word has not previously been shown in this match
  - The word has been stable (unchanged) for the configured time

 */
def maybe_run_miss_pelican_ai(word):
    const msp_npc = NPC.MSP.descriptor.npc
    
    // Check all trivial rejection conditions
    if (in_waiting_room or 
        not word or 
        contains(word, WILDCARD_CHARACTER) or
        not player.has_ability["Meet Miss Pelican"] or
        size(word) < 5 or
        
        // Cooldown since last shown
        game_frames - player.miss_pelican.last_shown_frame < msp_npc.cooldown_time * 60 or
        
        // Time left in match
        end_time - frame_utc_now < msp_npc.min_time_left or
        
        // Haven't shown this match before
        player.miss_pelican.shown_this_match[word] or
        
        // Don't show message until word has been stable
        game_frames - player.miss_pelican.current_word_frame < msp_npc.word_stability_time * 60): 
        return
    
    // Track when this word was first seen
    if player.miss_pelican.current_word ≠ word:
        player.miss_pelican.current_word = word
        player.miss_pelican.current_word_frame = game_frames
        return
    
    // Prevent checking this word again
    player.miss_pelican.shown_this_match[word] = true

    // Filter and highlight suggestions in one pass
    def process_suggestion(suggestion):
        // Check if invalid
        const lower = lowercase(q_decode(suggestion))
        if size(suggestion) < 5 or player.already_found[suggestion] or offensive[lower] or sensitive[lower]:
            return iterate.REMOVE
        
        // Highlight the part that differs from the original word
        let prefix_len = 0
        while (prefix_len < size(word) and 
               prefix_len < size(suggestion) and
               word[prefix_len] == suggestion[prefix_len]):
            ++prefix_len
        
        let suffix_len = 0
        while (suffix_len < size(word) - prefix_len and
               suffix_len < size(suggestion) - prefix_len and
               word[size(word) - 1 - suffix_len] == suggestion[size(suggestion) - 1 - suffix_len]):
            ++suffix_len
        
        const middle_end = size(suggestion) - suffix_len
        
        return (slice(suggestion, 0, prefix_len) + 
                "{color:#000 " + slice(suggestion, prefix_len, middle_end) + "}" +
                slice(suggestion, middle_end))
    
    // Process all suggestions and take first few
    const suggestions = slice(iterated(spell_check(word) default [], process_suggestion), 0, 4)
    if size(suggestions) == 0: return
        
    def close_callback():
        player.miss_pelican.last_shown_frame = game_frames
    
    // Auto-close if player completes any word
    def auto_close_condition(initial_word_count):
        return size(player.history.list) + size(player.history.free) > initial_word_count

    // Build suggestion text with a few words
    set_npc_message({
        avatar: msp_avatar,
        text: "You may be thinking of " + join(suggestions, ", ", " or "),
        importance: msp_npc.importance,
        play_sound_args: evaluate_constant_expression(NPC.MSP.descriptor.npc.sound),
        auto_close_condition: auto_close_condition,
        data: size(player.history.list) + size(player.history.free),
        auto_close_play_sound_args: evaluate_constant_expression(NPC.MSP.descriptor.npc.sound),
        close_callback: close_callback})
    


