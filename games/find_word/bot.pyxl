
/* Generate a stable set of bots with a range of abilities, and 
   produce their scores and word lists for the current `player.board`. */
def insert_bots(competitor_array, target_count, max_bots):
    assert(max_bots > 0)
   
    // Make results for the board stable so that all human players see the
    // bots doing the same things
    const match_rng = make_random(player.board.seed)
    target_count = min(target_count, size(competitor_array) + max_bots)
    
    // Used for determining which players are active
    const hour = utc_time().hour
    const minute = utc_time().minute
    
    // Shift everybody's ability by this amount
    const match_shift = match_rng(-10%, 0%)
    
    def maybe_add_bot_competitor(descriptor, id):
        assert(descriptor and descriptor.sprite and descriptor.name)
        
        const competitor = {
            avatar: {
                // Bots face left
                sprite: evaluate_constant_expression(descriptor.sprite).x_flipped,
                name: descriptor.name,
                bot: true,
                id: id},
            score: 0,
            free_list: []}
    
        competitor.avatar.color = avatar_compute_color(competitor.avatar.sprite)
        competitor.avatar.level = descriptor.level default clamp(⌈140 descriptor.base_ability^(1.3)⌉, 1, 40)
        
        // Make stable how good this player is overall, and then add noise per game.
        // Apply that as a fraction of all words possible
        const base_ability = descriptor.base_ability
        const find_percentage = min(28%, match_rng(3%^⅓, 30%^⅓)³ + base_ability)
        const words_found = clamp(⌊size(player.board.word_list) * find_percentage⌋, 5, 55)
        const short_word_preference = descriptor.short_word_preference
        
        // Is this particular competitor available right now?
        if descriptor.last_hour > descriptor.first_hour:
            if hour < descriptor.first_hour or hour > descriptor.last_hour: 
                return
        else if hour > descriptor.last_hour and hour < descriptor.first_hour:
            // Wraparound hours case
            return
        
        // Make a word list for this competitor and score it.
        // Higher chance of discovering shorter words via rejection sampling.
        
        const word_set = {}
        def maybe_add_word(word):
            assert(word)
            // Accept words that this competitor hasn't found with
            // decreasing probability as the word gets longer than 3 letters.
            // Players with higher base percentages also are better at long words.
            if (not sensitive[lowercase(word)] and
                not word_set[word] and
                match_rng() ≤ (2.8 base_ability + 23%) / pow(max(size(word) - 2, 1), 0.4 + 3 short_word_preference)):
                // Ensure that if a word is found, all substrings are found
                for 3 ≤ s ≤ size(word):
                    const w = slice(word, 0, s)
                    if player.board.word_set[w]:
                        word_set[w] = 1
        
        // Special case for Moo, who always finds *all* cow-related words
        if id == MOO_ID:
            for word in MOOCABULARY:
                if not word_set[word] and contains(player.board.word_list, word):
                    word_set[word] = 1
                    
        let tries = 0        
        // Special case for caf, who sometimes finds a great word, finds all
        // three-letter cow words, and with a low probability finds a terrible word
        if id == CAF_ID:
            caf_ai(word_set, player.board.word_list, match_rng)
        else:
            // Pick up a bunch of cheap words first
            const short_word_length = if id == MOO_ID then 3 else 4
            while size(word_set) < clamp(2 short_word_preference, 10%, 90%) * words_found and tries < 2 words_found:
                ++tries
                const word = random_value(player.board.word_list, match_rng)
                if size(word) ≤ short_word_length:
                    maybe_add_word(word)
    
        // Moo cannot find non-cow words greater than 4 letters    
        if id ≠ MOO_ID and id ≠ CAF_ID:
            tries = 0
            while size(word_set) < words_found and tries < 2 words_found:
                ++tries
                maybe_add_word(random_value(player.board.word_list, match_rng))
    
        competitor.word_list = keys(word_set)
                
        sort(competitor.word_list, size_comparator, true)
        sort(competitor.free_list, size_comparator, true)
        
        for word at i in competitor.word_list:
            competitor.score += score_word(word)

        return push(competitor_array, competitor)
    
    // Moo is a special case
    // ALWAYS insert Moo if the player has the See Moo ability, otherwise insert Moo if
    // it is an odd 10 minute interval right now. Process Moo after other bots
    // so that players who don't see Moo don't have their other results affected
    if player.has_ability["See Moo"] or (⌊minute / 10⌋ mod 2):
        maybe_add_bot_competitor({
                name: "Moo",
                sprite: "avatar_sprite[34][22]",
                base_ability: 0.1,
                short_word_preference: 0.80,
                first_hour: 0,
                last_hour: 22},
            MOO_ID)
    
    // Process caf *after* Moo. Everyone who can see caf can also see Moo, so
    // this keeps it deterministic
    if (player.has_ability["See caf"] and ((hour + ⌊minute / 7⌋) mod 2 == 0)) or DEBUG.CAF:
        maybe_add_bot_competitor({
                name: "caf",
                sprite: "avatar_sprite[33][22]",
                base_ability: 0.0,
                short_word_preference: 0.80,
                first_hour: 0,
                last_hour: 23, 
                level: 1},
            CAF_ID)

    if (player.has_ability["See VIL"] and _VIL_is_online(utc_time().day, hour, minute)) or DEBUG.VIL:
        // VIL also cheats and always gets extra points. This allows them
        // to be on top of the leaderboard and annoy the player without also winning
        // every award (and thus being TOO annoying)
        maybe_add_bot_competitor({
                name: "VIL",
                sprite: "avatar_sprite[25][20]",
                base_ability: 40%,
                short_word_preference: 5%,
                first_hour: 0,
                last_hour: 23,
                level: 41},
            VIL_ID).score += 125

    let c = 0
    while size(competitor_array) < target_count and BOT_DESCRIPTOR_ARRAY[c]:
        maybe_add_bot_competitor(BOT_DESCRIPTOR_ARRAY[c], "BOT_" + c)
        ++c


def _VIL_is_online(day, hour, minute):
    // Can only see VIL at higher levels and on occasional half hours.
    return (((day + hour) mod 2 == 0) and
            (⌊(day + hour + minute) / 10⌋ mod 
                (if player.has_ability["See VIL Frequently"] then 3 else 6) == 0))
        
if DEBUG.VIL:
    debug_print("\nVIL's Schedule:")
    let online = 0
    let total = 0
    for hour < 23:
        for m < 12:
            const minute = 5 m
            ++total
            let text = ""
            if _VIL_is_online(0, hour, minute):
                ++online
                text = "  ON"
            debug_print(format_number((60 hour + minute) * 60, "clock24"), text)
    debug_print("VIL is online " + format_number(online / total, "%") + "\n")


/* Special case AI for the caf bot. `word_list` is the input,
   `word_set` is the output found words */
def caf_ai(word_set, word_list, rng):
    if rng() < 10% or DEBUG.CAF:     
        const word = word_list[random_integer(max(0, size(word_list) - 6), size(word_list) - 1, rng)]
        if word:
            // Find this word
            word_set[word] = 1
            
    // Look for short cow words
    for word in MOOCABULARY:
        if size(word) ≤ 3 and contains(word_list, word):
            word_set[word] = 1

    // Find all words with "CAF" as a substring
    for word in player.board.word_list:
        if contains(word, "CAF"):
            word_set[word] = 1
            
    if rng() < 50% and size(word_set) == 0 and size(word_list):
        // Try to find another word so that caf doesn't complain too often
        word_set[word_list[0]] = 1
