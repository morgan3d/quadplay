GlobalIntermission
════════════════════════════════════════════════════════════════════════

todo("Separate leveling from postgame")

todo("Favoriting UI + save")
todo("Send emotes?!")


let prev_xp
let prev_level
let new_xp

/* Used to prevent multiple VIL effects per intermission */
let played_vil_sound = false

/* Cycle through the award stages. See `STAGE` */
let stage

/* Stage from the previous frame, used for detecting stage
   changes to play sounds */
let prev_stage

let first_frame_this_stage

let selection_index = 0

const STATS_BUTTON_INDEX = 1

let leaderboard_scroll

// For notifications
let bonus


/* Draw and animate Awards (Summary, Longest, Best Word, Best rare, High Score, Most Words) */
def draw_awards()
& preserving_transform:
    set_transform(
        if landscape() then xy(SCREEN_SIZE.x - GLOBAL_LAYOUT.LEADERBOARD.WIDTH, 0)
        else xy(0, GLOBAL_LAYOUT.HISTORY_PORTRAIT_HEIGHT + 2))
    
    if stage ≠ prev_stage and mode_frames > 10:
        play_sound({sound: word_sound, pan: xy(0, 0)})

    if stage == STAGE.SUMMARY:
        draw_award_summary()
   
    else if stage == STAGE.BEST_WORD:
        draw_word_award("Best Word", best_word_winner)
   
    else if stage == STAGE.LONGEST:
        draw_word_award("Longest", longest_winner)
        
    else if stage == STAGE.BEST_RARE:
        draw_word_award("Best Rare", best_rare_winner)
    
    else if stage == STAGE.MOST_WORDS:
        draw_most_words_award(most_words_winner)



/* Called from `draw_awards()` when `stage` == `STAGE.SUMMARY` */
def draw_award_summary()
& preserving_transform:
    board_deselect_all(player.board, player)    
    draw_corner_rect(xy(0, 0), xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH, GLOBAL_LAYOUT.AWARD_HEIGHT), player.avatar.color)
        
    const highlight_color = HIGHLIGHT_COLOR    

    const frames = mode_frames - first_frame_this_stage
    const flash = (⌊frames / 15⌋ mod 2) and (player.score > 0)
    const XP_ANIMATION_DELAY_FRAMES = 150
    if frames == XP_ANIMATION_DELAY_FRAMES + 10 and player.score > 0:
        play_sound({sound: xp_sound, pan: 90%, pitch: 70%})
        
    if frames < XP_ANIMATION_DELAY_FRAMES + 10 and (frames mod 30 == 0):
        play_sound({sound: word_sound, pan: 100%, pitch: 150%})
    
    const XP_ANIMATION_RATE = 1 / 120
    
    // *Currently shown* XP and level, interpolated for animation
    const τ = clamp((frames - XP_ANIMATION_DELAY_FRAMES) * XP_ANIMATION_RATE, 0%, 100%)
    const xp = round(lerp(prev_xp, new_xp, τ))
    const level = xp_to_level(xp)
    const xp_lo = level_to_xp(level)
    const xp_hi = level_to_xp(level + 1)
    
    if frames > 1 and (draw_award_summary.last_level_displayed ≠ level):
        // Level up
        play_sound(level_up_sound)
        
        // Give the abilities after the sound has finished
        delay(grant_new_abilities, 30)        
        delay(notify_badge_bonus, 30)
        delay(notify_word_bonus, 30) 
    
    draw_award_summary.last_level_displayed = level
    
    const shadow = 70% player.avatar.color

    // Flash and turn pink on level up
    draw_text({
        color:   if level ≠ prev_level and flash then highlight_color else #FFF,
        shadow:  shadow,
        outline: if level ≠ prev_level and flash then #FFF else ∅,
        font:    history_font,
        text:    "Level " + level,
        pos:     xy(21, 9)})
        
    avatar_draw_large(player.avatar, xy(21, 30), false, #FFF, shadow)

    const args = {
        font: history_font,
        x_align: "left",
        y_align: "baseline",
        shadow: shadow,
        color: #FFF}

    // Score
    draw_text({ …args, text: format_number(player.score, "commas") + " {font:leaderboard_font pts}", font: score_font, pos: xy(28, 2) + xy(105, 12), x_align: "right", markup: true})

    draw_text({…args, text: "Rare Words", pos: xy(49, 26)})
    draw_text({…args, text: player_competitor.num_rare, pos: xy(135, 26), x_align: "right"})

    // draw_text({…args, text: "Longest", pos: xy(x, 24)})
    // draw_text({…args, text: player_competitor.longest_text, font: history_font, pos: xy(30, 24), x_align: "right"})

    const xp_color   = if frames < XP_ANIMATION_DELAY_FRAMES and flash then highlight_color else #FFF
    const xp_outline = if frames < XP_ANIMATION_DELAY_FRAMES and flash then #FFF else ∅
    draw_text({…args, text: "XP Earned",              pos: xy(49,  46), color: xp_color, outline: xp_outline})
    draw_text({…args, text: "+" + (new_xp - prev_xp), pos: xy(135, 46), color: xp_color, outline: xp_outline, x_align: "right"})

    // XP bar outline
    const xp_rect = {corner: xy(49, 52), size: xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH + 56 - 108, 10)}
    draw_corner_rect(xp_rect.corner + xy(0, 1), xp_rect.size, ∅, shadow)

    // Progress bar
    const α = clamp((xp - xp_lo) / (xp_hi - xp_lo), 0%, 100%)
    draw_corner_rect(
        xp_rect.corner + 1,
        xy(α * (xp_rect.size.x - 2), xp_rect.size.y - 2), 
        if frames < XP_ANIMATION_DELAY_FRAMES and not flash then #000 else HIGHLIGHT_COLOR)
    
    draw_text({…args, shadow: #0008, font: history_font, text: format_number(xp, "commas") + " XP", x_align: "right", pos: xp_rect.corner + ½ xp_rect.size + xy(17, 2)})
    draw_corner_rect(xp_rect.corner, xp_rect.size, ∅, #FFF)
    
    board_draw_mini(player.board, xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH - 27, 26))
    


/* Special sounds for player, Moo, VIL, and caf */
def maybe_play_award_sound(winner):
    if stage == prev_stage: return

    if winner.avatar.id == player_competitor.avatar.id:
        play_sound(award_sound)
    else if winner.avatar.id == MOO_ID:
        play_sound(moo_00_sound)
    else if winner.avatar.id == CAF_ID:
        play_sound({sound: moo_01_sound, playback_rate: 200%})
    else if winner.avatar.id == VIL_ID and not played_vil_sound:
        played_vil_sound = true
        play_sound({sound: vil_00_sound, time: random(0, 1), pitch: random(80%, 120%)})




/* Used for best_word, longest, The title is used to compute the field */
def draw_word_award(title, winner)
& preserving_transform:
    maybe_play_award_sound(winner)
        
    const field = replace(lowercase(title), {" ": "_"})
    const text = winner[field + "_text"]
    if not text: return
        
    draw_award_background({corner: xy(0, 12), size: xy(69, 37)}, field, winner.avatar.color)

    draw_text({font: history_font, text: title + "!", color: player.board.selection_color, shadow: #000, pos: xy(35, 7), z: 2})
    draw_text({font: history_font, text: "→", color: player.board.selection_color, shadow: #000, pos: xy(75, 7), z: 2})
    
    avatar_draw_large(winner.avatar, xy(35, 31), false, ∅, ∅, true)
    
    if winner == player_competitor or not offensive[lowercase(text)]:
        board_select_word(player.board, text)
        board_draw_mini(player.board, xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH - 33, 38))



def draw_award_background(rect, field, color)
& preserving_transform:
    
    let badge_background = BADGE_TABLE[field]
    for i < 4:
        badge_background += badge_background
    for i < 3:
        badge_background += "\n" + badge_background
    
    const badge_color = 90% color
    set_clip(transform_cs_to_ss(rect.corner), rect.size)
    draw_text({font: leaderboard_font, color: badge_color, text: badge_background, pos: xy(0, -2), y_align: "top", x_align: "left"})



def draw_most_words_award(winner):
    maybe_play_award_sound(winner)
    ++draw_most_words_award.frames
    player.board.selection_color = HIGHLIGHT_COLOR

    
    draw_text({font: history_font, text: "Most Words: " + size(winner.word_list), color: player.board.selection_color, shadow: #000, pos: xy(35, 7), z: 2})
    draw_award_background({corner: xy(0, 12), size: xy(69, 37)}, "most_words", winner.avatar.color)
    avatar_draw_large(winner.avatar, xy(35, 31), false, player.board.selection_color, ∅, true)

    let word
    // Find a non-offensive word, but give up after four tries instead of locking up
    for i < 4:
        word = array_value(winner.word_list, (draw_most_words_award.frames / MOST_WORDS_AWARD_FRAMES_PER_WORD) + draw_most_words_award.skip, "loop")
        if winner ≠ player_competitor and offensive[lowercase(q_decode(word))]:
            // Skip over this word
            ++draw_most_words_award.skip
            
    if winner == player_competitor or not offensive[lowercase(q_decode(word))]:
        board_select_word(player.board, word)
        board_draw_mini(player.board, xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH - 33, 38))



/* Draw the ranked competitors and perform UI logic */
def draw_leaderboard()
& preserving_transform:
    
    const leaderboard_header_height = 14
    
    // Dimension of the scroll rectangle on the screen
    const leaderboard_corner = (
        if landscape() then xy(SCREEN_SIZE.x - GLOBAL_LAYOUT.LEADERBOARD.WIDTH, GLOBAL_LAYOUT.AWARD_HEIGHT)
        else xy(0, GLOBAL_LAYOUT.HISTORY_PORTRAIT_HEIGHT + GLOBAL_LAYOUT.AWARD_HEIGHT + 2)) + xy(0, leaderboard_header_height)

    const leaderboard_size = SCREEN_SIZE - leaderboard_corner - xy(0, 22)
    
    set_transform(leaderboard_corner - xy(0, leaderboard_header_height))

    // Line at top of leaderboard against the awards
    draw_corner_rect(xy(0, 0), xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH, 2), #000, ∅, 20)
    
    // Header    
    draw_text({text: "Player", pos: xy(GLOBAL_LAYOUT.LEADERBOARD.AVATAR_X - 6, 7), x_align: "left", font: leaderboard_font, color: HIGHLIGHT_COLOR, shadow: #000})
    draw_text({text: "Lvl", pos: xy(GLOBAL_LAYOUT.LEADERBOARD.LEVEL_X, 7), x_align: "right", font: leaderboard_font, color: HIGHLIGHT_COLOR, shadow: #000})
    draw_text({text: "Award", pos: xy(GLOBAL_LAYOUT.LEADERBOARD.BADGE_X - 6, 7), x_align: "left", font: leaderboard_font, color: HIGHLIGHT_COLOR, shadow: #000})
    draw_text({text: "Score", pos: xy(GLOBAL_LAYOUT.LEADERBOARD.SCORE_X, 7), x_align: "right", font: leaderboard_font, color: HIGHLIGHT_COLOR, shadow: #000})
    draw_text({text: "#", pos: xy(GLOBAL_LAYOUT.LEADERBOARD.COUNT_X, 7), x_align: "right", font: leaderboard_font, color: HIGHLIGHT_COLOR, shadow: #000})
    draw_text({text: "Best Word", pos: xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH - 2, 7), x_align: "right", font: leaderboard_font, color: HIGHLIGHT_COLOR, shadow: #000})

    // Content    
    scroll_tracker_update(
        leaderboard_scroll,
        xy(0, size(competitor_array) * GLOBAL_LAYOUT.LEADERBOARD.ROW_SPACING + 2),
        {corner: leaderboard_corner, size: leaderboard_size})
        
    set_clip(leaderboard_corner, leaderboard_size)
    set_transform(leaderboard_corner - leaderboard_scroll.offset)
    // Alternating animation frames for avatar idle animations
    const alt = ⌊mode_frames / 30⌋ mod 2
    const show_free_word = ⌊mode_frames / (60*4.5)⌋ mod 2
    
    for competitor at i in competitor_array:
        // Center of avatar
        const pos = xy(0, i * GLOBAL_LAYOUT.LEADERBOARD.ROW_SPACING + 9)
                
        const me = (competitor == player_competitor)
        
        const friend = competitor_is_friend(competitor)
        
        // Highlight
        const highlight_color = if friend then lerp(competitor.avatar.color, #333, 75%) else (if me then competitor.avatar.color else ∅)
        draw_corner_rect(pos - xy(0, 9), xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH, 18), highlight_color, ∅, ∅, -1)

        const text_args = {
            font: leaderboard_font,
            shadow: if me then 60% competitor.avatar.color else ∅,
            x_align: "left",
            color: if me or friend then #FFF else #999}
        
        if friend:
            draw_text({…text_args,
                pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.AVATAR_X - 14, 0),
                text: "♥"})
                
        draw_sprite(idle_animate_avatar(competitor.avatar.sprite.x_flipped, alt), pos + xy(GLOBAL_LAYOUT.LEADERBOARD.AVATAR_X, 0))
        
        draw_text({…text_args,
            text: competitor.avatar.level,
            font: history_font,
            x_align: "right",
            pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.LEVEL_X, 1),
            color: if me then #FFF else competitor.avatar.color})
            
        draw_text({…text_args,
            text: competitor.avatar.name,
            pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.NAME_X, 0),
            color: if me then #FFF else competitor.avatar.color})
        
        const free_word = show_free_word and size(competitor.free_list)

        // Hide badges when showing the free word, which is long
        const badges = if free_word then "" else competitor.badges
        if size(badges) > 2:
            draw_text({…text_args,
                text: slice(competitor.badges, 0, 2),
                pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1 - 4)})
            draw_text({…text_args,
                text: slice(competitor.badges, 2),
                pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1 + 4)})
                
        else if size(badges) > 0:
            draw_text({…text_args,
                text: competitor.badges,
                pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.BADGE_X, 0 alt - 1)})
            
        draw_text({…text_args, text: format_number(competitor.score, "commas"), pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.SCORE_X, 0), x_align: "right"})

        draw_text({…text_args, text: size(competitor.word_list), pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.COUNT_X, 0), x_align: "right"})

        // Force unknown to string, decode
        let text = q_decode((if free_word then competitor.free_list[0] else competitor.word_list[0]) default "∅")

        if competitor ≠ player_competitor: 
            text = censor(text)
            
        draw_text({
            …text_args, 
            font: history_font, 
            text: if free_word then "«" + text + "»" else text, 
            x_align: "right", 
            pos: pos + xy(GLOBAL_LAYOUT.LEADERBOARD.WIDTH - 2, 0)})



def update_countdown():
    const time_left = max(end_time - frame_utc_now, 0)
    const timer_pos = xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 10)
    const α = clamp(100% - time_left / (if game_type == SOLO then SOLO_INTERMISSION_TIME else GLOBAL_INTERMISSION_TIME), 0%, 100%)
    
    const countdown_rect = {
        corner: xy(32, timer_pos.y - 10),
        size: xy(SCREEN_SIZE.x - 64, 20)}
        
    draw_corner_rect(countdown_rect.corner, countdown_rect.size, #000, #FFF)
    draw_corner_rect(countdown_rect.corner + 1, xy(α * (countdown_rect.size.x - 2), countdown_rect.size.y - 2), #0F0)
    
    draw_text({
        font: score_font,
        text: "Next match in " + format_number(time_left, "timer"),
        outline: #090,
        pos: timer_pos + xy(0, 1),
        color: #FFF})
    
    if frame_utc_now ≥ end_time and not DEBUG.INTERMISSION:
        set_mode(GenerateBoard) because "Timer"
    
    
    
def notify_badge_bonus()
& if bonus.badge_xp > 0:
    
    const title_array = []
    for badge in player_competitor.badges:
        // Convert the badge back into a title
        let title = replace(find(BADGE_TABLE, badge), "_", " ")
        if not contains(title, "word"):
            title += " word"
        
        push(title_array, uppercase(title))

    notify_xp_bonus(
        bonus.badge_xp,
        "winning " + join(title_array, ", ", ", and ", " and ") + " in a " + size(competitor_array) + "-player match!")



def notify_word_bonus()
& if bonus.word_xp > 0:
    assert(bonus.unique_word_list ≠ ∅)
    
    let decoded = []
    for word in bonus.unique_word_list:
        push(decoded, q_decode(word))
    
    let text
    if size(bonus.unique_word_list) ≤ 7:
        text = join(decoded, ", ", ", and ", " and ")
    else:
        text = "" + size(bonus.unique_word_list) + " words including " + join(slice(decoded, 0, 6), ", ", ", and ")

    notify_xp_bonus(
        bonus.word_xp,
        "discovering " + text + "!")        



pop_mode from DisplayStats
────────────────────────────────────────────────────────────────────────
selection_index = 0



enter
────────────────────────────────────────────────────────────────────────
set_background(#333)
selection_index = 0

leaderboard_scroll = make_scroll_tracker()

prev_xp = player.stats.lifetime.xp + player.stats[today_date_string()].xp
prev_level = player.avatar.level

played_vil_sound = false
bonus = stats_update(player.stats, player_competitor, size(competitor_array), joined_late)


// Avoid recomputing every frame during the XP animation
new_xp = player.stats.lifetime.xp + player.stats[today_date_string()].xp

// Update the net vocabulary. Vocabulary was originally computed on load of stats
// so is not updated by stats_update
for word in bonus.unique_word_list:
    player.vocabulary[word] = 1

// Update level based on the new total XP, as this is part of the 
// avatar computed at load and not part of the stats
player.avatar.level = xp_to_level(new_xp)

// Save the updated stats (we'll save again at the end of the intermission).
// Unlocked abilities are stored as part of the ability notification process.
if true or not DEBUG.INTERMISSION:
    stats_save(player.stats)
    

if  prev_level == player.avatar.level:
    // See if caf has any commentary. Don't bother players who are leveling up
    // with this.
    for competitor in competitor_array:
        if competitor.avatar.id == CAF_ID and competitor.score == 0:
            notify(competitor.avatar.sprite, "caf", "`too hard!!!!!'", play_sound, {sound: moo_03_sound, pitch: 150%})

    // Note: If the level changed, these notifications move to after leveling up
    notify_badge_bonus()
    notify_word_bonus()

// Used to animate which word is being shown
draw_most_words_award.frames = 0

// Used to skip over offensive words
draw_most_words_award.skip = 0

end_time = next_global_game_utc_start_time()

if player.avatar.level ≠ prev_level:
    // Leveling up, start on the summary/level up display
    stage = STAGE.SUMMARY
else:
    stage = 0


prev_stage = stage
first_frame_this_stage = 0



frame
────────────────────────────────────────────────────────────────────────

if not notifications_pending():
    // Cycle through awards, giving equal time to each. Don't advance
    // while notifications are appearing
    prev_stage = stage
    stage = min(⌊size(STAGE) * mode_frames / (60 GLOBAL_INTERMISSION_TIME)⌋, size(STAGE) - 1)

    if player.avatar.level ≠ prev_level:
        // Leveling up, so cycle around the order to put the summary stage first
        stage = (stage + STAGE.SUMMARY) mod size(STAGE)
        
    if stage == STAGE.MOST_WORDS2 or stage == STAGE.SUMMARY2:
        // These are 2x as long
        --stage
        
    if prev_stage ≠ stage:
        first_frame_this_stage = mode_frames


// Separator bars
if landscape():
    // Vertical separator
    draw_corner_rect(xy(SCREEN_SIZE.x - GLOBAL_LAYOUT.LEADERBOARD.WIDTH - 2, 0), xy(2, SCREEN_SIZE.y), #000, ∅, -1)

const history_rect = (
    if landscape() then {corner: xy(0, 0), size: xy(SCREEN_SIZE.x - GLOBAL_LAYOUT.LEADERBOARD.WIDTH - 2, SCREEN_SIZE.y - 22)}
    else {corner: xy(0, 0), size: xy(SCREEN_SIZE.x, GLOBAL_LAYOUT.HISTORY_PORTRAIT_HEIGHT)})
history_update(player.history, history_rect)
draw_corner_rect(history_rect.corner + xy(0, history_rect.size.y), xy(history_rect.size.x, 2), #000, ∅, -1)

draw_awards()

draw_leaderboard()

// Bottom bar
draw_corner_rect(xy(0, SCREEN_SIZE.y - 22), xy(SCREEN_SIZE.x, 2), #000, ∅, -1)

// Stats button
if player.has_ability["Stats Tracker"]:
    const region = {pos: xy(16, SCREEN_SIZE.y - 10), size: 10 * xy(2, 2), shape: "disk"}
    if touch.hover:
        selection_index = if overlaps(touch.hover, region) then STATS_BUTTON_INDEX else 0
    else if player.using_gamepad:
        selection_index = 0
        draw_text({font: leaderboard_font, pos: region.pos + xy(-12, 4), text: joy.prompt["(q)"], color: #DDD, outline: #000, z: 10})
            
    draw_stats_button(region.pos, selection_index == STATS_BUTTON_INDEX, ½ region.size.x)
    
    if (touch.pressed_a and overlaps(touch.xy, region)) or joy.pressed_q:
        push_mode(DisplayStats) because "Button"

// Countdown
update_countdown()



leave
────────────────────────────────────────────────────────────────────────
disconnect_from_network()


