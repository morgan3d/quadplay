Title
════════════════════════════════════════════════════════════════════════
const INTRO_DURATION = TITLE.INTRO.PRE_FRAMES + TITLE.INTRO.BEAT_FRAMES * TITLE.INTRO.NUM_BEATS

/* Hook for the intro sequence. If ∅ the intro is over */
let intro = ∅

/* If non-zero, show a different title screen */
let easter_egg = 0

const cursor = make_cursor(∅, ∅, false, select_tile_sound)


def go_to_stats():
    push_mode(DisplayStats, update_stats_done_button) because "Button"



def go_to_avatar():
    push_mode(AvatarEditor) because "Selected avatar"



def update_stats_button(pos):
    const region = {pos: pos, shape: "disk", size: 20 * xy(2, 2)}
    const selected = cursor_register_target(cursor, region, if intro then ∅ else go_to_stats)
    draw_stats_button(pos, selected, ½ region.size.x)


    
def start_match(type):
    game_type = type
    play_sound(blip_sound)
    set_mode(GenerateBoard) because "Chose game type"

    
    
def update_button(pos, text, type):
    const rect = {pos: pos, size: xy(132, 24)}
    
    const selected = cursor_register_target(cursor, rect, if intro then ∅ else start_match, type)
        
    // Drop shadow
    draw_rect(pos + xy(0, if selected then 4 else 2), rect.size + (if selected then 6 else 0), #0004, ∅, ∅, 100)
    if selected:
        // Highlight
        for 1 ≤ i < 4: 
            draw_rect(pos, rect.size + 2 i, ∅, rgba(lerp(#FFF, CURSOR_COLOR, (i + 1) / 4), 50%), ∅, 100)
        
    // Background
    draw_rect(pos, rect.size, if selected then CURSOR_COLOR else #FFFD, if selected then #FFF else #666, ∅, 100)
    
    draw_text({
        text: text, 
        font: score_font,
        pos: pos + xy(0, 1),
        color: if selected then #FFF else #000,
        outline: if selected then #090 else ∅,
        z: 101})
            


def bounce_row(y, sound default select_tile_sound, color default TILE.CENTER_SELECTED_COLOR):
    play_sound(sound)
    player_deselect_all(player)
    player.selection_color = color
    for x < 4:
        push(player.selection, xy(x, y))
        player.tile[x][y].selected = mode_frames



def highlight_random_row():
    bounce_row(
        random_integer(0, ROWS - 1), 
        if easter_egg == 3 then vil_00_sound else
        (if easter_egg then moo_00_sound else word_sound),
        HIGHLIGHT_COLOR)


    
def ease_out(f):
    return sign(f) * |f|^1.3
    
    

/* Jump to the end of the intro */
def end_intro():
    highlight_random_row()
    remove_frame_hook(intro)
    intro = ∅


def update_stats_done_button():
    const rect = {pos: xy(½ SCREEN_SIZE.x, SCREEN_SIZE.y - 15), size: xy(150, 21)}
    
    for 1 ≤ i < 4: 
        draw_rect(rect.pos, rect.size + 2i, ∅, rgba(lerp(#FFF, CURSOR_COLOR, (i + 1) / 4), 50%), ∅, 100)
            
    draw_rect(rect.pos, rect.size, CURSOR_COLOR, #FFF)
    draw_text({
        font: score_font,
        text: "Done",
        pos: rect.pos + xy(0, 1),
        outline: #000,
        color: #FFF})
        
    if (gamepad_array[0].pressed_a or gamepad_array[0].pressed_b or (touch.pressed_a and overlaps(touch.xy, rect))) and mode_frames > 2:
        pop_mode()


enter
────────────────────────────────────────────────────────────────────────

set_background(#000)
set_hooks()

easter_egg = (
    if DEBUG.VIL or (player.avatar.level > ABILITY_TABLE["See VIL Always"].level and ξ < 4%) then 3 else
    (if player.avatar.level > 20 and ξ < 8% then 2 else 
    (if player.avatar.level > 15 and ξ < 10% then 1 else 0)))

if not easter_egg and player.stats.lifetime.xp > 2000 and ξ < 1.5%:
    notify(shapes.gear, "Please Backup", "FWAN is in beta and could crash!\n\nUse the gear button to export a save game as a backup.")

// Initialize the fake board
player_reset_match(player, SOLO_GAME, ["FIND WORD ALLL NITE", "FIND COWS ALLL NITE", "MOOO OOOO OOOO OOOO", "VILL WINS ALLL NITE"][easter_egg], true)
player.selection_color = TILE.CENTER_SELECTED_COLOR
player_deselect_all(player)

intro = sequence(
    TITLE.INTRO.PRE_FRAMES, 
    {begin_callback: bounce_row, data: 0, frames: TITLE.INTRO.BEAT_FRAMES},
    {begin_callback: bounce_row, data: 1, frames: TITLE.INTRO.BEAT_FRAMES},
    {begin_callback: bounce_row, data: 2, frames: TITLE.INTRO.BEAT_FRAMES},
    {begin_callback: bounce_row, data: 3, frames: TITLE.INTRO.BEAT_FRAMES},
    highlight_random_row,
    TITLE.INTRO.SLIDE_FRAMES + 40,
    {begin_callback: play_sound, data: {sound: times_up_sound}, frames: 100},
    end_intro)

if DEBUG.STATS:
    go_to_stats()


frame
────────────────────────────────────────────────────────────────────────
if game_frames == 30:
    // Check for any upgrades since the previous version of the game on
    // start
    unlock_new_abilities()
    if DEBUG.INTERMISSION or DEBUG.EARN_XP:
        start_match(GLOBAL_GAME)

    
draw_text({
        pos: xy(0, 0),
        font: tile_point_font,
        text: "v" + CREDITS.version + "+" + QUADPLAY_INFO.version,
        color: #777,
        y_align: "top",
        x_align: "left",
        z: 1})

draw_background_words()

// Spin after the intro
const θ = -0.2° max(0, mode_frames - INTRO_DURATION)
const pos = ½ SCREEN_SIZE
player_draw_board(player, pos, θ, false)
draw_rect(pos, get_player_board_pixel_size() + 22, player.selection_color, ∅, θ, -1) 

// How far to slide the buttons, 0 if the intro has been skipped
const slide = if intro then (-3 min(ease_out(mode_frames - INTRO_DURATION - TITLE.INTRO.SLIDE_FRAMES), 0)) else 0

if player.has_achievement["Change Avatar"]:
    update_button(pos + xy(slide, -30), "Solo", SOLO_GAME)
    if not intro and not player.has_achievement["Play Solo Match"]:
        draw_tutorial(pos - xy(0, 35), "Play a match")
    
if player.has_achievement["Play Solo Match"]:
    update_button(pos - xy(slide, -30), "Global", GLOBAL_GAME)
    if not intro:
        if not player.has_achievement["Play Global Match"]:
            draw_tutorial(pos + xy(0, 35), "Join a global match", 90°)
        else if not player.has_achievement["Play Second Global Match"]:
            draw_tutorial(pos + xy(0, 35), "Keep playing Global\nto unlock features", 90°)

// Logo
local:
    const pos = xy(SCREEN_SIZE.x - 32 + slide, 20)
    draw_sprite({sprite: logo_sprite, pos: pos, z: -0.6})
    if touch.pressed_a and overlaps(touch.xy, {pos: pos, size: logo_sprite.sprite_size}):
        pause_menu("Credits")
        
    
// Avatar
local:
    const region = {pos: xy(SCREEN_SIZE.x - 32 + slide, SCREEN_SIZE.y - 36), size: xy(32, 32)}
    
    if not player.has_achievement["Change Avatar"]:
        draw_tutorial(region.pos - xy(0, 25), "Change\nyour\navatar")
    
    if cursor_register_target(cursor, region, if intro then ∅ else go_to_avatar):
        draw_round_selection(region.pos, 20)
    else:
        draw_disk(region.pos, 20, rgba(player.avatar.color, 75%), 75% player.avatar.color)
        
    avatar_draw_large(player.avatar, region.pos)
    draw_text({text: "Level " + player.avatar.level, z: 102, pos: region.pos - xy(0, 26), color: player.avatar.color, outline: #0008, font: leaderboard_font})
    

// Stats button
if player.has_ability["Stats Tracker"]:
    update_stats_button(xy(32 - slide, SCREEN_SIZE.y - 36))


if intro and (any_button_press() or touch.pressed_a):
    end_intro()

cursor_update(cursor)

