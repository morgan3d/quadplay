Title
════════════════════════════════════════════════════════════════════════
const INTRO_DURATION = INTRO.PRE_FRAMES + INTRO.BEAT_FRAMES * INTRO.NUM_BEATS

/* Hook for the intro sequence. If ∅ the intro is over */
let intro = ∅

/* If non-zero, show a different title screen */
let easter_egg = 0

const cursor = make_cursor(∅, ∅, false, select_tile_sound)


def go_to_stats():
    push_mode(DisplayStats) because "Button"



def go_to_avatar():
    push_mode(AvatarEditor) because "Selected avatar"



def update_stats_button(pos):
    const region = {pos: pos, shape: "disk", size: 20 * xy(2, 2)}
    const selected = cursor_register_target(cursor, region, if intro then ∅ else go_to_stats)
    draw_stats_button(pos, selected, ½ region.size.x)


    
def start_match(index):
    game_type = index
    
    // When did the previous game start?
    const prev_start = prev_global_game_utc_start_time()
    
    // Did the previous game finish (i.e., there is no current game)
    const prev_game_finished = frame_utc_now ≥ prev_start + GLOBAL_PLAY_SECONDS
            
    // Is the next game about to begin? If they are within 2 seconds of the next
    // game just send them to the game a little early, it isn't a huge
    // advantage and avoids any race condition
    const next_game_imminent = frame_utc_now > prev_start + GLOBAL_PERIOD - 2
    
    // How much time is left in the current game?
    const curr_game_remaining_time = max((prev_start + GLOBAL_PLAY_SECONDS) - frame_utc_now, 0)

    /*        
    debug_print(
        "prev_start =", prev_start,
        "\nprev_game_finished =", prev_game_finished,
        "\nnext_game_imminent =", next_game_imminent,
        "\ncurr_game_remaining_time =", curr_game_remaining_time) */
    
    // There is no game currently running because the global game is in 
    // the GameOver state, or about to be so. Send this player to the waiting room
    // so that they aren't bored. 
    in_waiting_room = ((index == GAME_TYPE.GLOBAL and
        (prev_game_finished or curr_game_remaining_time < GLOBAL_JOIN_MIN_REMAINING_TIME) and
        not next_game_imminent))
    
    play_sound(blip_sound)
    set_mode(GenerateBoard) because "Chose game type"

    
    
def update_button(pos, text, index):
    const rect = {pos: pos, size: xy(132, 24)}
    
    
    const selected = cursor_register_target(cursor, rect, if intro then ∅ else start_match, index)
        
    if selected:
        // Drop shadow
        draw_rect(pos + xy(0, 4), rect.size + 6, #0004, ∅, ∅, 100)
        
        // Highlight
        for 1 ≤ i < 4: 
            draw_rect(pos, rect.size + 2 i, ∅, rgba(lerp(#FFF, CURSOR_COLOR, (i + 1) / 4), 50%), ∅, 100)
        draw_rect(pos, rect.size, CURSOR_COLOR, #FFF, ∅, 100)
        
    else:
        // Drop shadow
        draw_rect(pos + xy(0, 2), rect.size, #0003, ∅, ∅, 100)
        
        // Background
        draw_rect(pos, rect.size, #FFFD, #666, ∅, 100)
        
    draw_text({
        text: text, 
        font: score_font,
        pos: pos + xy(0, 1),
        color: if selected then #FFF else #000,
        outline: if selected then #090 else ∅,
        z: 101})
            


def bounce_row(y, sound default select_tile_sound, color default TILE_CENTER_SELECTED_COLOR):
    play_sound(sound)
    board_deselect_all(player.board, player)
    player.board.selection_color = color
    for x < 4:
        push(player.board.selection, xy(x, y))
        player.board.tile[x][y].selected = mode_frames



def highlight_random_row():
    bounce_row(random_integer(0, ROWS - 1), if easter_egg then moo_00_sound else word_sound, HIGHLIGHT_COLOR)


    
def intro_cleanup():
    intro = ∅ 
    
    
    
def ease_out(f):
    return sign(f) * |f|^1.3
    
    

/* Jump to the end of the intro */
def skip_intro():
    highlight_random_row()
    remove_frame_hook(intro)
    intro = ∅


enter
────────────────────────────────────────────────────────────────────────
set_background(#000)
set_hooks()

easter_egg = if player.avatar.level > 20 and ξ < 12% then 2 else (if player.avatar.level > 15 and ξ < 12% then 1 else 0)

if not easter_egg and player.stats.lifetime.xp > 1000 and ξ < 2%:
    notify(shapes.lightning, "Please Backup", "FWAN is in beta and could crash!\n\nUse the gear button to export a save game as a backup.")


// Initialize the fake board
player_reset_match(player, GAME_TYPE.SOLO, ["FIND WORD ALLL NITE", "FIND COWS ALLL NITE", "MOOO OOOO OOOO OOOO"][easter_egg], true)
player.board.selection_color = TILE_CENTER_SELECTED_COLOR
board_deselect_all(player.board, player)

intro = sequence(
    INTRO.PRE_FRAMES, 
    {begin_callback: bounce_row, data: 0, frames: INTRO.BEAT_FRAMES},
    {begin_callback: bounce_row, data: 1, frames: INTRO.BEAT_FRAMES},
    {begin_callback: bounce_row, data: 2, frames: INTRO.BEAT_FRAMES},
    {begin_callback: bounce_row, data: 3, frames: INTRO.BEAT_FRAMES},
    highlight_random_row,
    INTRO.SLIDE_FRAMES + 40,
    {begin_callback: play_sound, data: {sound: times_up_sound}, frames: 100},
    intro_cleanup)

if DEBUG.STATS:
    go_to_stats()


frame
────────────────────────────────────────────────────────────────────────
if game_frames == 30:
    // Check for any upgrades since the previous version of the game on
    // start
    grant_new_abilities()
    
    if DEBUG.INTERMISSION:
        start_match(GAME_TYPE.GLOBAL)

    
draw_text({
        pos: xy(0, 0),
        font: tile_point_font,
        text: "v" + CREDITS.version + "+" + QUADPLAY_INFO.version,
        color: #777,
        y_align: "top",
        x_align: "left",
        z: 1})

draw_background_words()

// Spin after the intro
const θ = -0.2° max(0, mode_frames - INTRO_DURATION)
const pos = ½ SCREEN_SIZE
player_update_board(player, pos, θ, false)
draw_rect(pos, get_board_pixel_size() + 22, player.board.selection_color, ∅, θ, -1) 

// How far to slide the buttons, 0 if the intro has been skipped
const slide = if intro then (-3 min(ease_out(mode_frames - INTRO_DURATION - INTRO.SLIDE_FRAMES), 0)) else 0

if player.has_achievement["Change Avatar"]:
    update_button(pos + xy(slide, -30), "Solo", 0)
    if not intro and not player.has_achievement["Play Solo Match"]:
        draw_tutorial(pos - xy(0, 35), "Play a match")
    
if player.has_achievement["Play Solo Match"]:
    update_button(pos - xy(slide, -30), "Global", 1)
    if not intro and not player.has_achievement["Play Global Match"]:
        draw_tutorial(pos + xy(0, 35), "Join a global match", 90°)


// Logo
local:
    const pos = xy(SCREEN_SIZE.x - 32 + slide, 20)
    draw_sprite({sprite: logo_sprite, pos: pos, z: -0.6})
    if touch.pressed_a and overlaps(touch.xy, {pos: pos, size: logo_sprite.sprite_size}):
        pause_menu("Credits")
        
    
// Avatar
local:
    const region = {pos: xy(SCREEN_SIZE.x - 32 + slide, SCREEN_SIZE.y - 36), size: xy(32, 32)}
    
    if not player.has_achievement["Change Avatar"]:
        draw_tutorial(region.pos - xy(0, 25), "Change\nyour\navatar")
    
    if cursor_register_target(cursor, region, if intro then ∅ else go_to_avatar):
        draw_round_selection(region.pos, 20)
    else:
        draw_disk(region.pos, 20, rgba(player.avatar.color, 75%), 75% player.avatar.color)
        
    avatar_draw_large({…player.avatar, sprite: player.avatar.sprite.x_flipped}, region.pos)
    draw_text({text: "Level " + player.avatar.level, z: 102, pos: region.pos - xy(0, 26), color: player.avatar.color, outline: #0008, font: leaderboard_font})
    

// Stats button
if player.has_ability["Stats Tracker"]:
    update_stats_button(xy(32 - slide, SCREEN_SIZE.y - 36))


if intro and (any_button_press() or touch.pressed_a):
    skip_intro()

cursor_update(cursor)

