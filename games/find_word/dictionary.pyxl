/*
 Routines for working with words, including
 the dictionary word sets.
 
 The dictionary contains about 193k words that are not proper nouns,
 including variations such as plurals.
 
 The full boggle board contains about 57M possible 
 sequences (nodes in the search tree).
 
 In this game:
 
 - "word" as a variable name means an all-caps, Q-encoded word (Q = Qu)
 - "text" as a variable name is something that can be shown to the player
 - In-game text representing a dictionary play word is shown in all caps
 - In-game letter tiles are capital letters, except for "Qu" 
 - All other text is mixed case, except for: logos, avatar names,
   and the Free Mode animation
 - The primary emphasis color is HIGHLIGHT_COLOR pink
 - The primary button/cursor/UI selection color is green
*/

if DEBUG.RESET_PLAYER:
    debug_print("RESET PLAYER")
    save_local()


set_random_seed()

/* Revised dictionary table of about 192k words with:
 
   - No capitalized words
   - No words shorter than `DICTIONARY.MIN_WORD_LENGTH`
   - No words with "Q" not followed by "U"
   - All words capitalized
   - All "QU" replaced with "Q", so that it counts as a single letter/tile
     for comparison purposes
     
   Use `q_decode()` for expanding the "Q" back to "QU" before displaying
   to the user.
*/

// Compute `dictionary`
def _filter_dictionary(text):
    // Use JavaScript regexp undocumented quadplay feature to exclude 
    // words with capital letters or q without u. Also ensure the word
    // does not end in a q (without u).
    //
    // We have to check max word length after q encoding because there
    // are 30 words with 2 qs, which change the length.
    if (size(text) ≥ DICTIONARY.MIN_WORD_LENGTH and       
       not text.match(/q[^u]/g) and
       lowercase(text) == text and
       last_value(text) ≠ "q"):
           
        const w = replace(text, "qu", "q")
        
        return if size(w) ≥ DICTIONARY.MIN_WORD_LENGTH and size(w) ≤ DICTIONARY.MAX_WORD_LENGTH then uppercase(w) else ∅

const dictionary = {
    all: array_to_set(dictionary_source, 1, ∅, _filter_dictionary),
    common: array_to_set(common_source, 1, ∅, _filter_dictionary)}

// Restore months and days of the week, even though they are capitalized
for value at field in dictionary:
    array_to_set(DICTIONARY.EXTRA, 1, value)

const sensitive = {…sensitive_source, …DICTIONARY.SENSITIVE_EXTRA}

// Check to make sure we did the preprocessing correctly
assert(dictionary.all["COLOR"])
assert(dictionary.all["COLORS"])
assert(dictionary.all["COLOUR"])
assert(not dictionary.all["colors"])
assert(not dictionary.all["QUEST"])
assert(dictionary.all["QEST"])
assert(dictionary.all["BEST"])
assert(dictionary.all["TRUE"])
assert(dictionary.all["FALSE"])

/* Array of all of the words in `dictionary.all` */
const dictionary_array = {all: keys(dictionary.all), common: keys(dictionary.common)}
debug_print(format_number(size(dictionary_array.all), "commas"), "total words in dictionary")


/* Return `word` in which every "Q" has been replaced with "QU".
   The operation is trivial but this abstraction makes explicit
   and easily searchable where these operations occur in the code.
   
   Assumes `word` is all upper case. The returned string is all
   upper case. */
def q_decode(word):
    return replace(word, "Q", "QU")

    
def q_encode(word):
    return replace(word, "QU", "Q")



/* Given a q-encoded word `pattern` that contains zero or one `WILDCARD_CHARACTER`s,
   return an array of all q-encoded words (which may be zero) that
   match the pattern. */
def dictionary_search(pattern):
    const result = []
    if contains(pattern, WILDCARD_CHARACTER):
        const part = split(pattern, WILDCARD_CHARACTER)
        for letter in DICTIONARY.ALPHABET:
            const word = part[0] + letter + part[1]
            if dictionary.all[word]:
                push(result, word)
    else if dictionary.all[pattern]:
        push(result, pattern)
            
    return result
    
    

/* Computes the letter points and size multiplier. Assumes
   word is an all-uppercase string with only legal characters
   and is Q-encoded (Q appears without U) that came
   from pattern. */
def score_word(word, pattern default word):
    if size(word) < DICTIONARY.MIN_WORD_LENGTH or not dictionary.all[word]:
        return 0
            
    // Length multiplier (# tiles, not letters)
    const multiplier = min(5, size(word) - DICTIONARY.MIN_WORD_LENGTH + 1) + clamp(0.25 (size(word) - 7), 0, 2.25)

    let score = 0
    for letter in slice(pattern, 0, size(word)):
        score += (LETTER_POINT_TABLE[letter] default 0) * multiplier
    
    return max(round(score), 0)

/*
// Print the score multiplier table
for 3 ≤ W < 17:
    debug_print(W, "|", min(5, W - DICTIONARY.MIN_WORD_LENGTH + 1) + clamp(0.25 (W - 7), 0, 2.25))
*/

def color_for_points(points):
    if points ≤ HISTORY.LOW_POINTS:
        return HISTORY.COLOR[0]
    else if points ≥ HISTORY.HIGH_POINTS:
        return HISTORY.COLOR[3]
    else:
        // Scale up in discrete steps
        const α = min(⌊⅕ (points - HISTORY.LOW_POINTS)⌋ / 8, 100%)
        const c = hsv(perceptual_lerp_color(HISTORY.COLOR[1], HISTORY.COLOR[2], α))
        return rgb({h: c.h, s: 120% c.s, v: c.v})



/* Returns a word from the dictionary that is not sensitive */
def random_safe_word(array default dictionary_array.all, rng default random, min_size default 5, max_size default 8):        
    let word = ∅
    while not word or size(word) < min_size or size(word) > max_size or sensitive[word]:
        word = lowercase(q_decode(random_value(array, rng)))
    return word



/* Replaces the `text` with (first letter) + ∙∙∙ if it is in the 
   sensitive dictionary. Assumes the input is q-decoded */
def censor(text):
    return if text and sensitive[lowercase(text)] then hide_text(text) else text



def hide_text(text):
    return text[0] + slice("∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙", 0, size(text) - 1)
