/*
 Routines for working with words, including
 the dictionary word sets.
 
 The dictionary contains about 193k words that are not proper nouns,
 including variations such as plurals.
 
 The full boggle board contains about 57M possible 
 sequences (nodes in the search tree).
 
 In this game:
 
 - "word" as a variable name means an all-caps, Q-encoded word (Q = Qu)
 - "text" as a variable name is something that can be shown to the player
 - In-game text representing a dictionary play word is shown in all caps
 - In-game letter tiles are capital letters, except for "Qu" 
 - All other text is mixed case, except for: logos, avatar names,
   and the Free Mode animation
 - The primary emphasis color is HIGHLIGHT_COLOR pink
 - The primary button/cursor/UI selection color is green
*/

if DEBUG.RESET_PLAYER:
    debug_print("RESET PLAYER")
    save_local()


set_random_seed()

/* Revised dictionary table of about 192k words with:
 
   - No capitalized words
   - No words shorter than `DICTIONARY.MIN_WORD_LENGTH`
   - No words with "Q" not followed by "U"
   - All words capitalized
   - All "QU" replaced with "Q", so that it counts as a single letter/tile
     for comparison purposes
     
   Use `q_decode()` for expanding the "Q" back to "QU" before displaying
   to the user.
*/

// Compute `dictionary`
def _filter_dictionary(text):
    // Use JavaScript regexp undocumented quadplay feature to exclude 
    // words with capital letters or q without u. Also ensure the word
    // does not end in a q (without u).
    //
    // We have to check max word length after q encoding because there
    // are 30 words with 2 qs, which change the length.
    if (size(text) ≥ DICTIONARY.MIN_WORD_LENGTH and       
       not text.match(/q[^u]/g) and
       lowercase(text) == text and
       last_value(text) ≠ "q"):
           
        const w = replace(text, "qu", "q")
        
        return if size(w) ≥ DICTIONARY.MIN_WORD_LENGTH and size(w) ≤ DICTIONARY.MAX_WORD_LENGTH then uppercase(w) else ∅

const dictionary = {
    all: array_to_set(dictionary_source, 1, ∅, _filter_dictionary),
    common: array_to_set(common_source, 1, ∅, _filter_dictionary)}

// Restore months and days of the week, even though they are capitalized
for value at field in dictionary:
    array_to_set(DICTIONARY.EXTRA, 1, value)

const sensitive = {…sensitive_source, …DICTIONARY.SENSITIVE_EXTRA}

// Check to make sure we did the preprocessing correctly
assert(dictionary.all["COLOR"])
assert(dictionary.all["COLORS"])
assert(dictionary.all["COLOUR"])
assert(not dictionary.all["colors"])
assert(not dictionary.all["QUEST"])
assert(dictionary.all["QEST"])
assert(dictionary.all["BEST"])
assert(dictionary.all["TRUE"])
assert(dictionary.all["FALSE"])

/* Array of all of the words in `dictionary.all` */
const dictionary_array = {all: keys(dictionary.all), common: keys(dictionary.common)}
debug_print(format_number(size(dictionary_array.all), "commas"), "total words in dictionary")


/* Return `word` in which every "Q" has been replaced with "QU".
   The operation is trivial but this abstraction makes explicit
   and easily searchable where these operations occur in the code.
   
   Assumes `word` is all upper case. The returned string is all
   upper case. */
def q_decode(word):
    return replace(word, "Q", "QU")

    
def q_encode(word):
    return replace(word, "QU", "Q")



/* Given a q-encoded word `pattern` that contains zero or one `WILDCARD_CHARACTER`s,
   return an array of all q-encoded words (which may be zero) that
   match the pattern. */
def dictionary_search(pattern):
    const result = []
    if contains(pattern, WILDCARD_CHARACTER):
        const part = split(pattern, WILDCARD_CHARACTER)
        for letter in DICTIONARY.ALPHABET:
            const word = part[0] + letter + part[1]
            if dictionary.all[word]:
                push(result, word)
    else if dictionary.all[pattern]:
        push(result, pattern)
            
    return result
    


/* Computes the letter points and size multiplier. Assumes
   word is an all-uppercase string with only legal characters
   and is Q-encoded (Q appears without U) that came
   from `pattern`. */
def score_word(word, pattern default word):
    if size(word) < DICTIONARY.MIN_WORD_LENGTH or not dictionary.all[word]:
        return 0
            
    // Length multiplier (# non-wildcard tiles, not letters)
    const num_tiles = size(replace(pattern, WILDCARD_CHARACTER, ""))
    const multiplier = min(5, num_tiles - DICTIONARY.MIN_WORD_LENGTH + 1) + clamp(0.25 (num_tiles - 7), 0, 2.25)

    let score = 0
    for letter in slice(pattern, 0, size(word)):
        score += (LETTER_POINT_TABLE[letter] default 0) * multiplier
    
    return max(round(score), 0)

/*
// Print the score multiplier table
for 3 ≤ W < 17:
    debug_print(W, "|", min(5, W - DICTIONARY.MIN_WORD_LENGTH + 1) + clamp(0.25 (W - 7), 0, 2.25))
*/

def color_for_points(points):
    if points ≤ HISTORY.LOW_POINTS:
        return HISTORY.COLOR[0]
    else if points ≥ HISTORY.HIGH_POINTS:
        return HISTORY.COLOR[3]
    else:
        // Scale up in discrete steps
        const α = min(⌊⅕ (points - HISTORY.LOW_POINTS)⌋ / 8, 100%)
        const c = hsv(perceptual_lerp_color(HISTORY.COLOR[1], HISTORY.COLOR[2], α))
        return rgb({h: c.h, s: 120% c.s, v: c.v})



/* Returns a word from the dictionary that is not sensitive */
def random_safe_word(array default dictionary_array.all, rng default random, min_size default 5, max_size default 8):        
    let word = ∅
    while not word or size(word) < min_size or size(word) > max_size or sensitive[word]:
        word = lowercase(q_decode(random_value(array, rng)))
    return word



/* Replaces the `text` with (first letter) + ∙∙∙ if it is in the 
   sensitive dictionary. Assumes the input is q-decoded */
def censor(text):
    return if text and sensitive[lowercase(text)] then hide_text(text) else text



def hide_text(text):
    return text[0] + slice("∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙", 0, size(text) - 1)
    

    
/* Convert a word into a partly-masked hint such as "SEIK" -> "S∙∙K". The result is q_decoded.
    */
def word_to_hint_text(word, tile):
    let text = word_to_hint_text.cache[word + ", " + tile]
    if not text:
        const decode_and_mask_set = array_to_set(replace(DICTIONARY.ALPHABET, tile, ""), "∙")
        if tile ≠ "Q": decode_and_mask_set["Q"] = "∙∙"
        text = q_decode(word[0] + replace(slice(word, 1, size(word) - (if word[0] == tile then 1 else 0)), decode_and_mask_set) + (if word[0] == tile then last_value(word) else ""))
        word_to_hint_text.cache[word + ", " + tile] = text

    return text

word_to_hint_text.cache = {}



/*
 `word` is a q-encoded, all upper case string.

 Returns `nil` if `word` is in the `dictionary.all` set, otherwise returns an array of
 the most likely correct spellings sorted by likelihood. The strings in the returned
 array are all upper case and q-encoded.
 
 Does not suggest words that only append one letter to the end,
 as the user may still be in the process of typing.
 */
def spell_check(word):
    if dictionary.all[word]: return ∅
    
    const result = {}

    // Add candidate to result if it is a valid word
    def maybe_add(candidate):
        if dictionary.all[candidate] and not result[candidate]:
            result[candidate] = {
                candidate: candidate,
                score: size(candidate) + (if dictionary.common[candidate] then 5 else 0) + (if candidate[0] == word[0] then 20 else 0)}

    // Phonetic substitutions: common letter confusions
    def consider_phonetic_variations(candidate):
        maybe_add(candidate)

        // Also try phonetic substitutions on this candidate
        for original at i in candidate:
            for group in ["AEIOU", "CKQ", "SZ", "DT", "MN", "BP", "FV", "GJ"]:
                if contains(group, original):
                    for substitute in group:
                        if substitute ≠ original:
                            const phonetic_candidate = spliced(candidate, i, 1, substitute)
                            if dictionary.all[phonetic_candidate] and not result[phonetic_candidate]:
                                result[phonetic_candidate] = {
                                    candidate: phonetic_candidate,
                                    score: size(phonetic_candidate) + (if dictionary.common[phonetic_candidate] then 5 else 0) + (if phonetic_candidate[0] == word[0] then 20 else 0)}
    
    consider_phonetic_variations(word)

    // Deletions: remove each character
    if size(word) - 1 ≥ DICTIONARY.MIN_WORD_LENGTH:
        for i < size(word):
            consider_phonetic_variations(spliced(word, i, 1))
    
    // Substitutions: replace each character
    for i < size(word):
        for letter in DICTIONARY.ALPHABET:
            if letter ≠ word[i]:
                consider_phonetic_variations(spliced(word, i, 1, letter))
    
    // Insertions: add a character at each position (except the end 
    // in Play mode, as the user may still be swiping)
    for i < size(word) + (if get_mode() == Freestyle then 1 else 0):
        for letter in DICTIONARY.ALPHABET:
            consider_phonetic_variations(spliced(word, i, 0, letter))
    
    // Transpositions: swap adjacent characters
    for i < size(word) - 1:
        consider_phonetic_variations(spliced(word, i, 2, word[i + 1], word[i]))
    
    
    // Sort by liklihood and then extract just the words
    const word_array = []
    for entry in sorted(values(result), "score", true):
        push(word_array, entry.candidate)
    
    return word_array


