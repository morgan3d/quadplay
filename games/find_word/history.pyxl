
/* List of words found by a `player`. */
def make_history():
    return {
        // Each entry is `{text, word, tiles, points, color, emphasize_frame, pos}`.
        // `pos` is computed as a side effect of draw history
        // `word` is Q-encoded, `text` may contain arbitrary characters
        list: [],
        
        /* 
          `[{text, word, points, color, …}, …]`. Recomputed by `update_free_row_list()`
          in the `freePhase` mode.
            
         `size(last_value().word)` is the number of tiles used in a word.
         `color_for_points(last_value().points)` is the color to use.
        */
        free: [],
        
        // Auto computed and overriden on new word spawn or resize,
        // but can be manually affected by the player
        scroll: make_scroll_tracker(),

        // Scroll computation resets when screen size changes.
        // This was the size it was computed for.
        scroll_screen_size: xy(0, 0),
        
        // Scroll computation resets when the list size changes.
        // This was the size it was computed for.
        scroll_history_size: 0}
        


/* Mutates `pos`, returns `max_width of the entire contents`. Called from `history_update()`. */
def history_draw(history, pos, max_height):
    todo("Visualize history scroll state on Play view")
    
    const start_y = pos.y
    
    let max_width = 0
    
    def history_draw_entry(entry):
        // Wrap into multiple columns if this element will
        // go off the page. Do this here so that we never
        // reset right before the end
        if pos.y > max_height - 8:
            pos.y = start_y
            pos.x += max_width + HISTORY.COLUMN_SEPARATION
            max_width = 0
            
        const emphasize = max(0, entry.emphasize_frame - game_frames)
        const wiggle = xy(oscillate(18% emphasize, -1, +1) - sign(emphasize), 0)
    
        // Save for animation later
        entry.pos = transform_ws_to_ss(pos)
        
        // Hide while animation is playing for this word, but
        // draw invisibly so we get bounds
        const show = game_frames > entry.reveal_frame
        const outline = if emphasize then #FFF else entry.outline
        
        let text = entry.text
        
        // Emphasize rare values when on the Intermission mode.
        // For other modes (e.g., Play), `rare` will never be true.
        if entry.rare: text += "★"
        
        const flash = entry.rare and (game_frames + 500 - ¼ pos.y) mod 360 > 345
            
        const bounds = draw_text({
            // Bounce if emphasized
            pos: pos + wiggle,
            font: if emphasize then history_emphasis_font else history_font,
            x_align: "left",
            y_align: "top",
            color: if show then ((if flash then #fff else entry.color) * (if entry.rare then 190% else 100%)) else #0000,
            outline: if show then outline else #0000,
            z: emphasize,
            text: text})

        // Track if this makes the column larger
        max_width = max(max_width, text_width(history_font, text))
        pos.y += history_font.line_height + 1

    // Draw tutorial/help
    if not player.has_achievement["Play Solo Match"] and game_type == SOLO_GAME:
        for word at i in TUTORIAL.FIRST_TIME_WORD_LIST:
            if not player.has_achievement["Spell " + word]:
                draw_text({
                    pos: pos + xy(0, max_height),
                    font: score_font,
                    x_align: "left",
                    y_align: "bottom",
                    color: #FFF,
                    outline: #000,
                    z: 100,
                    wrap_width: 150,
                    text: 
                        if i then 
                            (if word == "..." then "Keep going while there's time…" else "Great! Now find " + word)
                        else (if player.using_gamepad
                             then replace("Select letters with (a) to spell " + word, joy.prompt)
                            else "Swipe through letters to spell " + word)})
                // Prevent printing anything else
                break


    if get_mode() ≠ Intermission:
        // Regular list first
        iterate(history.list, history_draw_entry)
        
        // Separator
        if size(history.list) and size(history.free):
            history_draw_entry({text: "", color: #888, reveal_frame: 0, emphasize_frame: 0})
            
    // Draw the free list
    iterate(history.free, history_draw_entry)
    
    if get_mode() == Intermission:
        // Separator
        if size(history.list) and size(history.free):
            history_draw_entry({text: "", color: #888, reveal_frame: 0, emphasize_frame: 0})
            
        // Regular list second
        iterate(history.list, history_draw_entry)
    
    return pos.x + max_width
   
    

/* Adds to `history[list_name]`, where `list_name` must be `"free"` or `"list"`. 
   Returns the color to use for the selection on the board.
   
   Does not change `score` or `free_score` */
def history_add(history, list_name, word, points):
    assert(word)
    assert(type(word) == "string")
    
    if not player.has_achievement["Play Solo Match"]:
        for target at i in TUTORIAL.FIRST_TIME_WORD_LIST:
            if target == word and not player.has_achievement["Spell " + target]:
                player_achieve(player, "Spell " + target)
                    
    const color = color_for_points(points)
    let text_color = color
    let outline = ∅
    
    // Super scorer colors
    if points ≥ 65:
        outline = lerp(color, #FFF, 40%)
        text_color = #FFF
    else if points ≥ 45:
        outline = color
        text_color = #FFF
    else if points ≥ 35:
        outline = lerp(color, #000, 25%)
        text_color = lerp(color, #FFF, 50%)
    
    // Put free words in quotes to clarify that they
    // were not found during the regular game
    push(history[list_name], {
        text:       enquote_if(list_name == "free", q_decode(word)) + " " + points, 
        word:       word,
        emphasize_frame: 0,
        reveal_frame: game_frames + HISTORY.POINTS_ANIMATION_FRAMES,
        points:     points, 
        color:      text_color,
        outline:    outline})
    
    return color
    
    

/* Draw the word history and manage touch dragging */
def history_update(history, history_rect)
& with scroll_screen_size, scroll_history_size in history
& preserving_transform:

    set_clip(history_rect)
    
    if not equivalent(SCREEN_SIZE, scroll_screen_size):
        // Reset on window change
        history.scroll.offset = xy(0, 0)

    const pos = xy(3, 2)
    let max_width
    
    preserving_transform:
        set_transform(history_rect.corner - history.scroll.offset)
        max_width = history_draw(history, pos, history_rect.size.y)

    if player.has_ability["Scry Word Count"]:
        draw_text({
            pos: history_rect.corner + history_rect.size - (if landscape() then xy(½ history_rect.size.x - 25, 1) else xy(2, 1)),
            font: history_font,
            text: "Found " + size(history.list) + "/" + size(board.word_list),
            color: #DDD,
            outline: get_background(),
            x_align: "right",
            y_align: "bottom"})

    const history_size = size(history.list) + size(history.free)
    
    if not equivalent(SCREEN_SIZE, scroll_screen_size) or (scroll_history_size ≠ history_size):
        scroll_screen_size = xy(SCREEN_SIZE)
        scroll_history_size = history_size
        // Set the scroll to whatever it needs to be to keep the 
        // most recent words on screen
        history.scroll.offset.x = max(history.scroll.offset.x, max_width - history_rect.size.x + 1)
    
    scroll_tracker_update(history.scroll, xy(max_width, history_rect.size.y), history_rect, xy(0, 0))

        


/* Gets the history rect in `Play` and `Freestyle` modes. */
def get_history_rect():
    const board_pos = get_board_pos()
    const board_size = get_player_board_pixel_size()

    if landscape():
        return {
            corner: xy(1, 1), 
            size: xy(
                board_pos.x - ½ board_size.x - ¼ TILE.EXTENT + 1, 
                SCREEN_SIZE.y - (if player.has_ability["Freestyle"] and not in_waiting_room then 42 else 8))}
    else:
        // Portrait
        return {
            corner: xy(1, 1),
            size: xy(SCREEN_SIZE.x - 2, board_pos.y - ½ board_size.y - 32)}


        