Standard Library
=========================================================

Types
---------------------------------------------------------

`is_array(value)`
: Returns true for arrays and false for all other types.

`is_boolean(value)`
: Returns true for booleans and false for all other types.

`is_function(value)`
: Returns true for functions and false for all other types.

`is_nil(value)`
: Returns true for `nil` and false for all other types.

`is_number(value)`
: Returns true for numbers and false for all other types.
  Note that the `nan` value ("not a number") _is_ a number for type
  checking purposes

`is_object(value)`
: Returns true for objects and false for all other types.

`is_string(value)`
: Returns true for strings and false for all other types.

`type(value)`
: Returns the type of the value as a string: `"array"`, `"boolean"`,
  `"function"`, `"nil"`, `"number"`, `"object"`, or `"string"`.


Array
---------------------------------------------------------

`array_value(array, i, extrapolate default (array.extrapolate or "clamp"))`
: Applies `floor()` to `i` and then applies the extrapolation mode, which defaults
  to the extrapolation mode of the array itself if specified.
  Intended primarily for animation of values, including
  the named arrays of spritesheets, for example,
  `sprite = array_value(spritesheet[animName], frame)`.
  See also `animation_frame()`, `make_spline()`, and the Sprite JSON section. The `extrapolate` values accepted are:

  - `"oscillate"`
  - `"loop"`
  - `"clamp"` (default, other unsupported values are silentely treated as clamp instead of failing)

`clone(array)`
: Return a shallow clone of `array`. Pointer structures are preserved and loops
  are OK. Immutable objects such as spritesheets and functions are not cloned.

`contains(array, value, comparator default ==)`
: Return `true` if `value` appears at least once in `array` and `false` otherwise.
  The `comparator` may be `nil`, a function that returns
  a non-falsy value if the values are equivalent, or a string or integer that is the
  key of the property to compare using `==` (similar to `sort()`).

`deep_clone(array)`
: Return a deep clone of `array`. Pointer structures are preserved and loops
  are OK. Immutable objects such as spritesheets and functions are not deep cloned.
  Maps are the only asset that can be deep cloned.

`extended(array1, array2)`
: Create a new array that contains all elements of `array1` followed by all elements of `array2`.
  Identical to `[...array1, ...array2]`. See also `extend()`.

`equivalent(a, b)`
: Returns true if these arrays have the same length and the elements are
  `==` (does not recursively test if the elements are equivalent).
  Also returns true if both `is_nan(a)` and `is_nan(b)`.

`extend(array1, array2)`
: Mutate `array1` by pushing all elements of `array2` onto it. Identical to `push(array1, ...array2)`.
  See also `extended()`.

`fast_remove_key(array, i)`
: Delete element `i` from the array, swapping it with the last element. O(1) expected amortized time.

`fast_remove_value(array, v)`
: Delete one element that is `== v`, or do nothing if there is no such element. May reorder the
  array and may choose any such element, not necessarily the first. See also `remove_values()`.

`find(array, x, i default 0, comparator default ==)`
: Find the index of the element whose value is `x`, starting at
  optional index `i`.  Returns `∅` if not found. 
  
  Unless a function is for `comparator`, uses `==` to compare `x` to
  the array values. If a comparator is present, any non-falsy return
  value from the comparator indicates a match. The array element is 
  passed as the first argument to the comparator.
  
  Runs in linear time in the length of the list from `i`. This is
  called `index_of` or `indexOf` in some other programming languages.
  Note that if `is_nan(x)`, then `find()` cannot find any match.
  
  The `comparator` may be `nil`, a function that returns
  a non-falsy value if the values are equivalent, or a string or integer that is the
  key of the property to compare using `==` (similar to `sort()`).
  See also `equivalent()`.

`insert(array, i, x, ...)`
: Inserts the values into the array, starting at index `i` (as in, `array[i] = x` on return)
  and returns the first value inserted. Similar to Python insert and JavaScript splice functions.

`iterate(array, callback, ...args)`
: Iterates through array in order using a callback function, with
  optional O(1) order-preserving removal. Returns `true` if any element
  was removed, otherwise returns `false`. This is an imperative
  version of map(), filter(), and list comprehension primitives from
  other languages.

   If `callback` is a string, iterate then calls `array[i][callback](array[i], ...args)`
   on each element for which `array[i][callback]` is not nil.  If `callback` is a function, it instead calls `callback(array[i])`
   on each element. It is common to define a local function immediately before the
   `iterate()` call for use as the callback.
   
   Return values from the called function have the following effects:

   - `iterate.REMOVE`: remove the current value and continue iterating
   - `iterate.BREAK`: immediately stop iterating
   - `iterate.REMOVE_AND_BREAK`: remove the current element and then stop processing
   - `iterate.CONTINUE`: continue with iteration. This is not required; as long as the previous
      values are not returned by the callback, the iterator will still continue

   The callback may push values onto the array during iteration, but
   not otherwise mutate the array.


`iterate_pairs(array, callback, ...args)`
: Iterates over all n * (n - 1) / 2 uniquely indexed pairs of elements
  in the n-element array. This is useful for testing for collisions, for example.
  Invokes `callback(A, B, ...args)` for each pair. 
  
  Returns `true` if any element was removed and false otherwise.

  The return value from `callback` may be an array of two elements,
  `[a_action, b_action]`. If a single `iterate` constant is returned,
  then it is converted to an array of two copies of that value.
  The return values are processed as follows.

  `a_action`:

  - `iterate.REMOVE`: Remove A immediately from the
    array and continue iteration, starting from the next value
    for A.

  - `iterate.REMOVE_AND_BREAK`: Remove A immediately from the
    array and stop all iteration.

  - `iterate.BREAK`: Stop all iteration.

  - `iterate.CONTINUE` or any other value: Continue iteration.

  

  `b_action`:

   - `iterate.REMOVE`: Remove B immediately from the array and
     continue iteration. B will not be seen by further values of A
     (unless it appeared in the array multiple times).

   - `iterate.REMOVE_AND_BREAK`: Remove B immediately from the array
     and stop iteration for the current A, but continue iterating on
     more As.  B will not be seen by further values of A (unless it
     appeared in the array multiple times).

   - `iterate.BREAK`: Stop iteration for the current A, but continue 
     iterating on more As. 

   - `iterate.CONTINUE` or any other value: Continue iteration.

  Note that `[iterate.REMOVE, iterate.BREAK]` has the same effect as
  `[iterate.REMOVE, iterate.CONTINUE]`.

  All removals preserve order. Running time with no removal or break
  is necessarily O(n^2) for an array of length n. Unlike `iterate()`,
  each removal is O(n) instead of constant time.

  The callback may push values onto the array during iteration, but
  not otherwise mutate the array.

  See also `iterate()`.


`join(array, separator default "", lastSeparator default separator, pairSeparator default lastSeparator, empty default "")`
: Joins the elements of the array into a string. Each element `x` converted to a string with `unparse(x, 1)` if it is not already a string.
  The optional `lastSeparator` allows the final join to use a special case.
  The optional `pairSeparator` is a special separator used for arrays of length two.
  For example `join(inventory, ", ", ", and ", " and ", "nothing")`.
  The optional `empty` value is used if the array has length 0.

`last_key(array)`
: Returns `size(array) - 1`, the last key (that is, index).

`last_value(array)`
: Returns `array[last_key(array)]`.

`make_array(size, value default nil, value_clone default nil)`
: Creates a 1D (if `size` is a number), 2D (if `size` is an `xy()`),
  or 3D (if `size` is an `xyz()`) array of arrays.  Each element is
  initialized independently to `if value_clone then value_clone(value) else value`.
  `clone()` and `deep_clone()` are common choices for `value_clone`.
  
  Multidimensional arrays are indexed as `array[x][y][z]`.
  
  For 2D arrays, the outer array has an extra `array2D.size` property
  on the outermost array that is an `xy()`.

  For 3D arrays, the outer array has an extra `array3D.size` property
  that is an `xyz()`, and the inner 2D arrays each have an extra
  `array2D.size` property on the that is a `yz()`.
  
  Use `size(array)` to determine the length of a 1D array.

`penultimate_value(array)`
: Returns `array[last_key(array) - 1]`.

`pop(array)`
: Remove the last element from the array and return it, or `∅` if the array is empty. O(1) expected amortized time.

`pop_front(array)`
: Remove the first element from the array and return it, or `∅` if the array is empty. O(n) expected amortized time.

`push(array, x, ...)`
: Append `x` and any other arguments to the array and then return the last argument. O(1) expected
  amortized time for a single argument and O(_m_) for _m_ arguments. This is
  the only mutation permitted while iterating over an array via `for value in array`
  or `iterate(array, callback)`.

`push_front(array, x, ...)`
: Insert `x` and any other arguments onto the array, preserving the order
  that they appear in the arguments and then return the first. O(_n_) expected
  amortized time for a single argument and O(_m_) for _m_ arguments and
  array of length _n_.

`random_from_distribution(array, random default random)`
: Return a random index (key) of the array, chosen proportional to the values.

`random_key(array, random default random)`
: Return a random index into the array.

`random_value(array, random default random)`
: Return a random element of the array.

`remove_key(array, i)`
: Remove element `i` from the array, preserving order. O(n) expected time.

`remove_values(array, v, comparator default ==)`
: Remove every value `x` for which `comparator(x, v)` in the array, maintaining order. O(n)
  time in the original length of the array. Returns true if any value
  was removed. Does nothing if `v` is not in the array. See also
  `fast_remove_value()`

  The `comparator` may be `nil`, a function that returns
  a non-falsy value if the values are equivalent, or a string or integer that is the
  key of the property to compare using `==` (similar to `sort()`).
  See also `equivalent()`.

`remove_all(array)`
: Remove everything from the array. Same as `resize(array, 0)`.

`resize(array, n)`
: Change the length of the array. O(size(array) + n) time if growing, O(1) if shrinking.

`reverse(array)`
: Reverses the array in place, O(size(array)). 
  Returns nothing to avoid confusion with `reversed()`.

`reversed(array)`
: Returns a shallow, reversed clone of the array, O(size(array))
  See also `reversed(string)`.

`shuffle(array, random default random)`
: Randomizes the array in place using using Knuth-Fisher-Yates in O(n) time. Returns nothing to avoid confusion with `shuffled()`.

`shuffled(array, random default random)`
: Returns a shallow, shuffled clone of the array, O(size(array))

`size(array)`
: Get the length of the array. O(1) time.

`slice(array, s, e default size(array))`
: Return the subarray of `array` between `s` (inclusive) and
  optional `e` (exclusive, defaults to length).

`sort(array, k, reverse default false)`
: Sort the array from least to greatest in place. If `k` is a string, then
  elements of the array are assumed to be objects and are sorted by
  that key. If `k` is a number, then elements of the array are assumed
  to be other arrays or strings and are sorted by that index. If `k`
  is not specified and the array contains objects, then elements are
  sorted by their alphabetically-first key.

  If `k` is a function, then it must be a function of the form
  `compare(a, b)` that returns a positive number if `a` is greater
  than `b`, a negative number if `b` is greater than `a`, and zero if
  they are equal.

  If `k` is not specified and the array contains numbers or strings,
  then they are sorted by natural order.

  If `reverse` is true, then the array is sorted in reverse order
  from greatest to least.

`sorted(array, k, reverse default false)`
: Clone the array, sort it, and return the sorted array. See `sort()`
  for details.
  
`swap(array, i, j)`
: Swaps elements `i` and `j` in the array in place.

String
---------------------------------------------------------
`array_value(string, i, extrapolate default "clamp")`
: Extract a character with extrapolation for out of bounds values.
  Applies `floor()` to `i` and then applies the extrapolation mode.
  The `extrapolate` values accepted are:

  - `"oscillate"`
  - `"loop"`
  - `"clamp"` (default, other unsupported values are silentely treated as clamp instead of failing)

`capitalized(string)`
: Returns a new string with the first letter of each word capitalized. Existing capital
  letters are unchanged.

`contains(string, substring)`
: Returns `true` if `substring` appears at least once in `string`
  and `false` otherwise.

`ends_with(string, target)`
: Returns true if `string` ends with the substring `target`.

`evaluate_constant_expression(expr)`
: Parse the code expression `expr` and evaluate it. This is useful for embedding <quadplay/> constant literals
  and constant expressions inside of data files. For example, to have a CSV file with a 
  table that contains references to sprites. Creates an error if parsing fails.

  Handles:
   
   - Simple constant literals such as `true`, `3`, `nil`, `"hi"`, `#E1B`
   - Literal object or array definitions that do not reference assets or game constants.
     For example, `{name: "Electra", health: 100}`
   - identifier expressions from ASSET or CONSTANT that use only strings, identifiers, and integers.
     For example, `spritesheet[2][1]`. Does not allow mixing with other literals.

  Does not support arithmetic or other operators, only literals.

`extended(a, b)`
: Returns a new string that is `a + b`.

`find(string, x, i default 0)`
: Find the index of the substring `x`, starting at
  optional index `i` (default 0).  Returns `∅` if not found.
  
  Runs in linear time in the length of the string from `i`. This is
  called `index_of` or `indexOf` in some other programming languages.

`format_number(n, format)`
: Produces a string from number `n` in one of the following formats.
  Each is followed by an example output. When `n` is a time, it is in seconds.

   - `"percent"`, `"%"`: 30%
   - `"commas"` (comma thousand separators): 1,000,000
   - `"spaces"` (space thousand separators): 1 000 000
   - `"binary"`: 0b10100001
   - `"degrees"`, `"deg"`, `"°"`: 57°
   - `"0.#deg"`, `"0.#°"`: 57.3°
   - `"0.0deg"`, `"0.0°"`: 180.0°
   - `"hex"`: 0xa1
   - `"scientific"`: 6.022×10²³
   - `"clock12"`: 5:35pm
   - `"clock24"`: 17:35 (these are hours and minutes)
   - `"timer"`: 1:38 (these are minutes and seconds)
   - `"stopwatch"`: 1:38.71
   - `"oldstopwatch"`: 1"38'71
   - `"ordinal"`: second
   - `"ordinalabbrev"`: 2ⁿᵈ
   - `"fraction"`: ¼
   - `".00"` (or any other trailing zero sequence): 4.91
   - `"00"` (or any other leading zero sequence): 07
   - `" 0"` (or any other leading space sequence followed by a zero sequence): " 7"

  The suffixes `°`, `degrees`, `deg`, and `%` can be added to the `0` forms to
  force the rounding to occur after to conversion to degree measure or percentage.
  For example, `format_number(0.8123, "0.0%")` produces `"81.2%"`.

  The prefix `+` can be added to all forms to force a leading + sign when
  the number is positive.

`last_key(string)`
: Returns `size(string) - 1`.

`last_value(string)`
: Returns `string[last_key(string)]`.

`lowercase(s)`
: Returns the lower case version of the string.

`parse(s)`
: Parse a string that was encoded using `unparse()` and convert it back into the original
  data structure. Functions, built-ins, and recursive arrays cannot be converted.

`penultimate_value(string)`
: Returns `string[last_key(string) - 1]`.

`replace(string, src, dst)`
: Replace all occurances of `src` in `string` with `dst`.

`replace(string, object)`
: Replace all occurances of each key of `object` with each `value` of object in `string`
  simultaneously. For example,
  `replace("Hey, PROPER_NOUN, use the ADJ NOUN!", {ADJ: "big", NOUN: "stick", PROPER_NOUN: "Runi"})`.

`resized(string, size, pad default " ", right_align default false)`
: Return a new string of the specified `size`, using `pad` to extend as needed.
  If `right_align` is true, padding and cropping occur at the start of the string
  instead of the end.

`reversed(string)`
: Returns a reversed version of the string in O(size) time.

`shuffled(string, rng default random)`
: Returns a shuffled version of the string in O(size) time.

`size(s)`
: Get the length of the string. O(1) time.

`slice(string, s, e default size(str))`
: Return the substring of `string` between `s` (inclusive) and
  optional `e` (exclusive, defaults to length).

`split(string, separator default "", max_splits default infinity)`
: Returns an array of strings separated by `separator`. If 
  the `separator` is the empty string, then all characters are separated.
  If a `max_splits` is specified, at most that many splits are made.

`split(string, count default 0)`
: Returns an array of strings that are every sequential `count` characters from `string`.

`starts_with(string, target)`
: Returns true if `string` begins with the substring `target`. See also `ends_with()`.

`string_compress(string)`
: Returns a compressed version of the string (as a different string). Good for conserving
  space in `save_local()`.

`string_decompress(string)`
: Returns a decompressed version of the string. The compression ratio varies with content.
  Expect between 2x and 10x reduction in length for typical text or word lists.
  Recognizes strings that lack the compression header and returns them unchanged.

`trim_spaces(string)`
: Returns a new string that is the original with whitespace removed
  from the start and end. See also `resized()`

`unparse(x, level default 1)`
: Returns code that is equivalent to producing data object `x`, if it
  is not a recursive object or array or a function. Note that
  unparsing a string will add quotes around the contents. 
  
  The values of `level` are:
  
  0 = Compact as possible. No whitespace at all. Used internally for
      `save_local()`

  1 = Readable single line, with spaces after ":" and ",". Default and used
      internally for string coercion.
  
  2 = Containers with more than four elements or which contain
      other containers have newlines and indentation after "[{,".
      "]" and "}" on the line with the previous element.
      
  3 = Containers with more than four elements or which contain other
      containers have newlines and indentation after "[{,".  "]" and
      "}" on their own lines. Used internally by `debug_print()`.
      
  4 = Newlines and indentation after all "[{,}]" except for empty
      containers
      
  See also `unparse_hex_color()`.

`uppercase(s)`
: Returns the upper case version of the string.


Object
---------------------------------------------------------
`clone(object)`
: Return a shallow clone of `object`. Pointer structures are preserved and loops
  are OK. Built-in objects such as spritesheets and functions are not cloned.

`contains(object, value, comparator default ==)`
: Returns `true` if there is some key that maps to `value` in `object`
  and `false` otherwise. The `comparator` may be `nil`, a function that returns
  a non-falsy value if the values are equivalent, or a string or integer that is the
  key of the property to compare using `==` (similar to `sort()`).
  See also `equivalent()`.

`deep_clone(object)`
: Return a deep clone of `object`. Pointer structures are preserved and loops
  are OK. Built-in objects such as spritesheets and functions are not cloned.

`extended(object1, object2)`
: Create a new object that is the union of `object1` and `object2`,
  where `object2` keys override in the case of collisions.
  This is identical to using the spread operator, `{...object1, ...object2}`.
  See also `extend()`.

`extend(object1, object2)`
: Mutate `object1` by assigning all elements of `object2` into it,
  overriding any existing keys in the case of collisions.
  See also `extended()`.

`fast_remove_key(object, k)`
: Same as `remove_key` for a object.

`fast_remove_value(object, value)`
: Delete one element that is `== v`, or do nothing if there is no such element.
  See also `remove_values()`.

`find(object, x, start_key default ∅, not_found_value default ∅, comparator default ==)`
: Find a key for which the value is `x`.
  Returns `not_found_value` if not found. Uses `comparator` to compare `x` to array values.
  O(n) time in the number of key-value pairs. The `ignored` parameter is
  present to match the signature of the array and string versions of
  `find()` but does nothing in the object case.
  The `comparator` may be `nil`, a function that returns
  a non-falsy value if the values are equivalent, or a string or integer that is the
  key of the property to compare using `==` (similar to `sort()`).
  See also `equivalent()`.

`keys(object)`
: An array of the keys in the object. You almost never need this because
  `for k in object` iterates over the keys directly.

`random_key(object, random default random)`
: Return a random key of the object

`random_value(object, random default random)`
: Return a random key's value in the object

`random_from_distribution(object, random default random)`
: Return a random key from the object, chosen proportional to the values.

`remove_key(object, k)`
: Remove a key-value pair by key. Does nothing if `k` is not in the object.
  Use `object[k] ≠ ∅` to test for containment explicitly.

`remove_values(object, v, comparator default ==)`
: Remove every value `x` for which `comparator(x, v)` from the object. Returns true if any
  value was removed. See also `fast_remove_value()`.  
  The `comparator` may be `nil`, a function that returns
  a non-falsy value if the values are equivalent, or a string or integer that is the
  key of the property to compare using `==` (similar to `sort()`).
  See also `equivalent()`.

`remove_all(object)`
: Remove everything from the object. It is faster to assign to a new, empty object than to
  use this function. `remove_all()` is for when it is important to retain a pointer
  to the original object because it is shared.

`size(object)`
: The number of entries in the object.

`swap(object, i, j)`
: Swaps elements with keys `i` and `j` in the object in place.
  
`values(object)`
: An array of the values in the object.


Random Values
---------------------------------------------------------

### 1D

`make_random(seed default local_time().millisecond)`
: Returns a new _function_ that acts like `random()` but has its own private
  seed and internal state. See also `set_random_seed()`.
  The `seed` may be a number or a string.
  The exact number sequence arising from a given seed is not guaranteed
  to be consistent across different quadplay versions, as the underlying
  pseudo-random number generator may change.

`random()`
: `random(0, 1)`. Same as the `ξ` operator.

`random(lo, hi)`
: Random real number between `lo` and `hi`, excluding `hi`. See also the `ξ` operator, the no-argument version
  of `random()`.

`random_gaussian()`
: Same as `random_gaussian(0, 1, random)`

`random_gaussian(mean, stddev, rng default random)`
: Returns a Gaussian distributed random number on the distribution
  with the given mean and standard deviation. See also `random_truncated_gaussian()`.

`random_integer(hi)`
: Uniformly distributed random integer between 0 and hi, inclusive.
  This version is deprecated. Use `random_integer(0, hi)` instead.

`random_integer(lo, hi, rng default random)`
: Random integer between `lo` and `hi`, including both ends.
  The `random` argument defaults to common random number generator `random()`, but
  an alternative function previously created by `make_random()` can be
  passed instead.

`random_sign(rng default random)`
: Returns +1 or -1 with equal probability.

`random_truncated_gaussian(mean, stddev, radius default (2 * stddev), rng default random)`
: Returns a Gaussian distributed random number within `radius` of
  the mean. The default radius corresponds to about 96% of the total probability
  of the distribution and avoids very long tails. See also `random_gaussian()`.

`set_random_seed(seed default local_time().millisecond)`
: Reset the default random number generator, `random()`, using an optional seed.
  The `seed` may be a string or number.
  To match the default random number generator, use a seed of `0`.
  See also `make_random()`.


### 2D

`random_direction2D(rng default random)`
: Same as `random_on_circle()`

`random_gaussian2D()`
: Same as `random_gaussian2D(xy(0, 0), xy(1, 1), random)`.

`random_gaussian2D(mean, stddev, rng default random)`
: Returns a Gaussian distributed random point on the distribution
  with the given mean and standard deviation. The mean and standard
  deviation may each be scalar or `xy()` values.
  See also `random_gaussian()`, `random_truncated_gaussian2D()`.

`random_on_circle(rng default random)`
: Returns a uniformly distributed `xy()` on the perimeter of the
  circle with center `(0, 0)` with radius 1.  Useful for random
  directions.

`random_on_square(rng default random)`
: Uniformly distributed `xy()` on the _perimeter_ of a square from
  `(-1, -1)` to `(1, 1)`.

`random_within_circle(rng default random)`
: Returns a uniformly distributed `xy()` in the disk with center `(0, 0)` 
  with radius 1. Useful for random offsets within a circle. See
  also `random_on_circle()`.

`random_within_region(region, recurse default true, rng default random)`
: Random world space 2D point generated within uniformly within the
  region described. A region may be:

   - an entity from `make_entity()`
   - any object with `pos` or `corner`, and optional `shape`, `angle`, `pivot`, and `size` properties
   - any object with `x` and `y` properties (including an `xy()`), which will be treated as a point

  If `recurse` is true (the default), recursively considers the area
  covered by all children as if they were non-overlapping. That is,
  the overlapping area is sampled twice.

`random_within_square(rng default random)`
: Returns a uniformly distributed `xy()` in the square from `(-1, -1)` to `(1, 1)`, that is,
  the square that has a "radius" of 1 or sides of length two, and is centered at the origin `(0, 0)`.
  See also `random_within_circle()`.

`random_within_tri(A, B, C, rng default random)`
: Returns a uniformly distributed `xy()` point within triangle ABC, including potentially
  on the border.

`random_truncated_gaussian2D(mean, stddev, radius, rng default random)`
: Returns a Gaussian distributed random point within `radius`
  of `mean`. The `mean` and `stddev` may be scalars or `xy()`s.
  If `radius` is a number, the truncation region is a disk. If
  `radius` is an `xy()`, then the truncation region is an ellipse
  that has those radii along each axis.
  See also `random_gaussian2D()`.


### 3D
`random_direction3D(rng default random)`
: Same as `random_on_sphere()`.

`random_gaussian3D()`
: Same as `random_gaussian3D(xy(0, 0), xy(1, 1), random)`.

`random_gaussian3D(mean, stddev, rng default random)`
: Returns a Gaussian distributed random point on the distribution
  with the given mean and standard deviation. The mean and standard
  deviation may each be scalar or `xyz()` values.
  See also `random_gaussian()`, `random_truncated_gaussian3D()`.

`random_on_cube(rng default random)`
: A random point on the _surface_ of the cube from `(-1, -1, -1)` to `(1, 1, 1)`.

`random_on_sphere(rng default random)`
: Returns a uniformly distributed `xyz()` on the [hollow] sphere with center `(0, 0, 0)` with radius 1. Useful for
  random directions in 3D. See also `random_within_sphere()` and `random_on_circle()`.

`random_within_cube(rng default random)`
: A random point inside the cube from `(-1, -1, -1)` to `(1, 1, 1)`.

`random_within_sphere(rng default random)`
: Returns a uniformly distributed `xyz()` within the unit sphere, that is, the ball with center `(0, 0, 0)` and radius 1.
  Useful for random offsets within a sphere. See also `random_on_sphere()`.

`random_truncated_gaussian3D(mean, stddev, radius, rng default random)`
: Returns a Gaussian distributed random point within `radius`
  of `mean`. The `mean` and `stddev` may be scalars or `xyz()`s.
  If `radius` is a number, the truncation region is a disk. If
  `radius` is an `xyz()`, then the truncation region is an ellipsoid
  that has those radii along each axis.
  See also `random_gaussian3D()`.


Vector
---------------------------------------------------------

Most of the math functions and operators defined for numbers _also_
operate component-wise on vectors represented as structures or arrays.
For example, `clamp()`, `min()`, `+`, `/`, etc.

`angle_to_xy(angle)`
: Returns `xy(cos angle, rotation_sign() * sin angle)`,
  snapping to integer axes if within 10<sup>-12</sup>.

`atan(xy)`
: Returns `atan(vec2.y, vec2.x)`. See also `xy_to_angle()`.

`convex_hull(vertex_array)`
: Returns a new array that is the 2D convex hull of the points in
  `vertex_array`. The original points will be reused, an any
  additional properties (such as `z` values) will be preserved.

`cross(a, b)`
: Return the vector cross product of two arrays of length three each
  or two vectors with `x`, `y`, and `z` properties. For arguments of
  length two or without a `z` component, returns `a.x * b.y - a.y *
  b.x`, which is the 2D wedge product.

`direction(v)`
: `v / magnitude(v)` if the magnitude is greater than
  10<sup>-10</sup>, otherwise returns the original (nearly zero)
  vector. That is, returns a normalized or unit vector unless the
  input is close to zero.

`dot(a, b)`
: Return the dot (inner) product of any two structures or arrays with
  parallel elements.

`equivalent(a, b)`
: Returns true if these vectors have the same size and the elements are
  `==` (does not recursively test if the elements are equivalent).

`find_max_value(v)`
: Returns the key of the _first_ instance of the largest component, or
  `nil` if the array or object is empty. See also `max_value()`

`find_min_value(v)`
: Returns the key of the _first_ instance of the smallest component,
  or `nil` if the array or object is empty. See also `min_value()`.

`magnitude(v)`
: The square root of the sum of the elements (L2 norm).

`magnitude_squared(v)`
: The sum of squares of the elements.

`max_value(v)`
: Largest element. See also `find_max_value()`.

`min_value(v)`
: Smallest element. See also `find_min_value()`.

`perp(v)`
: Returns a vector perpendicular to `v` by rotating it 90 degrees:
  `xy(-v.y, v.x)`, for `xy()` and 2-element array vectors only.

`xy_to_angle(xy)`
: Returns `rotation_sign() * atan(xy)`.

`xy(x, y)`
: Create the object with `x` and `y` properties.

`xy(xy)`
: Returns `{x:xy.x, y:xy.y}`. Useful for removing the `z` component or cloning.
  See also `xy_to_xz()`.

`xy(array)`
: Returns `{x:array[0], y:array[1]}`. Useful for converting from a matrix column.

`xy_to_xz(xy)`
: Returns `{x:xy.x, z:xy.y}`. See also `xz_to_xy()`.

`xz_to_xyz(v, new_z default 0)`
: Returns `{x:v.x, y:v.z, z:new_z}`.

`xz(x, z)`
: Create the object with `x` and `z` properties.

`xz(xz)`
: Returns `{x:xz.x, z:xz.z}`. Useful for removing the `y` property or cloning.

`xz(array)`
: Returns `{x:array[0], z:array[1]}`. Useful for converting from a matrix column.

`xz_to_xy(xz)`
: Returns `{x:xz.x, y:xz.z}`. See also `xy_to_xz()`.

`xz_to_xyz(xz, new_z default 0)`
: Returns `{x:xz.x, y:xz, z:new_z}`. See also `xz_to_xy()`.

`xyz(x, y, z)`
: Create the object with `x`, `y`, and `z` properties.

`xyz(xy, z default 0)`
: Creates `{x: xy.x, xy:y, z}`

`xyz(xz, y default 0)`
: Creates `{x: xz.x, y:y, z:xz.z}`. See also `xz_to_xyz()`

`xyz(xyz)`
: Clones the `xyz` value, stripping any other properties

`xyz(array)`
: Returns `{x:array[0], y:array[1], z:array[2]}`. Useful for
  converting from a matrix column.

`xyz_to_rgb(v)`
: Returns `{r: v.x, g: v.y, b: v.z}`. This does _not_ convert between the XYZ and sRGB
  color spaces.


Function
---------------------------------------------------------

`call(f, a, b, ...)`
: Invoke function `f` with arguments `a`, `b`, etc.



Math
---------------------------------------------------------
`abs(x)`
: Absolute value

`acos(x)`
: Inverse cosine in radians

`atan(y, x)`
: Arctangent of y/x, in radians. See also the version that operates on an `xy()`.

`asin(x)`
: Inverse sine in radians

`cbrt(x)`
: Cube root of `x`. Has the same sign as the argument.

`ceil(x)`
: Return the nearest integer value of `x` towards positive infinity.

`ceil(x, u)`
: Ceil to the nearest multiple of `u` using `ceil(x / u) * u`.

`clamp(x, lo, hi)`
: Clamp `x` to the range [`lo`, `hi`] inclusive.

`clone(v)`
: Return a shallow clone of `v`. For built-in objects and functions returns the
  original object, because they are immutable. For map assets, automatically deep clones
  the 3D layer array/2D XY array.

`copy(s, d)`
: Copy the properties of `s` onto `d`. Both must be arrays or objects.

`cos(x)`
: Cosine, `x` in radians

`deep_clone(v)`
: Return a deep clone of `v`. Pointer structures are preserved (two pointers to the
  same object will be cloned as identical pointers to a different object) and cycles
  are supported. Functions cannot be cloned. Assets and constants can be cloned.

`floor(x)`
: Return the nearest integer value of `x` towards negative infinity.

`floor(x, u)`
: Floor to the nearest multiple of `u` using `floor(x / u) * u`. Can also 
  be applied with the operator syntax `⌊x, u⌋`.

`hash(x, y default ∅)`
: A hash value of string or number `x`, returning a value on [0, 1].
  If `y` is specified, the hash considers the union of the values. Useful 
  for stable procedural generation.

`is_nan(value)`
: Returns true for the floating point not-a-number value
  `nan` and false for all other values.
  Note that you cannot test for `nan` using `==` due to
  floating point nan rules.

`lerp(a, b, t)`
: Returns `a + (b - a) * t`. See also `smoothstep()` and `smootherstep()`.
  See also `perceptual_lerp_color()`. See also `lerp_angle()` and
  the 5-argument version for remapping ranges.

`lerp(a, b, t, t_min, t_max)`
: Returns `a + (b - a) * ((t - t_min) / (t_max - t_min))`,
  linearly interpolating to remap/rescale the range of `t` from
  [`t_min`, `t_max`] to [`a`, `b`]. The 3-argument `lerp()`
  performs `lerp(a, b, t, 0, 1)`.

`lerp_angle(a, b, t)`
: Linear interpolation between angles `a` and `b` by `t`, taking wrapping
  into account and always going the short way. Returns a value between
  `-pi` and `+pi`.

`linstep(t_start, t_end, t)`
: Transition along a line from 0 at `t = t_start` to 1 at `t = t_end`, clamped
  if `t` is outside of that range. All arguments must be numbers.
  Typically used as `lerp(A, B, linstep(lo, hi, t))` where `A` and `B` are colors or points.
  This is linear version of `smoothstep()`.

`log(x)`
: Natural logarithm (base _e_) of `x`, _ln x_ in math notation.

`log2(x)`
: Logarithm base 2 `x`, _lg x_ in math notation.

`log10(x)`
: Logarithm base 10 `x`, _log x_ in math notation.

`loop(x, lo, hi)`
: Handy for making values wrap around. Real-number relative floored modulus. Wraps `x` to the range [`lo`, `hi`). See also `oscillate()`

`loop(x, hi default 1)`
: Handy for making values wrap around. Real-number floored modulus. Wraps `x` to the range [0, `hi`). See also `oscillate()`

`magnitude(x, y, ...)`
: The square root of the sum of the arguments, which must all be numbers.
  Same as `magnitude([x, y, ...])`.

`magnitude_squared(x, y, ...)`
: The sum of the squares of the arguments, which must all be numbers.
  Same as `magnitude_squared([x, y, ...])`.

`make_spline(time_array, value_array, order = 3, extrapolate = "stall")`
: Returns a function mapping numbers to values by piecewise polynomial
  interpolation. The value array must have types for which `*` and `+`
  operate (which includes numbers, all objects, `xy()`, `xyz()`, `rgb()`, and
  `rgba()` values), and all elements of the `value_array` must have
  the same type. The spline is always interpolating. The `time_array`
  and `valueArray` must have the same length.

  `order`:
  - `0` = nearest-neighbor interpolation
  - `1` = linear (polyline) interpolation
  - `3` = cubic (Catmull-Rom) spline interpolation

  `extrapolate`:
  - `"loop"` = cyclic. The `time_array` must have one more element than the `value_array`.
     That final value is the looped time that matches the start time. Similar to OpenGL
     `GL_REPEAT` mode for textures.
  - `"clamp"` = hold the final value. Similar to OpenGL `GL_CLAMP` texture mode.
  - `"stall"` = interpolate to additional control points that match the final value.
     Unlike clamping, for a cubic curve this will ensure that the velocity smoothly
     ramps to zero rather than creating a sharp corner.
  - `"oscillate"` = treat like looping with twice the period, reversing direction.
    This is similar to OpenGL `GL_MIRROR` texture mode.
  - `"continue"` = continue the curve with the trend of the final control points

`max(a, b, ...)`
: Largest of the arguments

`min(a, b, ...)`
: Smallest of the arguments

`mid(a, b, c)`
: Middle argument once sorted. Can be used for clamping.

`noise(octaves, v)`
: Applies `noise()` to an `xy()`, `xyz()`, or array position.

`noise(octaves, x, y default 0, z default 0)`
: Value noise on the range [-1, 1], bicubically interpolated between integer locations at
  octave 0. Unused dimensions default to zero.

`oscillate(x, m)`
: Deprecated. `oscillate(x, 0, m)`.

`oscillate(x)`
: `oscillate(x, 0, 1)`

`oscillate(x, lo, hi)`
: Like `loop` but alternately counts up and down on the interval
  [`lo`, `hi`], including both ends. Works with negative and fractional values.
  Let `k = 2 m - 2; w = loop(x, k)`.
  `oscillate(x, m)` is `w` if `w < m`, otherwise it is `k - w`.

`pass_through(x)`
: Returns its argument. Convenient in cases where a function is needed that 
  does nothing, when mapping or filtering arrays. Not named `identity` to avoid 
  confusion with the constructor for identity matrices.

`pow(a, b)`
: Exponent. See also the `^` operator.

`round(x)`
: Return the nearest integer value of `x`. Half-integers round towards positive infinity.

`round(x, q)`
: Return the nearest value of `x` quantized to `q`. 
  If `q` is zero then no rounding occurs. Otherwise, `round(x, q) == round(x * q) / q`.

`sign(x)`
: Sign of `x`. Returns -1 if `x` is less than zero, -0 if `x` is -0,
  +0 if `x` is +0, and +1 if `x` is greater than zero.

`sign_nonzero(x)`
: Returns -1 if `x` is less than zero, otherwise returns +1.

`smoothstep(t_start, t_end, t)`
: Transition from 0 at `t = t_start` to 1 at `t = t_end`, 
  clamping if `t` is outside of that range. All arguments must be numbers.
  Typically used as `lerp(A, B, smoothstep(lo, hi, t))` where `A` and `B` are colors or points.
  This is a common graphics function for cubic Hermite interpolation. See also
  the [GLSL documentation](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml),
  `smootherstep()`, and `linstep()`.

`smootherstep(t_start, t_end, t)`
: Transition from 0 at `t = t_start` to 1 at `t = t_end` with more
  gradual acceleration than `smoothstep`. All arguments must be
  numbers.  Typically used as `lerp(A, B, smootherstep(lo, hi, t))`
  where `A` and `B` are colors or points. This is a common graphics
  function for fifth-order interpolation.

`sqrt(x)`
: Square root.

`sin(x)`
: Sine of `x` radians.

`tan(x)`
: Tangent of `x` radians.


`x`               |  -5  |  -4  |  -3  |  -2  |  -1  |  0  |  1  |  2  |  3  |  4  |  5  |  6
------------------|-----:|-----:|-----:|-----:|-----:|----:|----:|----:|----:|----:|----:|-----:
`clamp(x, 0, 4-1)`|  0   |  0   |   0  |   0  |   0  |  0  |  1  |  2  |  3  |  3  |  3  |  3
`x mod 4`         |  -1  |  0   |  -3  |  -2  |  -1  |  0  |  1  |  2  |  3  |  0  |  1  |  2
`loop(x, 4)`      |  3   |  0   |   1  |   2  |   3  |  0  |  1  |  2  |  3  |  0  |  1  |  2
`oscillate(x, 4)` |  1   |  2   |   3  |   2  |   1  |  0  |  1  |  2  |  3  |  2  |  1  |  0
[Table [tblCompare]: Comparison of range restriction functions useful for animation.]

Input
-----------------------------------------------------------

### Gamepads

The gamepad objects in the four-element `gamepad_array` each have
the following properties:

Property                   | Values   | Meaning
---------------------------|----------|----------------------------------
`gamepad.index`            | 0,1,2,3  | Index of this gamepad in `gamepad_array`. The player name is `"P" + (gamepad.index + 1)`
`gamepad.player_color`     | rgb      | Color identifying this player (not the color of the gamepad itself)
`gamepad.x`                | -1,0,+1  | D-pad value on the _x_-axis at the start of the current frame frame
`gamepad.xx`               | -1,0,+1  | If the D-pad moved from the center to a side on the _x_-axis at any time between the previous and current frame, this is the side that it moved to. When it hit both extremes, the last one is returned.
`gamepad.x_frames`         | number   | Number of frames that `x` has had the current value, 0 if it just changed this frame
`gamepad.dx`               | -2,-1,0,+1,+2 | Change in value of `x` between the previous and current frames on the _x_-axis
`gamepad.y`                | -1,0,+1  | D-pad value on the _y_-axis at the start of the current frame
`gamepad.yy`               | -1,0,+1  | If the D-pad moved from the center to a side on the _y_-axis at any time between the previous and current frame, this is the side that it moved to.  When it hit both extremes, the last one is returned.
`gamepad.y_frames`         | number   | Number of frames that `y` has had the current value, 0 if it just changed this frame
`gamepad.dy`               | -2,-1,0,+1,+2 | Change in value of `y` between the previous and current frames
<code>gamepad.xy</code>    | xy       | `xy(x, y)` for the gamepad
`gamepad.dxy`              | xy       | `xy(dx, dy)` for the gamepad
`gamepad.angle`            | -π to +π | `rotation_sign() * atan(y, x)` if both `x` and `y` are not zero, otherwise the last angle
`gamepad.dangle`           | -π to +π | Change in `angle` this frame
`gamepad.a`                | number   | The number of frames the ⓐ button has been held down, 0 if it was not held down at the start of the current frame
`gamepad.pressed_a`        | number   | Nonzero if the ⓐ button went from up to down at least once since the previous frame.
`gamepad.released_a`       | number   | Number of frames the ⓐ button was down if it went from down to up at least once since the previous frame, otherwise 0
`gamepad.b`                | number   | The number of frames the ⓑ button has been held down, 0 if it was not held down at the start of the current frame
`gamepad.pressed_b`        | number   | Nonzero if the ⓑ button went from up to down at least once since the previous frame
`gamepad.released_b`       | number   | Number of frames the ⓑ button was down if it went from down to up at least once since the previous frame, otherwise 0
`gamepad.c`                | number   | The number of frames the ⓒ button has been held down, 0 if it was not held down at the start of the current frame
`gamepad.pressed_c`        | number   | Nonzero if the ⓒ button went from up to down at least once since the previous frame
`gamepad.released_c`       | number   | Number of frames the ⓒ button was down if it went from down to up at least once since the previous frame, otherwise 0
`gamepad.d`                | number   | The number of frames the ⓓ button has been held down, 0 if it was not held down at the start of the current frame
`gamepad.pressed_d`        | number   | Nonzero if the ⓓ button went from up to down at least once since the previous frame
`gamepad.released_d`       | number   | Number of frames the ⓓ button was down if it went from down to up at least once since the previous frame, otherwise 0
`gamepad.e`                | number   | The number of frames the ⓔ button has been held down, 0 if it was not held down at the start of the current frame
`gamepad.pressed_e`        | number   | Nonzero if the ⓔ button went from up to down at least once since the previous frame
`gamepad.released_e`       | number   | Number of frames the ⓔ button was down if it went from down to up at least once since the previous frame, otherwise 0
`gamepad.f`                | number   | The number of frames the ⓕ button has been held down, 0 if it was not held down at the start of the current frame
`gamepad.pressed_e`        | number   | Nonzero if the ⓕ button went from up to down at least once since the previous frame
`gamepad.released_f`       | number   | Number of frames the ⓕ button was down if it went from down to up at least once since the previous frame, otherwise 0
`gamepad.q`                | number   | The number of frames the ⓠ button has been held down, 0 if it was not held down at the start of the current frame
`gamepad.pressed_q`        | number   | Nonzero if the ⓠ button went from up to down at least once since the previous frame
`gamepad.released_q`       | number   | Number of frames the ⓠ button was down if it went from down to up at least once since the previous frame, otherwise 0
<code>gamepad.type</code>  | string   | The type of gamepad, as autodetected based on serial number or overriden by the player
`gamepad.prompt`           | `{...}`  | An object mapping button names to text prompts for use with `replace()`. See the example below.
`gamepad.status`           | string   | `"absent"` before any interaction this game on this gamepad. `"present"` if local interaction has occurred and not playing an online game. `"host"` if the host in an online game. `"guest"` if a guest in an online game. Starting or stopping online hosting/guesting resets to `"absent"`.
`gamepad.online_name`      | string   | Name of the computer this gamepad is connected to. Useful primarily for online play.

!!! 
    Use the single-letter gamepad properties (e.g., `x`, `a`) for
    continuous inputs such as aiming or charging. Use
    double-letter properties (e.g., `xx`, `aa`) for discrete inputs such as
    firing or choosing a menu option. Use the frame counter
    in (e.g., `x_frames`, `a`, `touch.a`) for cooldowns and
    button repeats.

!!! 
    Use `sign(gamepad.a)` etc. if you want to force the value to 1
    or 0 for a computation. For branching there is never a need to convert
    to a boolean because 0 = `false` and nonzero = `true` for 
    statements such as `if gamepad.a:`.


If a button is pressed and released very quickly, then `a` could be 0
for two frames in a row, because at the time that the frame runs it
will be in the released state. However, `aa` will be nonzero for a frame in
that case, so that the button press will not be missed. (Due to
technical limitations of web browsers, there is a very small chance
that `aa` will not capture a button press that is less than 1/60s on a
physical gamepads.  Our testing determined that fastest most people
and gamepads can switch is about 1/45s, which is under this threshold.
The gamepad will always capture button presses on keyboard.)

The `xx` and `yy` values record the last change in value from zero
between frames.  It is theoretically possible for the D-pad to move so
fast that it encounters along the x-axis values of 0, -1, 0, 1, 0 in
that order between frames. If this is the case, then the `xx` property
will only record the last non-zero that was switched to. So, this
scenario would yield `x=0`, `xx=+1`, and `dx=0`. (On a physical
gamepad, any given value that is held for less than 1/60s could be
missed. Again, this is extremely unlikely because of the timescales
involved.)

The axes are affected by the current transformation _at the time that
they are read by your program_, as set by `set_transform()`. Reading
the same property twice with a transform change in between can change
the sign of the value. The angles are always clockwise in screen
space.


`any_button_press(gamepad_or_touch default ∅)`
: Returns true if any button on `gamepad_or_touch` was just pressed.
  If `gamepad_or_touch` is `nil`, returns true if any button on any
  gamepad was pressed or there was any touch pressed.

`any_button_release(gamepad_or_touch default ∅)`
: Returns true if any button on `gamepad_or_touch` was just released.
  This is useful on main menus to ensure that the button is no longer
  held at the end of the mode.
  If `gamepad_or_touch` is `nil`, returns true if any button on any
  gamepad was released or there was any touch released.

`joy`
: A variable equal to `gamepad_array[0]` as shorthand for
  single-person games.

`gamepad_array[]`
: The array of all gamepads. Regardless of how many physical controllers are
  connected, there are always four elements.

### Button Prompts

The `prompt` property of a `gamepad_array[]` value is to be used with `replace()` to
create strings for showing controls and button prompts to players with
`draw_text()`.  

It maps `"ⓐ"`, `"ⓑ"`, `"ⓒ"`, `"ⓓ"`, `"ⓔ"`,`"ⓕ"`, `"ⓟ"`, `"ⓠ"`,
`"⍐"`, `"⍗"`, `"⍇"`, and `"⍈"` as well as ASCII aliases `"(a)"`,
`"(b)"`, `"(c)"`, `"(d)"`, `"(e)"`, `"(f)"`,`"(p)"`, `"(q)"`, `"[^]"`, `"[v]"`,
`"[&lt;]"`, and `"[&gt;]"` to the appropriate button prompts. 
It maps `"##"` to the 1-based player number.

These can be used to describe
controls to players in a way mapped to the physical controller they
are currently using instead of the <quadplay/> native controls

For example, `replace("Player ## press (a) to jump", gamepad_array[0].prompt)` creates a
string with the proper physical button label for the first player's
primary button substituted for the string `"(a)"`. On a PlayStation
controller, this string will be `"Player 1 press ⓧ to jump"`. On an Xbox
controller, it will be `"Player 1 press ⓐ to jump"`.  For a player using the
keyboard, it will be `"Player 1 press ␣ to jump"`. 

The value of `gamepad_array[].prompt` can change during the game if
the player uses the system menu to change the control scheme, so you
should always generate the string right before drawing it instead of
at program start.

The `gamepad_array[i].type` property describes the control scheme used for
the prompts.


### Touch

<quadplay/> provides single-touch and single-button mouse input via
virtual touch screen. Not all <quadplay/> devices support touch input
(although most do, through a touch screen, stylus, or
mouse).

`touch`
: There is a single `touch` global object with the following properties:

Property                 | Type     | Meaning
-------------------------|----------|----------------------------------
`touch.x`                | number   | Camera-space x position
`touch.y`                | number   | Camera-space y position
`touch.dx`               | number   | Change in `x` since the previous frame
`touch.dy`               | number   | Change in `y` since the previous frame
`touch.xy`               | xy       | `xy(touch.x, touch.y)`
`touch.dxy`              | xy       | `xy(touch.dx, touch.dy)`
`touch.a`                | number   | Number of frames that the touch has been held down, or 0 if not currently down
`touch.pressed_a`        | number   | Nonzero if the touch started this frame
`touch.released_a`       | number   | Nonzero if the touch ended this frame
`touch.screen_x`         | number   | Screen-space x position
`touch.screen_y`         | number   | Screen-space y position
`touch.screen_dx`        | number   | Change in `screen_x` since the previous frame
`touch.screen_dy`        | number   | Change in `screen_y` since the previous frame
`touch.screen_xy`        | xy       | `xy(touch.screen_x, touch.screen_y)` for the touch
`touch.screen_dxy`       | xy       | `xy(touch.screen_dx, touch.screen_dy)` for the touch
`touch.hover`            | xy       | If the device supports hovering _and_ the hover moved this frame, the camera-space position of the hover. Otherwise `nil`.

The `x` and `y` values are in camera-space coordinates using the current transform.
Change or reset the transform to read them in a different coordinate system, or use
the transformation routines.

If there is no active touch, then the coordinates reflect the previous
active touch location.  There is no way to track 
a scroll wheel or second mouse button with `touch`. 
`device_control()` allows low-level access to
additional device-specific properties for a mouse or other pointing device.


### Main Menu

The system pause menu is bound to the ⓟ button, which is not visible to games.
Games can add up to three custom elements on the pause menu, and can change these
at any point.

`set_pause_menu(opt1 default ∅, opt2 default ∅, opt3 default ∅)`
: Override the custom elements on the pause menu. Each argument
  is an object of the form `{text:string, callback:function, confirm:boolean}`.
  At 64x64 resolution, specifying `opt3` disables the automatic game
  credits option in the pause menu.

  - `text` is the menu item text. It will be clipped if too long.
  - `callback` is a function of no arguments to execute when this option is selected.
  - `confirm` (defaults to `false`) if true, is an additional confirmation dialog
    appears when this option is selected. If a non-empty string, displays that
    string as an additional message on the confirmation dialog.


### MIDI

<quadplay/> supports MIDI on all platforms except for macOS
Safari. Other browsers on macOS support MIDI. The global `midi` object
has the following properties:
  
`midi.input_port_array`
: Array of all input ports. Updated whenever devices are added or
  removed at runtime, preserving ordering. The input ports have state
  that can be polled similarly to a game pad (see below for `note` and
  `controller`).
  
`midi.output_port_array`
: Array of all output ports. Updated whenever devices are added or
  removed at runtime, preserving ordering. The output ports may be
  used with `midi_send_raw()`.
  
`midi.message_queue`
: The message queue array contains all incoming MIDI messages received
  since the previous frame, in the order that they were
  received. Messages are not tracked until the first time that the
  `midi` object is accessed, so the queue will initially be
  empty even if the MIDI input device was in use before the program
  checked it.

In the `midi.message_queue`, each message has the form `{type: string,
port: port, raw: [...], ...}`, where the `type` determines the other
properties. The most common messages are `"NOTE_ON"`, which has
`channel`, `note` and `velocity` properties; and `"NOTE_OFF"`, which
has `channel` and `note` properties. The `raw` property is the
underlying 1-3 byte MIDI message. Most devices send `"NOTE_ON"` with
velocity zero instead of `"NOTE_OFF"` to enable the
[running status compression hack](https://www.euclideanspace.com/art/music/midi/codes/index.htm).

All ports have:

`port.id`
: Device's integer ID (which may be negative), which will be the ID of the adapter if the device
  is not natively using USB

`port.name`
: Device's name, which will be the name of the adapter if the device
  is not natively using USB
  
`port.manufacturer`
: Device's manufacturer, which will be the manufacturer of the adapter if the device
  is not natively using USB
 
`port.state`
: `"connected"` or `"disconnected"`

`port.type`
: `"input"` or `"output"`

The input ports contain `note[]`
and `controller[]` 128-element arrays that are aggregated across all
channels, and a `channel[]` 16-element array for which each element
has its own `note[]` and `controller[]`. This provides convenient
access for simpler devices that do not take advantage of channels
(such as an 88-key piano keyboard or 16-pad drum pad), as well as the
full state of all 4096 input elements possible for each port if
needed. For the purpose of these, `"NOTE_ON"` with zero velocity
is treated as equivalent to `"NOTE_OFF"`.

Each `note[]` element has the following fields:

`note.on`
: The number of frames the note has been held down, 0 if
  it was not held down at the start of the current frame
  
`note.pressed`
: Nonzero if the note went from off to on at least once
  since the previous frame
    
`note.released`
: Number of frames the note was on if it went from on
  to off at least once since the previous frame, otherwise 0

`note.velocity`
: Velocity with which the note was last turned on.
    
`note.pressure`
: Last recorded pressure. This generally counts up
  continuously from 0 while a note is held at constant pressure, and
  then down when the pressure is reduced.

Controllers are generally mapped to knobs and faders and notes are
mapped to (pressure sensitive) pads or keys. Each `controller[]`
element has the following properties:

`controller.value`
: Current value

`controller.delta`
: Change since last frame of value


The MIDI send command is:

`midi_send_raw(port, raw_message_array)`
: The `port` must be one of the output ports from the `midi` object.
  The message must be an array of integers according 
  to the [MIDI message format](https://www.songstuff.com/recording/article/midi_message_format/).
  The return value is either `"ok"` or an error message string.

  The common messages are:

  Message          | Array
  -----------------|--------------------------------
  `NOTE_ON`        | `[0x90 + channel, note, velocity]`
  `NOTE_OFF`       | `[0x80 + channel, note]`
  `CONTROL_CHANGE` | `[0xB0 + channel, controller, data]`

  Where `channel` is an integer 0-15, and `note`, `velocity`, and
  `controller` are integers 0-127.

         --------------------------------

<quadplay> supports MIDI input and output of connected devices. Unlike
the gamepads and display I/O, no MIDI devices are guaranteed to be
present. MIDI input can route footswitches, drum pads, piano keyboard,
MIDI guitars, faders, and other devices as controllers for a
game. MIDI output can drive synthesizers, audio FX units, and
MIDI-controlled amplifiers, and when paired with a MIDI-DMX bridge can
control party lights, fans, smoke machines, and other physical
objects. 

Together these are a great way to use <quadplay> for music projects,
as well as providing creative input and output devices for everything
from rhythm games to escape rooms.

Some relatively inexpensive, highly rated MIDI input (and in some
cases, RGB button output) devices are:

- [Donner Starrypad](https://www.amazon.ca/Donner-Maker-Assignable-Controller-STARRYPAD/dp/B01GYK2CKK) about US$50, has key velocity
- [AKAI APC Mini Mk2](https://amzn.to/3Ne2UQK) about US$90, [RGB lights protocol](https://cdn.inmusicbrands.com/akai/attachments/APC%20mini%20mk2%20-%20Communication%20Protocol%20-%20v1.0.pdf)
- [Behringer X-Touch Mini](https://amzn.to/3Ne2Lga) about US$100
- [AKAI MPKmini](https://amzn.to/42owKpK) about US$100
- [Novation Launchpad Mini Mk3](https://amzn.to/3CgZbeQ) about US$100, [RGB light protocol](https://www.djshop.gr/Attachment/DownloadFile?downloadId=10737), has square buttons
- [Novation Launchpad X](https://amzn.to/43sZlLY) about US$160, [RGB light protocol](https://www.djshop.gr/Attachment/DownloadFile?downloadId=10737), has key velocity, has square buttons
- [Behringer FCB1010 Foot Controller](https://amzn.to/42xEJ3P) about US$160; see [Morgan's notes](https://morgan3d.github.io/articles/2023-06-22-fcb1010/index.html) to use this device

Many MIDI devices directly support USB and Bluetooth for connecting to
a computer. Others use MIDI 5-pin or either 1/8" phono (headphone)
cables and require a USB adapter, such as:

- [FORE MIDI-to-USB adapter](https://amzn.to/3C96dlI) about US$20 (Note that its MIDI connectors are labelled backwards)
- [M-Audio MIDI-to-USB adapter](https://amzn.to/42vT9BS) about US$35

MIDI devices generally don't need drivers on macOS or Windows.

DMX devices and converters are more expensive than straight MIDI
ones. Here are a few interesting examples chosen without considering reviews:

- [DOREMiDi USB MIDI-to-DMX MTD-1024](https://www.doremidi.cn/h-pd-80.html) about US$90
- [DecaBox MIDI-to-DMX](https://www.amazon.ca/DecaBox-MIDI-to-DMX-Converter/dp/B00N36JQG2) about US$300
- [Colored light bar](https://amzn.to/3qssbxD) about US$70
- [Fog and light machine](https://amzn.to/42vSWP6) about US$130
- [Effects fan](https://amzn.to/3WRwsa3) about US$450
- [Flamethrower](https://amzn.to/3WYJdPZ) about US$450

For playing music, the frequency of MIDI note $n$ is $f =
440~\operatorname{Hz} \cdot 2^{(n - 69) / 12}$. 

$n=0$ is at 8.18 Hz, below the range of human
hearing. It corresponds to the C two octaves below C1.
$n=24$ is C1 at 32.70 Hz, the lowest pitched note on a full
piano. $n=60$ corresponds to middle C4 at 261.63 Hz.
$n=108$ is C8 at 4,186.01 Hz, the highest pitched note on a
full piano. $n=127$ is G9 at 12,543.85 Hz, the highest note in MIDI
and about half of the highest frequency (i.e., one octave) below the
highest note in the range of human hearing.

Protocol specifications for some common MIDI controllers are:
 - [Launchpad Mini Mk3](https://www.djshop.gr/Attachment/DownloadFile?downloadId=10737)
 - [Launchpad X](https://fael-downloads-prod.focusrite.com/customer/prod/s3fs-public/downloads/Launchpad%20X%20-%20Programmers%20Reference%20Manual.pdf)
 - [Ableton Push](https://github.com/Ableton/push-interface)
 - [AKAI APC Mini Mk2](https://cdn.inmusicbrands.com/akai/attachments/APC%20mini%20mk2%20-%20Communication%20Protocol%20-%20v1.0.pdf)
   
For example, setting the color of
each LED to match a sprite on a Novation Launchpad device is:
  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Pyxlscript
def launchpad_show_sprite(sprite):
    // Apply gamma and map floating point to 7-bit unsigned normalized fixed point [0, 127] interval
    def map(v): return MIN(0x7F, FLOOR(MUL(0x80, MUL(v, v))))

    const msg = [0xF0, 0x00, 0x20, 0x29, 0x02, 0x0D, 0x03]
    const c = #0000
    const pos = xy(0, 0)
    
    // To access the 9th row and column of control buttons,
    // extend these loops one further. The indexing is consistent
    for x < 8:
        for y < 8:
            pos.x = x; pos.y = 7 - y
            sprite_pixel_color(sprite, pos, c)
            msg.push(0x03, (x + 1) + 10 (y + 1), map(c.r), map(c.g), map(c.b))
    push(msg, 0xF7)

    midi_send_raw(port, msg)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To reduce permission dialogs for the player, MIDI is only available if
the source code explicitly references an object or property directly
on the `midi` object by name at least once. Exclusively renaming or
passing the `midi` object as an argument and then accessing properties
of it by another name will not trigger the initialization correctly.


Modes
------------------------------------------------------------------------


`get_previous_mode()`
: Return the previous mode, or `nil` if there was no previous
  mode. When returning to a mode via `pop_mode()`, the previous mode
  is the mode from which _that_ one was entered; they are on a stack.

`get_mode()`
: Return the current mode. This can be passed to hook functions or
  compared against mode names, but not to `set_mode`, which requires an
  explicit mode name. during mode initialization, `get_mode()` returns `nil`.

`pop_mode()`
: Go back to the previous mode that invoked `push_mode`, restoring the
  draw calls and `mode_frames` as of that point. It is a runtime error
  to invoke `pop_mode()` when the mode was not entered from
  `push_mode()`. Invokes the `leave` section of the current mode but
  not the `enter` section of the mode being returned to.

`push_mode(Mode, ...)`
: Enter a new mode but remember the current mode. Combines their draw calls
  for `draw_previous_mode()`. Useful for modal dialogs, such as pause screens,
  inventory screens, and dialogue. Does not invoke the `leave` section of
  the current mode. Does invoke the `enter` section of the mode being entered.
  Any arguments after the `Mode` are passed to the `enter` section.

`pause_menu(choice default nil)`
: Immediately enter the pause menu mode, as if the player had pressed P. If `choice` is
  not nil, then that mode is selected directly from the pause menu. Accepted values
  for `choice` are:

  - `"Online"`
  - `"Online -> Guest"`
  - `"Credits"`
  - `"Controllers"`

  When control returns to the mode, it is through the `pop_mode` event.

`quit_game()`
: Quit the game and exit to the IDE or the launcher, or close the tab depending on
  what the `quit` HTML query parameter was set to. Note that games do not
  form a stack. Quitting a game returns to the built-in <quadplay/> launcher or
  IDE, and not the game that launched it.

`reset_game()`
: Reset the game, restoring all assets and starting again from the
  initial mode.

`set_mode(Mode, ...)`
: Immediately switch to the new mode. The current mode stops executing and the new
  mode begins.

  The mode name must be the literal name of the mode, not a variable,
  a value from a data structure, or the return value of the function.

  If the note is present, it must likewise be a string literal and not
  an expression.  The note is a comment that is used by the IDE for
  creating state machine diagrams and in the IDE for debugging. It has
  no effect on the executing program.

  Erases the `push_mode` stack but remembers its draw calls.
  Any arguments after the `Mode` are passed to the `enter` section.

When changing modes via `set_mode()`, the order of operations is:

1. `get_previous_mode()` switches to the current mode,
   `get_mode()` switches to the _new_ mode.
2. The _previous_ mode's graphics commands are captured for future
   `draw_previous_mode()` calls.
3. Any `leave` code executes on the _previous_ mode.
4. `mode_frames = 0`,
5. Any `enter` code executes on the _new_ mode and arguments supplied.


Sound
---------------------------------------------------------

The sound object has a single property, `sound.duration`, which is the number
of seconds that it will play before ending or looping.

`get_audio_status(audio)`
: Returns an object describing the current properties of this audio object:
  - `pitch`
  - `volume`
  - `playback_rate`
  - `pan`
  - `loop`
  - `state`: `"PLAYING"`, `"STOPPED"`, or `"ENDED"`
  - `sound`: the sound being played in this audio clip
  - `now`: Time since the start of the sound, measured seconds.
     This is useful for synchronizing visuals with audio. 
    Audio follows a more strict clock than the mode's frame
    event, the `mode_frames` value, and the `game_frames` values, which 
    run in 1/60 second increments but may drift slightly due to computational
    demands. Graphics are time scaled, so the visual frames may be independent
    of both the audio clock and the frame events.

`play_sound(sound, volume default 100%, pan default 0%, pitch default 100%, time default 0, playback_rate default 100%, loop default false, stopped default false)`
: Play `sound`, which must have been loaded as an asset. The time
  is in seconds. Full pan left is `-100%` and full pan right is `100%`.
  Returns an audio object that can be used with `stop_audio()`.
  
  If `pan` is an `xy()` value, it is interpreted as a world space point
  and the pan is computed based on the fraction of `SCREEN_SIZE`
  under the current transformation and camera. Note that if `set_screen_size()`
  is used with `private_views = true`, `xy()` pan values will produce
  incorrect audio. Set an explicit pan number in that case.
  
  If `stopped` is true, the sound initially starts in the `"STOPPED"` mode
  and can be restarted with `resume_audio()`. Useful for setting up loops
  that do not play immediately.

`play_sound(args)`
: Object version of `play_sound()`, allowing keyword argument style call.
  Values default according to the positional argument version.

`resume_audio(audio)`
: Resume a sound previously stopped with `stop_audio()`. Sets the state to `"PLAYING"`.

`set_pan(audio, pan)`
: Set the pan of an audio object that is currently playing. 0% is centered.
  -100% is full left, 100% is full right. 
  
  If `pan` is an `xy()` value, it is interpreted as a world space point
  and the pan is computed based on the fraction of the screen
  under the current transformation and camera.

`set_pitch(audio, pitch)`
: Set the pitch (in relative Hz) of an audio object that is currently playing without
  affecting speed. 100% is the default pitch from the file.  200% is
  one octave higher, 50% is one octave lower.
  
  To instead set the pitch in musical cents where 100 cents = 1
  semitone = 1 half-step, use: `set_pitch(audio, 2^(cents / 1200))`.

`set_volume(audio, volume)`
: Set the volume of an audio object that is currently playing. 100% is the default volume from the file.

`set_playback_rate(audio, rate)`
: Set the rate of an audio object that is currently playing, affecting both speed and pitch. 100% is the default rate from the file.

`stop_audio(audio)`
: Stop playing `audio`, which was created with `play_sound`. Sets the state to `"STOPPED"`.

`stop_audio(nil)`
: Does nothing. This is provided because it is often convenient to stop background
  sound if there is one on entering a mode and do nothing if there is no background
  sound value in a variable, e.g., `stop_audio(background_audio)`


Coordinate Systems
-----------------------------------------------------------

The <quadplay/> default coordinate system places the origin at the
upper-left corner of the screen, with the y-axis facing down, 0° to
the right, 90° upwards, and the z-axis out of the screen.

************************************************************
*  2048 (out of the screen)
*    ^
*     \  z
*      \
*       \0            x
*        *----------------------->* SCREEN_SIZE.x
*        |\                       |
*        | \                      |
*        |  \                     |
*     y  |   v                    |
*        |     -2047              |
*        v                        |
*        *------------------------*
*   SCREEN_SIZE.y
***********************************************************
[Figure [coords]: Default quadplay coordinate system.]

The z-axis is used for 3D perspective via the `camera.zoom`, 
isometric 3D via `transform.skew`, and for z-ordering so that closer
objects occlude more distant ones in z. The z-ordering can be separated
from the perspective and isometric aspect for certain special effects
when desired.

This is only the default. <quadplay/> allows you to choose the most
convenient 2D coordinate system for your game, and to change it
throughout the game code as needed. See the [Coordinate Systems](../console/quadplay.html?game=quad://examples/coordinate_system&IDE=1)
example for a visualization of some options.

Angles *always* increase counter clockwise,
nd 0° is always along the x-axis. The orientation of 90° depends
on the y-axis, however.

Sprites always render consistently regardless of transformation.
Their position is affected by the transformation.
They can be rotated by the `set_camera()` or the `angle` argument to
`draw_sprite()`. They can be flipped by the `scale` argument to
`draw_sprite()`.

Font characters are always rendered without rotation or scaling.
The position of a text string is affected by the transformation.

Functions `up_y()`, `rotation_sign()`, `xy_to_angle()`, `angle_to_xy()`,
and `get_transform()`, and the `preserving_transform:` block
help with writing transformation-independent libraries.
 
<quadplay/> transforms also support skew for isometric 3D,
limited support for 3D `xyz()`, and `xz()` coordinates for bookkeeping.
 
Advanced users can use `set_transform()` and `set_camera()` to produce separate
world space, camera space, and screen space coordinate systems from
this default, including scale and rotation.

Almost all standard library functions take arguments in world space.
This includes drawing routines, intersection routines, and the properties
of entities without parents. The functions that don't use world space
are obvious, since what they do requires another space. 

The full set of coordinate systems supported by the standard library are:

- *screen* space (ss)
- *camera* space (cs)
- *world* space (ws)
- *entity* space (es) 
- *sprite* space - pixels within in a sprite
- *map* space - indices of sprites in a map
<!-- - *spritesheet* space - indices of sprites in a spritesheet -->

Entities can also form hierarchies using the `entity.child_array`. The
first four coordinate systems are related by:

<style>
table.coord {
  text-align: center;
  margin-left: auto;
  margin-right: auto;
  width: 80%;
  border-collapse: separate;
}

table.coord th { font-weight: normal; font-style: italic; padding-bottom: 10px }
table.coord tr:not(.space) td:first-child,
table.coord tr:not(.space) td:nth-child(4) {font-size: 80%;}
table.coord tr.space { background: #555; }
table.coord tr.space td { padding-top: 4px; padding-bottom: 4px; }
table.coord tr.space td:first-child { border-radius: 8px 0px 0px 8px}
table.coord tr.space td:last-child { border-radius: 0px 8px 8px 0px}
table.coord td.arrow { line-height: 80%; font-size: 120%; color: #555}
</style>


<table class="coord">
<tr class="space"><td colspan=4>  Screen Space (ss)      </td><td>_Used by_: `set_clip()`, `reset_clip()`, `get_clip()`,
                                                                   `intersect_clip()`, `set_post_effects()`, `get_post_effects()`     </td></tr>

<tr><td>`transform_cs_to_ss()`</td>
    <td class="arrow" width=10>▲<br>┃<br>┃<br>┃<br>┃</td>
    <td class="arrow" width=10>┃<br>┃<br>┃<br>┃<br>▼</td>
    <td>`transform_ss_to_cs()`</td>
                                                        <td colspan>_Controlled by_: `y_up` in game.json,
                                                         `set_transform()`, `reset_transform()`, `compose_transform()`,
                                                        `get_transform()`       </td></tr>

<tr class="space"><td colspan=4>  Camera Space (cs)        </td><td>_Used by_: `touch`, `joy`, `gamepad_array[]`, `text_width()`  </td></tr>

<tr><td>`transform_ws_to_cs()`</td>
    <td class="arrow" width=10>▲<br>┃<br>┃<br>┃<br>┃</td>
    <td class="arrow" width=10>┃<br>┃<br>┃<br>┃<br>▼</td>
    <td>`transform_cs_to_ws()`</td> 
                                                        <td>_Controlled by_: `set_camera()`, `reset_camera()`, `get_camera()`</td></tr>


<tr class="space"><td colspan=4>  World Space (ws)      </td><td>_Used by_: `draw_sprite()`, `draw_line()`, `draw_map()`, `draw_entity()`,
                                                                 `draw_text()`, `draw_point()`, `ray_intersect()`, `overlaps()`, etc.</td></tr>

<tr><td>`transform_es_to_ws()`</td>
    <td class="arrow" width=10>▲<br>┃<br>┃<br>┃<br>┃</td>
    <td class="arrow" width=10>┃<br>┃<br>┃<br>┃<br>▼</td>
    <td>`transform_ws_to_es()`</td>                    <td>_Controlled by_: `entity.pos`, `entity.angle`, `entity.scale`</td></tr>

<tr class="space"><td colspan=4> Entity Space (es)    </td><td>                         </td></tr>

<tr><td>`transform_to_parent()`</td>
    <td class="arrow" width=10>▲<br>┃<br>┃<br>┃<br>┃</td>
    <td class="arrow" width=10>┃<br>┃<br>┃<br>┃<br>▼</td>
    <td>`transform_to_child()`</td>
                                                        </td><td>`entity.pos_in_parent`,
                                                        `entity.angle_in_parent`,
                                                        `entity.scale_in_parent`    </td><td>                         </td></tr>

<tr class="space"><td colspan=4> Child Entity Space      </td><td>                            </td></tr>
<tr><td></td><td class="arrow">▲<br>┃<br>&vellip;</td>
<td class="arrow">┃<br>&vellip;</td><td></td><td>                            </td></tr>

</table>

To simplify common game programming tasks and avoid certain kinds of mistakes,
quadplay has some differences from traditional graphics systems under coordinate
system transformations:

- Angles are always measured counter-clockwise, and routines automatically 
  change their angle direction to compensate. Use `rotation_sign()` to
  determine the current direction when using `sin()` and `cos()` to convert
  an angle to a vector.
  
- Sprites automatically flip vertically to match when the y axis is inverted.

- The anchor points for text will transform, but font characters are never
  rendered with scale or rotation because pixel fonts are generally unreadable if
  transformed and upside-down fonts are rarely what is intended when flipping an axis.
  Convert your text to a sprite if you want transformed text as an effect, or use a set of
  fonts available at different sizes (such as deja) if you want text at different sizes to
  correspond to zooming.

- `touch`, `gamepad_array[]`, and `joy` `xy` values match the current screen-to-camera space
  transformation from `set_transform` at the time that they are read. This is mostly
  so that controls and event coordinates will match drawing coordinates when the
  axis is flipped or the screen origin changed.
  
- Every `entity` contains both a transformation to its parent (`entity.pos_in_parent`, `entity.angle_in_parent`, `entity.scale_in_parent`, `entity.z_in_parent`)
  and a transformation directly to world space (`entity.pos`, `entity.angle`, `entity.scale`, `entity.z`).
  Storing the direct transformation improves performance and simplifies many common operations.
  `entity_update_children(root)` recursively updates the direct transformation for an entire hierarchy.

In general, `set_transform()` is good for tasks such as, "I'm making
the user interface and want Y=down and 0 at top left" or "I'm
drawing the world and want Y=up and the origin in the center". It
cannot rotate the viewpoint. 

`set_camera()` is for shifting the viewpoint in 2.5D within
the world coordinate system. It cannot flip axes (it only allows
positive, uniform zoom), but it can rotate, translate, and zoom. 
Use it to show different views of the same scene, follow a character,
or render a minimap. 
  
Common situations are:
  
 - No camera or transform. Use `y_up` in the game.json file if you want the y axis to go up
 - Move (0, 0) to the center of the screen: `set_transform(SCREEN_SIZE / 2)`
 - Center on the player entity, without rotation: `set_transform(SCREEN_SIZE / 2); set_camera(pos:player_entity.pos})`
 - Center on the player and rotate the y-axis to match (good for sprites drawn facing up): `set_transform(SCREEN_SIZE / 2); set_camera(player_entity)`
 - Center on the player and rotate the x-axis to the y-axis (good if you want `player.angle=0` to be the x-axis) `set_transform(SCREEN_SIZE / 2); set_camera({pos:player_entity, angle:player.angle - 90deg})`

The coordinate systems are defined by transformations _from_ a
coordinate system to its parent always being applied in the order of
scale, rotation (`angle`), translation (`pos`). That is, objects scale
along their own axes and rotate about their own origin.

The transformation routines are:

`transform_cs_to_ss(cs_point, cs_z default 0)`
: Transform `cs_point` at `cs_z` from camera space to screen space. The `cs_z` is needed 
  only if a skew transformation is active.
  
`transform_cs_z_to_ss_z(cs_z)`
: Transform camera space `cs_z` to a screen space z value.

`transform_ss_to_cs(ss_point, ss_z default 0)`
: Transform `ss_point` from screen space to camera space.

`transform_ss_z_to_cs_z(cs_z)`
: Transform screen space `ss_z` to a camera space z value.
  If the current transform has a zero z-scale then the result will be positive infinity,
  negative infinity, or zero because the transformation is not invertible in that case.

`transform_ss_to_ws(ss_point, ss_z default 0)`
: Transform `ss_point` from screen space through camera space to world space.

`transform_ws_to_ss(ws_point, ws_z default 0)`
: Transform `ws_point` from world space through camera space to screen space.
  If there is a `ws_point.z` value, it is ignored, only `ws_z` is used for z.

`transform_ws_z_to_cs_z(ws_z)`
: Make `ws_z` relative to the camera.

`transform_cs_z_to_ws_z(cs_z)`
: Make `cs_z` absolute in world space.

`transform_ws_z_to_ss_z(ws_z)`
: Transform from world space through camera space to screen space.

`transform_ws_to_cs(ws_point, ws_z default 0)`
: Transform world space `ws_point` to camera space. There is no
  transformation function for `cs_z` value because you can 
  transform it yourself `cs_z = ws_z - get_camera().z`.
  
  If there is a `ws_point.z` value, it is ignored. Only `ws_z` is used
  for z.

`transform_cs_to_ws(cs_point, cs_z default 0)`
: Transform camera space `cs_point` to world space. There is no
  transformation function for `cs_z` because you can transform
  it yourself as `ws_z = cs_z + get_camera().z`.

`transform_ws_to_es(entity, ws_point)`
: Transform world space point `ws_point` into the entity space of `entity`, wherever it is
  in the hierarchy. There is no transformation function for `ws_z` because you can transform
  it yourself as `es_z = ws_z - entity.z`.

`transform_es_to_ws(entity, es_point)`
: Transform entity space point `es_point` into world space, wherever the entity is in the hierarchy.
  There is no transformation function for `es_z` because you can transform
  it yourself as `ws_z = es_z + entity.z`.

`transform_to_parent(child, child_point)`
: Takes a coordinate `child_point` in the `child` entity reference frame and transforms it to
  the `child.parent` entity reference frame.

`transform_to_child(child, parent_point)`
: Takes a coordinate `parent_point` in the `child.parent` entity reference frame and transforms it to
  the `child` entity reference frame.

`transform_es_to_es(entity_from, entity_to, es_from_point)`
: Transform the `es_from_point` in the reference frame of
  `entity_from` to the reference frame of `entity_to`.
  There is no transformation function for `z` values because you can transform
  it yourself as `z += entity_from.z - entity_to.z`.

`transform_es_to_sprite_space(entity, es_point)`
: Transform `es_point` in the reference frame of `entity`
  into the pixel coordinates of the current `entity.sprite`.
  
`transform_sprite_space_to_es(entity, sprite_point)`
: Transform `sprite_point` in the pixel coordinates of the
  current `entity.sprite` into the reference frame of the
  entity.

`transform_to(pos, angle, scale, point)`
: Transform `point` into the reference frame defined by `pos`, `angle`, and `scale`.

`transform_from(pos, angle, scale, point)`
: Transform `point` from the reference frame defined by `pos`, `angle`, and `scale`.


### Screen Space

Note that `preserving_transform` also preserves the clipping rectangle.

`compose_transform(pos default ∅, dir default ∅, z default ∅, zDir default ∅, skew default ∅)`
: Apply this local transformation _before_ the current one. Used for entering a child
  coordinate system. Nil arguments or properties default to `(xy(0, 0), xy(1, 1), 0, 1, xy(0, 0))`.
  Use `preserving_transform` or `get_transform()` plus `set_transform()` to save and restore
  nested coordinate systems.

`compose_transform(args)`
: Named argument version of `compose_transform()`.

`get_transform()`
: Returns the current net transformation as an `args` object that could be passed to
  `set_transform(args)`.

`preserving_transform:`
: The special `preserving_transform:` block saves the current transform, camera, and
  clipping region, executes the code in the body, and then restores the
  previous transform and clipping region when the block is exited (including abruptly by 
  `return`, `continue`, or `break`). It is useful for making modular
  functions for handling UI scrolling, minimaps, and screenshake. 

`rotation_sign()`
: Returns -1 if `(t.dir.x * t.dir.y > 0)` for `t = get_transform()`
  and +1 if `(t.dir.x * t.dir.y < 0)`. Useful for computing the
  coordinate transform of an entity angle. Angles are always measured
  counter-clockwise on *screen*.  In the *draw coordinate system*, they
  rotate counter-clockwise if `rotation_sign() = 1` and clockwise if
  `rotation_sign() = -1` (which is the default). This is used by `draw_sprite()`
  to determine the rotation direction. See also `up_y()`.

`reset_transform()`
: Reset to the default transformation, `set_transform(xy(0, 0), xy(1, 1), 0, 1, xy(0, 0))`.
  This overrides the `y_up` flag from the .game.json file.

`set_transform(pos default ∅, dir default ∅, z default ∅, z_dir default ∅, skew default ∅)`
: Set the transformation applied to all camera coordinates to compute screen coordinates. Nil values
  or nil properties default to their previous value. The equation applied when mapping from
  camera space (cs) to screen space (ss) is:
  
  - `ss.x = (cs.x + skew.x * cs.z) * dir.x + pos.x`;
  - `ss.y = (cs.y + skew.y * cs.z) * dir.y + pos.y`;
  - `ss.z = cs.z * z_dir + z`.

  The `dir` parameters must be +1 or -1, for flipping axes. This
  affects the location of sprites and text but not their own axes;
  text will always render right side up and sprites must be
  independently flipped.

  By default, increasing z is towards the viewer, a negative direction can
  be used to make increasing values farther back.

  The skew transform applies after direction flipping and can be used for isometric 3D.

`set_transform(args)`
: Named argument object version of `set_transform()`.

<code lang=PyxlScript>up_y()</code>
: Returns `-sign(get_transform().dir.y)`, which is -1 if Y increases downwards (the default)
  and +1 if Y increases upwards (`"y_up": true` in the .game.json file).



The clipping region is the only object interacted with in *screen
space*, via `set_clip()`, `get_clip()`, and `intersect_clip()`.

The screen space graphics coordinate system is:

- x increasing from 0 at the left edge of the screen to `SCREEN_SIZE.x` at the right edge
- y increasing from 0 at the top edge of the screen to `SCREEN_SIZE.y` at the bottom edge
- z increasing from -2047 at the back to 2048 at the front

Integer coordinates correspond to the top-left corner of a pixel.
Pixel centers are at integers plus ½. The top-left pixel center is (½, ½).

Drawing commands sample at pixel centers. The pixel ownership rules
are bottom and right, so a primitive that has a top or left boundary
exactly on a pixel center will not color that pixel. This is important
for adjacent primitives to keep them from double-covering a pixel on
the boundary. When thinking of the screen as a 2D array of discrete
pixel elements, the snapping rule is essentially that a 1-pixel rectangle
centered at `pos` colors pixel `⌊pos⌋`.

For example, the rectangle from (0, 0) to
(2, 1) covers two pixel centers: (0.5, 0.5) and (1.5, 0.5). 
Setting this as the
clipping region makes two pixels visible.

This coordinate system favors intuition for centered, even-sized
objects such as sprites. It also gives the result that you might
intuitively expect for odd-sized objects at integer or half-integer coordinates
such as odd-width text,
1-pixel points at integers, and 1-pixel horizontal and vertical lines. Diagonal
1-pixel lines and points at non-integer, non-half locations will round in ways
that are less intuitive.

`draw_point(pos, #FFF)` draws a one-pixel rectangle from `pos - ½` to `pos + ½`.
So, when passed integer arguments, `pos` = (0, 0) will color the top-left pixel and `SCREEN_SIZE - 1` is the
lower-right. Any value from 0 to (1 - `ε`) will write to the
the first pixel. When seeking to draw individual pixels aligned with the grid,
I recommend that you use integer plus 1/2 coordinates
for `draw_point()` for robustness. However, if you use integer coordinates, it will
"do what you expect".

`draw_line()` draws a line centered on its endpoints that
extends ½ pixel beyond its endpoints. When seeking to draw horizontal and vertical lines
aligned with the grid, I recommend that you use integer plus ½ coordinates
for `draw_point()` for robustness. However, if you use integer coordinates, it will
"do what you expect". For other lines, you may be surprised by the result if they
aren't at half-pixel offsets.

A 4x4 sprite (or circle or text character) with its top and left
edge aligned with the screen edges is centered on coordinate (2, 2),
that is, half its width and height. A 3x3 object aligned as such
is centered at (1.5, 1.5) but will draw in the same way if centered
at (1, 1), which would be consistent with integer pixel centers.
The center of the entire screen is `½ SCREEN_SIZE`.

### Camera Space

Note that `preserving_transform` also preserves the camera.

`get_camera()`
: Returns the current camera as an `args` object that could be passed to `set_camera(args)`.

`reset_camera()`
: `set_camera({pos: xy(0, 0), angle: 0deg, zoom: 100%, z: 0})`

`set_camera(pos default xy(0, 0), angle default 0, zoom default 1, z default 0)`
: Positions the camera used to transform other draw calls. Note that
  `zoom` is the inverse of a scale transformation on the camera
  itself.  Use `set_transform()` to move the on-screen origin.
  
  `zoom` can be a number or a function, `zoom(cs_z)`. If it is a
  function, it computes the zoom factor for an object at `cs_z` in
  camera space.  This is useful for creating pseudo-3D effects. If you
  do not want your map layers to zoom in perspective, set the
  `"z_scale"` value in the map.json file to a small number or
  zero. Enabling a zoom function with nonzero `z_scale` can make map
  rendering significantly slower in the case of multiple layers
  because it disables occlusion culling.
  
  To render sprites with parallax but 1:1 pixel scaling when using a
  zoom function, set the sprite or entity `scale` to `1 / camera.zoom(entity.pos.z - camera.pos.z)`.

`set_camera(args)`
: Named argument object version of `set_camera()`.

### Entity Space

Each entity has its own coordinate system defined by `entity.pos`,
`entity.scale`, and `entity.angle`. The `entity.scale` is often used to
flip sprites from left to right, which also flips the entity's local
coordinate system. 

In most cases, you won't have to think about entity space beyond setting
those properties. Entitys drawn with sprites and interacting with physics
automatically handle the transformations. Only if you're doing detailed
manipulation of children or drawing explicitly in entity space do you
need to apply transformations.

The direction of `entity.angle` is always counter-clockwise in screen
coordinates. The direction in draw coordinates is given by
`rotation_sign()`.

******************************************************************
*  Default Entity Space         With flipped y-axis
*
*                                       ^ y
*                                       |
*     .---------.                  .----|----.
*     |    ↶    |                  |    |↶   |
*     |    *-------> x             |    *--------> x
*     |    |    |                  |         |
*     '----|----'                  '---------'
*          |
*          v y
******************************************************************

The axes of the entity space in draw space are given by:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
const θ = rotation_sign() * entity.angle
const X = xy( cos θ, sin θ) * entity.scale
const Y = xy(-sin θ, cos θ) * entity.scale

// or

const X = transform_entity_to_draw(entity, xy(1, 0)) - entity.pos
const Y = transform_entity_to_draw(entity, xy(0, 1)) - entity.pos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Entity space is mostly used for moving a character relative to its own
axes or resolving attachment points. Drawing commands always take 
world space arguments and physics, per-pixel hit detection, and sprite drawing
automatically handle the world-to-entity transformation for you.

In the rare case where you want to draw in entity space, you can transform the arguments to world space:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
draw_disk(transform_es_to_ws(entity, es_pos), es_radius * entity.scale.x, color)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This works even if the entity is deep in an entity hierarchy.
When drawing a shape with more parameters, the draw commands have additional arguments to help
with this process. For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
draw_rect(transform_es_to_ws(entity, es_pos), size * entity.scale, fill, border, entity.angle, entity.z)
draw_poly(es_vertex_array, fill, border, entity.pos, entity.angle, entity.scale, entity.z))
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Sprite Pixel Coordinates

Sprite coordinates are used by `sprite_pixel_color()`. These are integers
with (0,0) on the top left of the sprite and (`sprite.size.x` - 1, `sprite.size.y` - 1)
on the lower right.

### The Z-Axis

All drawing commands take one or more position values, color and other
parameters, and a `z` value.

The value `z default pos.z default 0` is used for z-order occlusion
(or the equivalent specified default for the few drawing functions
that have a position named other than `pos`).

The value `pos.z default z default 0` is used for clipping, camera
zoom, and transform skew.

Note that because of the defaults, if only one of `pos.z` and `z` is specified, that one value is then used for 
all z-axis properties. For example, in the common case `pos` is an `xy()` value, so it has no `pos.z`
and the `z` parameter will be used.

In rare cases it is useful to specify different values for `pos.z` and `z`. For example,
with volumetric shadows you can draw a drop shadow
that has the projection of the perspective of plane (`pos.z=0`) but is drawn 
with a higher occlusion order (`z = 10`),
so that the shadow is cast onto other objects.

Another example is for performance. Drawing many sprites sequentially with different `pos.z` values 
produces correct skew and zoom for them, while and forcing their `z` to the same value 
will cause the individual draw calls can be aggregated for better performance.


### Spritesheet Indices

*Sprite sheets* use integer coordinates with (0, 0) at the upper-left
corner and (`size(sheet)` - 1, `size(sheet[0])` - 1) at the
lower-right corner. Instead of functions for operating on these, sprite
sheets are directly accessed as 2D arrays: `sheet[x][y]`.

### Map Cell Indices

*Map space* integer coordinates used by maps have (0, 0) as upper-left
tile and `map.size` - 1 at the lower-right tile.
Maps are typically accessed as 2D arrays: `map.layer[L][x][y]`. For
convenience, `map[x][y]` is a shorthand for `map.layer[0][x][y]`.

The top-left corners of map cells are at integers when converting
between map and draw coordinates. When rendered, a map therefore
covers the same region as the drawing command
`draw_corner_rect(xy(0,0), map.size * tileSize, #f)`.

The map is aligned by default so that `draw_map()` renders the top-left
corner of the map to the top-left corner of the screen. Use
`offset` in the `.map.json` file or `set_transform()` to alter
the location of the map when rendered.


Animations
------------------------------------------------------------

Each named sprite animation `spritesheet["`<i>animation_name</i>`"]`
or `spritesheet.`<i>animation_name</i> of a spritesheet is an array
that has the following immutable properties:

`animation.period`
: Number of frames before the animation repeats, which is
  `0` for `clamp` animations.

`animation.frames`
: Number of frames before the animation ends, which is
  `infinity` for `loop` or `oscillate` animations.

`animation_frame(animation, t)`
: Return the sprite to show for the animation at time `t` measured in
  frames, obeying the individual `sprite.frames` durations and
  wrapping or clamping appropriately.

Because it is an array, the i<sup>th</sup> sprite is `animation[i]` and
you can loop that using `array_value(animation, i)` or choose a random
one with `random_value(animation)`.

To create an animation, there must be a `start` property in the named 
entry of the .sprite.json file.



Sprite
------------------------------------------------------------

Each sprite element `spritesheet[x][y]` of a spritesheet has the following immutable properties.
Sprites can also be referenced by name `spritesheet["`<i>name</i>`"]` or 
`spritesheet.`<i>name</i>, if the named sprite has an `x` and `y` property instead of
a `start` property in the .sprite.json file.

`sprite.animation`
: If the sprite is in an animation (a multi-frame named array from a `sprite.json` file),
  this is the array that contains it. See also `animation_frame()`

`sprite.base`
: The original spritesheet sprite on which this one is based. For
  example `sprite.rotated_90.base === sprite`. Can be used to determine
  the relative orientation of a transformed sprite from a map.

`sprite.frames`
: Number of 1/60-second (≈ 16.7 ms) game frames to hold this sprite during animation.
  Set by the spritesheet's `default_frames`, the animation's `default_frames`,
  or the animation's per-sprite `frames` array.

`sprite.id`
: Unique integer identifying this sprite by spritesheet and
  tile_index, but excluding orientation. This may change every time
  the program is run.

`sprite.mean_color`
: The average color of the entire sprite (not rounded to 4-bit precision).
  The color is computed using premultiplied alpha weighting, so low-alpha
  pixels contribute less to the final average.

`sprite.orientation_id`
: Unique integer identifying this sprite, including orientation. This
  may change every time the program is run. The flipped versions of a
  sprite have _different_ IDs. To tell if two sprites are the same
  except for flipping and rotation, use `sprite.id` instead.

`sprite.pivot`
: `xy()` position of the pivot from the upper left corner of the sprite
  in pixels. Defaults to the center.

`sprite.rotated_90`
: Counter-clockwise 90 degree rotated version of the sprite. The
  bounds may be different if the sprite is not square. This is not
  affected by the up direction of a map or game because it is always
  counter-clockwise in the spritesheet.

`sprite.rotated_180`
: Counter-clockwise 180 degree rotated version of the sprite. The
  bounds may be different if the sprite is not square. Note that
  `s.x_flipped.y_flipped == s.rotated_180 == s.y_flipped.x_flipped == s.rotated_90.rotated_90`.
  This is not affected by the up direction of a map or game because it is always
  counter-clockwise in the spritesheet.

`sprite.rotated_270`
: Counter-clockwise 270 degree/clockwise 90 degree rotated version of the sprite. The bounds may be different 
  if the sprite is not square. Note that `s.x_flipped.y_flipped.rotated_90 == s.rotated_270`.
  This is not affected by the up direction of a map or game because it is always
  counter-clockwise in the spritesheet.

`sprite.scale`
: An `xy()` value that is how the sprite is scaled along each axis
  when rendered. `xy(1, 1)` for sprites extracted directly
  from the spritesheet and may be +1 or -1 in each axis for flipped
  sprites. _This may take on non-unit values in a future version of the
  API to support MIP maps._

`sprite.size`
: `xy()` dimensions of the sprite in pixels. Note that for a rotated sprite,
  `sprite.size` is not the same as `sprite.spritesheet.sprite_size`.

`sprite.spritesheet`
: From which this sprite is taken.

`sprite.tile_index`
: Integer `xy()` index of the sprite in its spritesheet.

`sprite.x_flipped`
: The corresponding derived sprite that is this sprite flipped horizontally.
  Flipped sprites are created on spritesheet load but can only be accessed
  through the non-flipped sprites. Note that `s.x_flipped.x_flipped == s`.

`sprite.y_flipped`
: The corresponding derived sprite that is this sprite flipped vertically.
  Flipped sprites are created on spritesheet load but can only be accessed
  through the non-flipped sprites. Note that `s.y_flipped.y_flipped == s`.


Any properties attached to a named sprite or animation in the
`sprite.json` file also appear as properties of the sprite (and its
flipped variations).

The spritesheet itself has the properties:

`spritesheet.sprite_size`
: Pixel size of each sprite.

`spritesheet.size`
: Pixel size of the entire spritesheet.

`spritesheet.size_in_sprites`
: `xy(size(spritesheet), size(spritesheet[0]))`

The functions that operate on sprites and spritesheets are `draw_sprite()` and:

`sprite_pixel_color(sprite, pos, result default ∅)`
: Returns the color of pixel `pos` in the sprite as an `rgba`
  value. Sprite pixel indexing puts (0, 0) in the top left corner.
  When `result` is not `nil`, it is used to store the result
  to avoid memory allocation. If the pixel is out of bounds for that sprite,
  returns `nil` if there is no `result` specified and `rgba(0, 0, 0, 0)`
  in `result` otherwise.

`sprite_transfer_orientation(orient_sprite, content_sprite)`
: Returns `content_sprite` flipped and rotated in the same way that
  `orient_sprite` was relative to `orient_sprite.base`. Note that
  if `content_sprite` is _already_ transformed, the new transformations
  will apply on top of those. Use `content_sprite.base` to instead
  transform relative to the canonical version in the spritesheet.

`sprite_transfer_orientation(orient_sprite, content_spritesheet)`
: Shorthand for `sprite_transfer_orientation(orient_sprite,
  content_spritesheet[orient_sprite.tile_index.x][orient_sprite.tile_index.y])`.
  Useful for selecting the equivalent sprite including orientation
  from a different spritesheet. Applicable to manual level
  of detail, shadow rendering, and character swaps, for example.


Entity
------------------------------------------------------------

The entity system is optional. It is convenient for providing fast,
reliable implementations of common game-like simulation operations for
prototyping. There are three categories of entity abstraction: basic,
physics, and hierarchy. Use whichever level of complexity is useful to
you, or simply build your own system if you wish. Note that due to "duck
typing", you can apply entity functions to any object that has the
right subset of properties for that function.

In addition to the built-in entity properties, you can add whatever
properties you wish. Beware that the following properties are
available as user properties today, but are likely to be added as
built-in properties in the future: `density` and `friction`.


### Basic

`draw_entity(e, recurse default true)`
: Draw the entity, if its sprite is defined. If `recurse` is true,
  also draws all of the elements of `e.child_array` recursively (see
  the Hierarchy section).

`make_entity(obj default {}, child_table default {})`
: Returns a new entity object that is `obj` with defaults applied for
  any properties not specified. This is forward compatible to any
  extended properties that might be added in future versions, however,
  those properties might conflict with any that you add on your
  own. The built-in entity properties are all cloned if specified,
  preserving types (for example, if `pos` is an `xyz()` instead of an
  `xy()`, the extra property is retained). All other properties of
  `obj` are copied over but not cloned.

  If the `child_table` second argument is provided (note that this is not
  a property of `obj`), then all of the keys become properties of the new
  entity and the values are added to the entity's `child_array`. This is
  a convenient way to build entity hierarchies.

  If a `child_array` property is specified on `obj`, then
  `entity_add_child()` is called for each element of this array and
  `entity_update_children()` is automatically invoked after the new entity
  is constructed.
  
  If `entity.shape` is a polygon, then the following will occur when the entity 
  is initialized: 
    - The polygon vertices will be adjusted so that the center of mass is at (0, 0)
      in entity space
    - The pivot will move so that the sprite remains aligned with the original
      polygon specification
    - `entity.size` will be recomputed as the tightest centered bounding box
      on the polygon


The basic entity properties and defaults are:

`entity.angle default 0deg`
: The world space angle from the x-axis to y-axis in radians. Angles in <quadplay/>
  always increase counterclockwise regardless of the up direction. 
  Defaults to 0deg. See also `draw_sprite()`, `entity.angle_in_parent`,
  and `entity.orient_with_parent`.

`entity.name default "entity"`
: A string useful for debugging and error messages. Defaults to `"entity"` +
  a unique number.

`entity.offset default xy(0, 0)`
: A world space value added to `entity.pos` by `draw_entity()` for placing
  the sprite. Useful for causing the drawn position to temporarily drift from the
  simulated position for effects like shake or blowback after a hit.
  Defaults to `xy(0, 0)`. 
  _Does not affect bounds for `overlaps()`, physics, or ray intersection._
  See also `entity.pivot`.

`entity.opacity default 100%`
: Visibility on the interval 0 to 1. Defaults to 1.

`entity.pivot`
: Entity space point on the sprite that is mapped to the center of the entity.
  Defaults to the pivot from the intial sprite, or `xy(0, 0)` if there
  was no sprite. If you change the `entity.sprite`, then you may want
  to also change the `entity.pivot` at the same time. See also
  `entity.offset` for transient effects and `sprite.pivot` for the default
  value. This is called an "anchor" in some game engines.

`entity.pos default xy(0, 0)`
: The world space `xy()` or `xyz()` position of the center of the entity. Defaults to `xy(0, 0)`.
  See also `entity.pos_in_parent`, `entity.offset`, and `entity_update_children()`.

`entity.scale default xy(1, 1)`
: The world space `xy()` scaling applied to `entity.size` before
  translation and rotation. See `draw_sprite()`.  Defaults to `xy(1, 1)`. 
  This can be used to grow, stretch, or flip the entity.  If
  `entity.shape == "disk"`, then the scale must have the same
  magnitude in both x and y. The scale may be zero or negative along
  either axis.

`entity.shape default "rect"`
: May be:
   - `"rect"`
   - `"disk"`
   - An array of `xy()` entity-space vertices forming a convex polygon with
     center of mass at the entity's origin
  
  A `"disk"` entity must have `entity.scale` that is the same in x and y.
  Polygons are slower for many routines.
  
  A polygon must still lie within
  the `entity.size` but is not affected by it directly. For best results,
  make the size a tight bounding box and keep the center of mass of
  the polygon at the entity-space origin. Note that `make_entity()` automatically
  enforces this.

`entity.size`
: The _entity space_ `xy()` size of the width and height of the bounding
  box of the entire object, oriented in its own reference frame. The
  _world space_ rendered/collision size is `entity.size * |entity.scale|`.  If
  `entity.shape == "disk"`, then the `x` and `y` properties must have the
  same value. If not specified, size defaults to the sprite's size in
  in entity space. 

`entity.sprite default nil`
: A sprite from a sprite sheet. Can be `nil`.

`entity.override_color default nil`
: Blends over the color of the sprite with this color (only works
  if there is a sprite). See `draw_sprite()` for details. Defaults to `nil`.

`entity.z`
: z-order position (a number) in world space. Defaults to zero, unless `entity.pos`
  is an `xyz()` value, in which case this is left as `nil` so that the
  `entity.pos.z` value can override. Setting both `entity.pos.z` and
  `entity.z` allows separating the z-order for rendering.


Examples of creating an entity with different shapes:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
// Disk
e = make_entity({pos:P, shape:"disk", size: xy(diameter, diameter)})

// Square
e = make_entity({pos:P, shape:"rect", size: xy(edge, edge)})

// Rectangle
e = make_entity({pos:P, shape:"rect", size: xy(w, h)})

// Line
e = make_entity({pos:(A + B) / 2, shape:"rect",
                size: xy(magnitude(B - A), 0),
                angle:atan(B.y - A.y, B.x - A.x)})
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The entity system is designed to be extensible. You can add your own
properties to it, and aren't required to use it at all...make direct
`draw_sprite()` calls if you don't like this. You can also use the
entity system but replace the rendering if you prefer. For example,
if you'd like to register your own draw function callbacks instead
of using the sprite rendering, you can do this:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
def draw(e):
   if e.draw: e.draw(e)
   for c in e.child_array: draw(c)

def drawInBox(e):
   draw_corner_rect(e.pos, e.size, #FFF)
   draw_sprite(e.sprite, e.pos)

let e = make_entity({..., draw:drawInBox})

draw(e)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Example of replacing `draw_entity` with a version that uses arbitrary callbacks.]


### Label Properties

A text label is drawn for the entity if `entity.text and
entity.font` is not `nil`. This is useful for showing player
names, map labels, RPG stats, scores, and character dialogue. The full
set of label properties is:

- `entity.text`
- `entity.font`
- `entity.text_x_align`
- `entity.text_y_align`
- `entity.text_offset` (this is not affected by entity rotation but is affected by scale)
- `entity.text_color`
- `entity.text_shadow`
- `entity.text_outline`


### Physics Properties

A key relating textbook symbols and definitions to the <quadplay/> entity property names is:

  Property        | Symbol                           | Definition
  ----------------|----------------------------------|------------------
  `pos`           | _x_(_t_)                         | Position
  `vel`           | _v_(_t_) = _dx_(_t_) / _dt_      | Linear velocity
  `force`         | _F_(_t_) = _m_ • _a_(_t_)        | Force
  `angle`         | _θ_(_t_)                         | Angle
  `spin`          | _ω_(_t_) = _dθ_(_t_) / _dt_      | Angular velocity
  `torque`        | _τ_(_t_) = _I_ • _α_(_t_)        | Torque
  `inertia`       | _I_                              | Inertia
  `density`       | _ρ_                              | Density
  `friction`      | _μ_ₖ                             | Coefficient of kinetic friction
  `stiction_factor`| _μ_ₛ/_μ_ₖ                       | Static friction multiplier
  `restitution`   | _e_                              | Coefficient of restitution

You can choose the units and coordinate system. Pixels (of distance),
pixel mass, and game frames are the most common choice of units in
order to simplify conversion factors.

See also the Physics section for relevant functions.

`entity.force`
: `xy()` or `xyz()` linear force. Defaults to `xy(0, 0)`.
  Has units of mass * pixels / frame^2 by default.
  Typical forces are on the scale 1-10.

`entity.density`
: In mass units per square pixel. Defaults to 1.
  If density is `infinity`, then the object can move others
  but is not itself affected by collisions, and also ignores
  gravity.

`entity.spin`
: Scalar counter-clockwise rotational velocity. Defaults to 0.
  Has units of radians/frame by default.

`entity.torque`
: Scalar counter-clockwise rotational torque. Defaults to 0.
  Has units of mass * radians/frame^2 by default. Typical torques
  are on the scale 1-10.

`entity.vel`
: `xy()` or `xyz()` linear velocity. Defaults to `xy(0, 0)`.
  Has units of pixels/frame by default.

`entity.physics_sleep_state`
: Current sleeping state of the entity in a physics engine. Default is `"awake"`. Legal values are
  are `"sleeping"`, `"awake"`, and `"vigilant"` (awake and can never go to sleep). Because
  objects that are sleeping do not maintain contacts with other sleeping objects or parts of
  the environment, if you want to check for contacts (such as with the ground) on a player controlled
  entity then it should be `"vigilant"`.

`entity.restitution`
: Amount of energy preserved in a collision. Useful range is 0%-100%. The default is 10%.
  The net restitution applied between two entities is the geometric mean of their restitution values.

`entity.contact_category_mask`
: Contact (collision) categories for this object, as 32-bit flags.
  Two objects can only contact if
  `(A.contact_category_mask bitand B.contact_hit_mask) and (B.contact_category_mask bitand A.contact_hit_mask)`.
  Defaults to 1. Does not affect `overlaps()`.

  Think of the category mask as where you set bits to indicate what
  the entity *is* and the hit mask as what other entities it collides
  with. A collision only occurs if both entities agree that they can
  collide with each other. 
  
  For example, you could define `GRASS = 0b001`, `ROCK = 0b010`, and
  `SHEEP = 0b100`. Setting `sheep.contact_hit_mask = ROCK bitor
  SHEEP`, `rock.contact_hit_mask = ROCK bitor GRASS bitor SHEEP`, and
  `grass.contact_hit_mask = ROCK bitor GRASS` would enable sheep to
  pass through grass but not rocks or other sheep, and have all
  combinations of rocks and grass collide with each other.
  
  Note that masks can be set independently (and asymmetrically, so
  that A wants to collide with B but B doesn't want to collide with
  a). That is because an entity may be in multiple categories
  (example: `HELICOPTER = VEHICLE bitor AIRBORNE bitor ENEMY bitor
  FAST`), and have mutliple hit masks, rather than the category being
  1:1 with the entity type.
  
  The masks have no impact on performance during collision detection,
  but there is a limit of 32 categories. See also
  `entity.contact_group`.
  

`entity.is_sensor`
: If `true`, collisions will occur with this entity as usual but will not cause motion to change
  as a result, like a ghost. Default is `false`. This is useful for detecting triggers such as a character
  walking through a doorway or touching acid via the physics engine without causing that to affect
  the object. Note that a sensor must have infinite density or be attached to another object or it will
  fall out of the world by gravity. If you want to never register collisions, instead set `entity.contact_category_mask = 0`
  to prevent all collisions and preclude them being reported.

  Collision sensors have density, and it must be nonzero. Set their density
  to a small value, such as `epsilon`, to minimize the effect on the motion of other objects
  that they are attached to.

`entity.contact_group`
: An integer index of a group of other entities that this one should not collide with, regardless
  of the `contact_hit_mask` or `contact_category_mask`. Zero means no group at all. Defaults to 0.
  Does not affect `overlaps()`.
  
  This is useful for putting all of the parts of a multi-part object into
  a single group to prevent self-collisions. For example, with a rope constructed as a chain of boxes
  or a car with wheels. Unlike an `entity.contact_category_mask`, an object can only be 
  in a single group. However, there is no limit on the number of contact groups that can
  be used in the game, while there is a limit of 32 categories.

`entity.contact_hit_mask`
: See `entity.contact_category_mask`. Defaults to `0xffffffff`. Does not affect `overlaps()`.

`entity.stiction_factor`
: Multiplier applied to `entity.friction` in the static dry friction case
  when an object is at rest. Useful range is 0-10. Defaults to 1.

  The value 0 disables static friction (since it allows the object to immediately
  start moving, and thus have kinetic friction engage), so that only dynamic friction is applied.
  The net stiction_factor between two entities is the _maximum_ of each of their
  stiction_factor values. Set moving platforms and conveyor belts to have high stiction to help characters
  move with the surface that they are on.

`entity.friction`
: Kinetic dry friction applied when an object is in motion, damping the velocity.
  Useful range is 0%-100%. Defaults to 15%. The net friction applied between two
  entities is the geometric mean of their friction values.

`entity.drag`
: Drag friction applied when an object is moving freely. Useful range is 0-10. Defaults to 0.005.
  There is a single drag constant for the body independent of the orientation or direction of
  motion. This is not a drag _coefficient_ because it is independent of cross-sectional area.


### Hierarchy

The hierarchy is not a traditional scene graph. Children can opt to
either compose their properties with their ancestors recursively or
have absolute properties in draw space.

Hierarchy functions:

`entity_add_child(parent, child)`
: Adds the `child` entity to the `parent.child_array` and sets `child.parent = parent`.
  Removes the child from any previous parent's child array if there was one.
  Returns the `child`.

`entity_remove_child(parent, child)`
: Removes the `child` from `parent.child_array`, if it is a
  child. Does nothing if `child` is not in `parent`. Causes an error
  if `child` and `parent.child_array` are inconsistent.  If the child
  was added by the `make_entity` `childTable` as a property on parent,
  that property is not modified. You can remove the property explicitly
  using `remove_key(parent, "childName")`.

`entity_remove_all(parent)`
: Removes all children.

`entity_update_children(entity)`
: Recursively update the `pos`, `scale`, `angle`, and `offset` fields of all children and
  descendants from their `pos_in_parent`, `scale_in_parent`, `angle_in_parent`, and `offset_in_parent`
  fields. Usually called after simulation or animation processing.


The hierarchy properties are:

`entity.child_array`
: Array of other entities that position themselves relative to
  this one. Defaults to `[]`.

`entity.parent`
: Another entity that has this one as a child. Defaults to `nil`.

`entity.angle_in_parent`
: Scalar counter-clockwise angle in radians relative to the parent if
  `entity.orient_with_parent` is true, otherwise ignored.

`entity.offset_in_parent`
: `xy()` `offset` relative to the parent in entity space if `offset_with_parent` is true,
  otherwise ignored.

`entity.offset_with_parent`
: Boolean. If true, then `entity_update_children()` recomputes `entity.offset` from `entity.offset_in_parent`
  and `parent.offset`.

`entity.pos_in_parent`
: `xy()` or `xyz()` position value relative to the parent, in parent space. There is no way to opt out of this property being
  applied recursively. Defaults to `xyz(0, 0)`.

`entity.orient_with_parent`
: If true, `entity_update_children()` will override this entity's angle and scale with
  `entity.angle = entity.angle_in_parent + parent.angle` and `entity.scale = entity.parent.scale * entity.scale_in_parent`.

`entity.scale_in_parent`
: `xy()` scale relative to the parent axes for flipping
  the child if `orient_with_parent` is true, otherwise ignored.

`entity.z_in_parent`
: Scalar z value relative to the parent. There is no way to opt out of this property being
  applied recursively. Defaults to 0.


Physics
---------------------------------------------------------

You can implement your own physics simulation, use entity and the
entity helpers, enable the full entity physics engine, or mix these
techniques.

### Entity Helpers

Also see the Intersections section for computing your own collisions and
intersections.

`entity_apply_fluid_force(entity, ws_fluid_vel, ρ default 1, A default entity_projected_length(entity, perp(direction(ws_fluid_vel))), c_d default 0.4, es_pos default xy(0, 0), label default "")`
: Applies force $\vec{F_\mathrm{d}}$ $= \frac{1}{2} \rho ~ ||\Delta \vec{v}||^2 ~ \dfrac{\Delta \vec{v}}{||\Delta \vec{v}||} ~ c_\mathrm{d} ~ A$
  $= \left(\frac{1}{2} \rho ~ c_\mathrm{d} ~ A ~ ||\Delta \vec{v}||\right) ~ \Delta \vec{v}$,
  where $\Delta \vec{v}$ is the difference in velocity between the location `es_pos` on the entity
  and the `ws_fluid_vel`, and:

  - `ρ`: Density of the fluid, using the same units as `entity.density`.
     For reference, if the default density 1 of an entity corresponds to solid wood
     in your units system, then water also has density 1, air has density 0.0013,
     and lava has density 3.
  - `ws_fluid_vel`: World-space velocity of the fluid exerting the force, or velocity of the
     fluid through a propellor.
  - `A`: Cross-sectional length. In 2D this is technically the number of edge pixels exposed
     to the fluid, however most games are simulating a 3D object represented in 2D, so
     this is an arbitrary constant.
  - `c_d`: Drag coefficient of the entity, based on its shape and surface roughness. Typically between zero and 1.
     For some real-world objects: car ≈ 0.3, truck ≈ 0.6, parachute ≈ 1.4, airfoil ≈ 0.05.
  - `es_pos`: Entity-space position at which the force is exerted. For a propeller moving fluid,
    this would be the location of the propeller on the entity. For an object partly
    immersed in flowing fluid, this is the center of the immersed part. Defaults to the
    center of mass to exert no torque.
  - `label`: Title shown on the force when physics debugging is enabled

  Ignores the `entity.spin` except for the movement of `es_point`;
  does not integrate varying drag forces over the entire object.

  See also the `entity.drag` constant that coarsely simulates energy
  loss to a surrounding static medium.

  Ensure that a transformation with the same `rotation_sign()`
  as the transformation that will be used when `physics_simulate()` or
  `entity_simulate()` is called is in effect so that torques
  and angular velocities are interpreted with the same sign conventions.


`entity_apply_force(entity, ws_force, es_pos default xy(0, 0), label default "")`
: Apply world-space `ws_force` to `entity` at entity-space position `es_pos`,
  updating both `entity.force` and `entity.torque`. To apply
  a force at the center of mass, you can also directly add to `entity.force`.
  To apply a torque without a net force at the center of mass, directly
  add to `entity.torque`.

  Does not support entities with children or pivots.
  
  Ensure that a transformation with the same `rotation_sign()` as the
  transformation that will be used when `physics_simulate()` or
  `entity_simulate()` is called is in effect so that torques and
  angular velocities are interpreted with the same sign conventions.


`entity_apply_impulse(entity, ws_impulse, es_pos default xy(0, 0))`
: Apply world-space `ws_impulse` (mass * velocity) to `entity` at
  entity-space position `es_pos`, updating both `entity.vel` and
  `entity.spin`. To apply a velocity change at the center of mass, you
  can also directly add to `entity.vel`.  To apply angular velicty
  without a net linear velocity impulse at the center of mass,
  directly add to `entity.spin`.

  Does not support entities with children or pivots.

  Ensure that a transformation with the same `rotation_sign()`
  as the transformation that will be used when `physics_simulate()` or
  `entity_simulate()` is called is in effect so that torques
  and angular velocities are interpreted with the same sign conventions.


`entity_area(e, recurse default true)`
: Returns the world space area of `e`, which must have `shape`
  and `size` properties and may have a `scale` property.
  
  If `recurse` is true and there is a child array, then all of the
  children's areas are summed as well, however the overlap between
  children and between children and parent is not discounted, so some
  area may be double counted.
  
  See also `entity_mass()`, `entity_projected_length()`, and
  `random_within_region()`.


`entity_inertia(entity)`
: 2D scalar inertia tensor about the center of mass.
  Has units of mass * pixels^2.


`entity_mass(entity, recurse default true)`
: Scalar mass equal to `entity_area()` times the `entity.density` `default 1`.
  If `recurse` is true, adds the mass of children.
  Returns generic mass units.


`entity_move(entity, pos default entity.pos, angle default entity.angle)`
: Instantaneously moves an entity to this position and angle _as if it had
  naturally reached that location in the previous frame_, setting the appropriate
  `entity.vel` and `entity.spin`. This is useful for moving
  entities with infinite density in a way that causes them to interact
  naturally with other entities that they come into contact with.
  For example, use this function for implementing moving platforms,
  scripted set-piece animations, and elevators.


`entity_projected_length(entity, axis, recurse default false)`
: Computes the length of the region/entity (disk, rect, or poly)
  projected onto the world-space axis of `xy()` vector `axis`.  If
  `axis` is normalized, this would be the length of the shadow the
  entity casts onto the line containing the vector under a distant
  overhead light. This is the 2D equivalent of cross-sectional area 
  in 3D.

  If there is a child array and `recurse` is true, then all of the children's projected
  lengths are summed as well, however the overlap between children and
  between children and parent is not discounted, so some length may be
  double counted.
  
  See also `entity_area()`.


`entity_simulate(entity, t default 1, region default nil, border_behavior default "clamp")`
: Modifies
  `vel *= 1 - drag; spin *= 1 - drag`.  Then,
  integrates `force/mass` into `vel` into `pos` and `torque/inertia` into `spin` into
  `angle`. Then, resets `force` and `torque` to zero and
  invokes `entity_update_children()`.
  
  Finally, if `region` is specified, wraps or clamps the `pos` to that
  region. The only `region` shape currently supported is a finite
  unrotated, unscaled `"rect"`. The `border_behavior` can be
  `"clamp"` or `"loop"`.
  
  All changes are by mutation, so the `pos`, `acc`, `vel`, and `force`
  point to the same objects afterward.
  Translation operates in 2D or 3D, depending on the type of
  `entity.pos`. Rotation is always 2D.

  Uses a forward Euler (1st order Runge-Kutta) integrator over
  duration `t` measured in frames. This tends to be a more stable
  method for small, discrete time steps than the analytic quadratic
  solution and avoids the need for additional data of higher-order
  integrators.
  
  Does not perform collision detection or response, or enforce attachment
  constraints. Do not call `entity_simulate()` if you are
  already using `physics_simulate()` and the entity is in the
  physics object. Doing so will double-simulate the object.
  
  Torques and angular velocities are interpreted under the
  `rotation_sign()` at the time that `entity_simulate()`
  is invoked, so ensure that when forces and torques are set
  the sign is the same.


`entity_point_vel(entity, es_pos)`
: Returns the world-space linear velocity of the entity-space point at `es_pos`
  due to `entity.vel` and `entity.spin`. Uses the current
  transformation for determining the direction of spin.


`make_contact_group()`
: Creates a unique value for an `entity.contact_group`.


### Intersections

These are methods for determining intersections and collisions explicitly, without
using the full physics engine.

`axis_aligned_draw_box(e)`
: Returns a box specified by `{pos:xy(), size:xy(), shape:"rect"}` that encloses
  the object `e` (and all of its children if it is an entity) in draw space.

`overlaps(A, B, recurse default true)`
: Returns true if the bounds of `A` and `B` overlap each other, taking
  shape and orientation into account and incuding the borders. Ignores
  `offset` and `z` for entities. Each of `A` and `B` can be any of:

   - an entity from `make_entity()`
   - an `xy()` point 
   - any object with `pos` or `corner`, and optional `shape`, `angle`, `pivot`, and `size` properties
   - any object with `x` and `y` fields, which will be treated as a point

  If `recurse` is true (the default), compares `A` and all of its children
  against `B` and all of its children. This is quadratic in the number of
  elements of each and can be slow for very deep entity hierarchies.

  See `entity.pivot`, `entity.shape`, etc. for discussion of how those properties
  affect the collision detection.

`ray_intersect(ray, entity)`
: The `ray` object must have `xy()` fields for `pos`, `dir`,
  and an optional number field for `length default infinity`.
  The `ray.dir` will automatically be normalized.

  The `entity` has `shape`, `pos`, `size`, and optional `angle`
  properties (an entity satisfies this, but it doesn't have to be a full
  entity). If there is a `entity.child_array`, then that is recursively
  processed and the first intersection encountered is returned.

  Returns the entity hit, or `nil` if there was no intersection.
  The `ray.length` is shortened to the hit distance.

`ray_intersect(ray, array)`
: Returns the first object intersected when calling `ray_intersect(ray, array[i])`
  on each element of the array.
  
`ray_intersect_map(ray, map, layer default 0, sprite_callback default nil, pixel_callback default nil, replacement_array default [], run_callback_on_nil_sprites default false)`
: The `ray` object must have `xy()` fields for `pos`, `dir`,
  and an optional number field for `length default infinity`.
  The `ray.direction` will automatically be normalized.
  The ray is in _world coordinates_.
  
  The return value is the first non-`nil` return value of
  `sprite_callback` or `pixel_callback`, or `nil` if the end of the
  ray is reached.

  The callback signatures are:
  
   - `def sprite_callback(sprite, sprite_pixel_coord, ws_normal, ray, map, ws_distance, ws_coord, map_coord)`
   - `def pixel_callback(sprite, sprite_pixel_coord, ws_normal, ray, map, ws_distance, ws_coord, map_coord)`
   
  Where the `ws_normal` is a unit vector pointing out of the sprite or
  pixel along the face that was hit.  The `sprite_pixel_coord`,
  `ws_normal`, `ws_coord`, and `map_coord` are shared by every
  callback invocation, so make a copy of them if you wish to retain
  those values after the callback returns.
  
  The iterator stops immediately after the first callback returns a
  non-`nil` value and the `ray.length` is shortened to the hit
  distance.

  Invokes the sprite callback first for each sprite entered, and then
  the pixel callback repeatedly for each pixel along the ray in the
  sprite until the next sprite is reached.
  
  Both the sprite callback and pixel callback are optional.
  If neither the sprite callback nor the pixel callback
  is specified, then the default pixel callback is equivalent to:
  
  `def default_pixel_callback(s, p): return if sprite_pixel_color(s, p).a >= 50% then s else nil`

  Does not respect map wrapping.
  
  _The pixel callback is not supported in this release. It will be implemented soon._
  
  

### Engine

The full physics engine provides collision detection, response, and
constraints.

Children of entities in the physics system have no effect on physics. In future
releases they will affect the collision shape, moment of inertia, and mass.

While an entity is in a physics context, the following properties may
not be changed on that entity:

- `shape`
- `size`
- `pivot`, which must always be `xy(0,0)`
- `scale`, except for sign changes

Attachments not moved for scale changes because it is ambiguous how
the attached object should be changed. If you need attachments on
entities that change scale signs, then detach the two entities, move
them, and create a new attachment in the new position.  For example,
when a character flips direction and a rope tied to their hand should
now be on the other side.

Changing the `contact_group`, `contact_hit_mask`, or
`contact_category_mask` on the bodies in an attachment with `collide = false`
after the attachment been created may cause the attached bodies
to start colliding with each other.

`make_physics(options default {})`
: Create and return a new physics context. There can be multiple, independent physics contexts
  in the game. Each entity may only be in one physics context at a time.
  The options are:

  - `gravity default xy(0, -up_y())`: Default gravitational acceleration on all objects.
    Set to `xy(0,0)` and explicitly apply gravity if your game is not set on a planetary
    surface or requires excluding most objects from gravity.
  - `allow_sleeping default true`: Allow simple rigid bodies to fall "asleep" and stop simulating
    until touched. This dramatically increases simulation performance, however some entities
    will fail to properly waken when the object supporting them is removed and can remain
    floating in the air.

`physics_add_contact_callback(physics, callback, min_depth default 0, max_depth default ∞, contact_mask default 0xffffffff, sensors default "exclude")`
: Adds a callback that processes collisions (new contacts) at the end of `physics_simulate()`.
  If either entity in the collision has a `entity.contact_category_mask` that intersects the `contact_mask`
  and the collision has `depth &gt;= min_depth`, then your `callback(args)` will be invoked. The `callback`'s `args` object has the following 
  properties:
  
  - `entityA`: An entity in the contact
  - `entityB`: The other entity in the contact
  - `point0`: An `xy()` in world coordinates for the contact point
  - `point1`: If two points are touching in the contact, the second
    `xy()` in world coordinates. Otherwise `nil`
  - `normal`: The `xy()` unit surface normal pointing out of `entityA`
    for the contact plane
  - `depth`: a coarse measure of how hard the objects hit each
    other. It has a useful scale from 0-4.

  This is good for triggering particle effects or sound on collisions,
  or causing damage to objects. When doing so, use the parameters to filter:
  for example, `min_depth` = 1 will only trigger on significant,
  new contacts. There is no way to remove a contact callback. To make
  per-entity object-oriented callbacks, install a generic one that defers to
  the entities. For example,

  ```
  def on_contact(args): 
      with entityA, entityB, normal in args:
          if entityA.on_contact: 
             entityA.on_contact(entityA, entityB, normal)
          if entityB.on_contact:
             entityB.on_contact(entityB, entityA, -normal)
  ```
           
`physics_entity_has_contacts(physics, entity, child_region default ∅, world_normal default ∅, mask default 0xffffffff, sensors default "exclude")`
: Returns true if `physics_entity_contacts()` would produce any contacts with the same arguments.
  This is more efficient, for the case where the actual contacts are not needed.

`physics_entity_contacts(physics, entity, child_region default ∅, world_normal default ∅, mask default 0xffffffff, sensors default "exclude")`
: Returns an array of all current contacts, where each contact has the form
  `{entityA, entityB, depth, point0, point1, normal}`. The contact points are
  in draw coordinates.

  The region, mask, normal, and sensors setting are used to filter the contacts
  returned. A contact must have nonzero `contact_mask bitand
  otherEntity.contact_category_mask` for the _other_ entity
  involved. The average position of point0 and point1 must also lie
  within the `child_region`, which is in the entity's reference frame.
  `child_region` is either `nil` (all contacts) or an argument suitable
  for passing to `overlaps()`. If `normal` is specified, then the
  contact normal for the other entity must point within ±80° degrees of
  this vector. This is a draw-space vector. `sensors` may be `"include"`,
  `"exclude"`, or `"only"` (exclusively return contacts with sensors).

  In the returned contacts, the `entity` may be either `entityA` or `entityB`.

  This function is ueseful for determining if entities are currently
  in resting contact, such as whether a character is standing on the
  ground and can jump. In that case, make the `child_region` a box around the
  character's feet and set the `world_normal` to the up vector for the world.
  The `child_region` may have to be very wide (e.g., 2x as wide as the character)
  to encompass locations where contact was briefly made in a previous frame.

  Note that sleeping entities have no contacts.
  See also `physics_add_contact_callback()`.

`physics_add_entity(physics, entity)`
: Add `entity` to this physics context. An entity may only be in
  one physics context at a time. Returns the `entity`.

  Once an entity is added to the physics system, it will be retained
  in the physics system until `physics_remove_entity()` is called.
  Use the `draw_physics()` command or IDE button to debug physics objects
  that correspond to entities which are no longer being drawn.
  
  For efficiency, the `entity.size` and `entity.shape` properties are
  locked at the time that the entity is added to the physics
  context. If you need to change these properties, remove the entity
  from the physics context, change them, and then add it back. Other
  properties may be changed freely every frame.

`physics_attach(physics, type, {entityA, entityB, pointA, pointB, collide default ∅, ...})`
: Attaches two entities to each other or `entityB` to the
  world. `entityA` may be `nil` (the world) or have infinite
  density. `entityB` must be non-`nil` and have finite density. The
  points are optional attachment points in the reference frame of each
  entity.  The attachment points do not have to be within the bounds
  of the entities. The entities are immediately moved to satisfy the constraint
  of the attachment.

  Two entities may not have multiple attachments directly between them. Doing
  so will cause unstable and undefined behavior.

  _There is no relationship to the entity parent/child
  hierarchy_. Entity children are used for explicit
  positioning. Attachments are for letting simulation position
  objects.

  Returns an attachment object, which can be passed to
  `physics_detach()`.

  All attachment types are massless, except for weld, which adds a
  slight amount of mass at the weld point and thus affects net mass
  and moment of inertia.

  If `collide` is false, then the entities cannot collide with each
  other while the attachment is maintained. The default for `collide`
  is `true` for spring and rod attachments and `false` for all
  other types.  You can also disable collisions by putting the objects
  in the same `entity.contact_group`, which is more efficient.

  Attached entities cannot sleep.

  The supported values of `type` and the additional named parameters supported for each are:

  <table class="nested">
    <tr><th>`type`</th>
        <th width=70%>Description</th>
        <th>Parameters</th>
    </tr>
    
    <tr><td>`"pin"`</td>
        <td>Prevents translation, allows rotation. A.k.a. revolute joint.</td>
        <td></td>
    </tr>
    
    <tr><td>`"spring"`</td>
         <td>Applies force to pull length back to a target distance.</td>
         <td>`length default ‖pointB - pointA‖`, 
             <br>`stiffness default 0.5%`, 
             <br>`damping default 0.2%`</td>
    </tr>
    <tr><td>`"torsion_spring"`</td>
        <td>Prevents translation, allows rotation, and applies torque to pull the angle back
            to a target.</td>
        <td>`angle default entityB.angle -` `(if entityA then entityA.angle` `else 0°)`, 
            <br>`stiffness default 0.5%`,
            <br>`damping default 0.2%`</td>
    </tr>
    <tr><td>`"rod"`</td>
         <td>Rigidly maintain a fixed distance</td>
         <td>`length default ‖pointB - pointA‖`</td>
    </tr>
    
    <tr><td>`"weld"`</td>
        <td>Rigid attachment with the specified relative angle. <!-- It is more stable and efficient to
            call `physics_remove_entity(physics, entityB)` and `entity_add_child(entityA, entityB)`
             than to weld within the physics system. --> Requires `entityA` to be non-`nil`.</td>
        <td>`angle default entityB.angle - entityA.angle`</td>
    </tr>

    <tr><td>`"gyro"`</td>
        <td>Free translation, but frozen rotation relative to each other.
            Useful for keeping characters upright. `entityA` must be `nil`. This kind of
            attachment is referred to in other APIs as a Cartesian joint or generalized 2D prismatic joint.</td>
        <td>`angle default entityB.angle`</td>
    </tr>
  </table>

   <!--
   - `"hinge"`:  `minAngle`, `maxAngle`. If the hinge is unconstrained, use a pin.
   - `"rope"`:   `length`. If the rope will always be under tension, use a rod.
   - `"joint"`:  `minAngle`, `maxAngle`, `angle`, `stiffness default 100%` -->

`physics_detach(physics, attachment)`
: Remove this attachment, which was previously created by `physics_attach()`.

`physics_remove_all(physics)`
: Remove all entities and attachments from this physics context.

`physics_remove_entity(physics, entity)`
: Remove `entity` and all attachments for it from the physics context.
  Does nothing if the `entity` was not already in this physics
  context.  If called from within a collision callback, removal calls
  are delayed until the end of `physics_simulate()`.  See also
  `physics_add_entity()`.

`physics_simulate(physics, frames default 1)`
: Simulate physics for this many frames, treating all forces and torques
  as constant over that period. Automatically calls `entity_update_children()`
  on all entities in the context.

  Unlike `entity_simulate()`, `physics_simulate()` does not simulate z
  velocity or force, however, it preserves those values if they are
  specified using an `xyz()` for `pos`, `vel`, and `force`.

  Do not call `entity_simulate()` on objects that are in the
  physics world or they will be double simulated.
  
  Torques and angular velocities are interpreted under the
  `rotation_sign()` at the time that `physics_simulate()`
  is invoked, so ensure that when forces and torques are set
  the sign is the same.


Graphics
---------------------------------------------------------


### Colors

Colors in quadplay are interpreted in the
[sRGB](https://en.wikipedia.org/wiki/SRGB) color space and are on the
range 0 to 1 for each channel.  Although the screen and GPU operate in
4-bit per channel mode, arbitrary colors (including negative and out
of gamut ones) can be represented using these types.

All drawing routines accept an `rgb()`, `rgba()`, `hsv()`, `hsva()`,
or a sprite as a color. When a sprite is passed, the center pixel
of the sprite is used. Sprites as colors are the fastest, which
is useful for significant numbers of `draw_point()` calls. See the
[Clouds](../console/quadplay.html?game=quad://examples/clouds&IDE=1)
example program. The performance difference is negligible for other
drawing routines.

Quadplay internally stores 16-bit per pixel colors in the sRGB color
space for sprites and the framebuffer. Drawing commands accept
floating point sRGBA or HSVA colors, where all fields are on the range
0-1. HSL is not directly supported, but can be converted to and from 
HSV using:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
def hsl_to_hsv(src):
    const S = src.s * min(src.l, 1 - src.l)
    const V = S + src.l
    return hsv(src.h, 2 S / max(V, ε), V)

def hsv_to_hsl(src):
    const L = src.v * (1 - ½ src.s)
    const S = if (L ≤ 0 or L ≥ 1) then 0 else (src.v - L) / min(L, 1 - L) 
    return {h:src.h, s:S, l:L}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`artist_hsv_to_rgb(hsv)`
: Object version.

`artist_hsv_to_rgb(h, s, v)`
: Returns an `rgb` that uses a perceptual and RYB-primary system to
  interpret the hue and value. In this system, `h=0/6` is red,
  `h=2/6` is yellow, `h=3/6` is green, and `h=4/6` is blue.
  The blue primary is tilted a little towards cyan in sRGB space
  and the values of the blue hues are boosted. See also `perceptual_lerp_color()`.

`gray(n)`
: Returns `rgb(n, n, n)`, with `n` clamped to the range 0 to 1.

`gray(color)`
: Returns `rgb(n, n, n)`, with `n` equal to a perceptually-weighted average of the rgb values from color.
  The RGB --> gray conversion algorithm weights will likely change in a future release.

`hsva(h, s, v, a default 1)`
: Returns an object with field `h` _wrapped_ to [0, 1], and fields `s`, `v`, and `a` clamped to [0, 1].

`hsva(hsv, a default 1)`
: Clone the `hsv` object, adding an `a` property.

`hsva(rgb, a default 1)`
: Convert the `rgb` value to hsv and add an `a` property.

`hsva(rgba)`
: Convert the `rgba` to hsva.

`hsva(hsva)`
: Clone the `hsva` object, stripping other properties.

`hsva(array)`
: Reinterpret the array elements as an `hsva`

`hsva(sprite)`
: Returns the hsva value of the center pixel of the sprite.

`hsv(hsv)`
: Clone the `hsv` object, stripping other properties (such as an `a` channel).

`hsv(rgb)`
: Convert the `rgb` to hsv.

`hsv(array)`
: Reinterpret the array elements as an `hsv`

`hsv(h, s, v)`
: Returns an object with field `h` _wrapped_ to [0, 1], and fields `s` and `v` clamped to [0, 1].
  `h=0` and `h=1` are red, `h=1/3` is green, and `h=2/3` is blue, with values inbetween
  interpolated. These are the standard hues in a computer RGB-primary system.
  See also `artist_hsv_to_rgb()` for RYB-primary hues.

`hsv(sprite)`
: Returns the hsv value of the center pixel of the sprite.

`perceptual_lerp_color(c1, c2, t)`
: Both `c1` and `c2` must have the same type: `hsv()`, `hsva()`, `rgb()`, or `rgba()`.
  Performs a linear interpolation in CIELAB perceptual space and returns a value
  in the original color space. See also `lerp()`, `smoothstep()`, and `smootherstep()`,
  which can be applied to colors, and `artist_hsv_to_rgb()` for initializing
  from RYB-primary hues.

`rgb(hsv)`
: Convert the `hsv` result to rgb, stripping other properties.

`rgb(rgb)`
: Clone the `rgb` value (stripping other properties, such as an `a` property).

`rgb(array)`
: Reinterpret the array elements as an `rgb`

`rgb(r, g, b)`
: Create a structure with properties `r`, `g`, and `b` clamped to [0, 1].

`rgb(sprite)`
: Returns the rgb value of the center pixel of the sprite.

`rgb(string)`
: Returns the rgb value of hex-constant string such as "#F03".

`rgb_to_xyz(c)`
: Returns `{x: c.r, y: c.g, z: c.b}`.

`rgba(rgb, a default 1)`
: Clone the `rgb` value and add an alpha property.

`rgba(rgba)`
: Clone the `rgba` value, stripping other properties.

`rgba(array)`
: Reinterpret the array elements as an `rgba`

`rgba(r, g, b, a default 1)`
: Create a structure with properties `r`, `g`, `b`, and `a` clamped to [0, 1].

`rgba(hsva)`
: Convert the `hsva` result to rgba.

`rgba(hsv, a default 1)`
: Convert the `hsv` result to rgb and add an `a` property.

`rgba(string)`
: Returns the rgba value of hex-constant string such as "#F03"

`rgba(sprite)`
: Returns the rgb value of the center pixel of the sprite.

`unparse_hex_color(c)`
: Returns a color string of the form `#rrggbb` or `#rrggbbaa` from any color input.
  See also `unparse()`.

Colors can also be constructed using the syntax of HTML hexadecimal colors (which are also
shown in Photoshop and other drawing programs) using the syntax:

- #RRGGBBAA
- #RRGGBB
- #RGBA
- #RGB
- #LL (gray)
- #L (gray)

For example, `#F08` is equivalent to `rgb(1, 0, 0.5333)` and `#CC` is
equivalent to `gray(0.8039)`.

     --------------------------------------------------

The <quadplay/> uses 4:4:4:4 RGBA color, for a total of 4096 different colors and
16 levels of transparency including fully-transparent.

It can draw perfect 16-shade gradients of red, green, blue, yellow,
magenta, cyan, and gray, where the darkest shade of each of those is
black.

Blending into the screen is based on z-order, not draw order, and
is always the Porter-Duff over-compositing rule:

 `result.r = back.r * (1 - front.a) + front.r * front.a`

and so on for `g` and `b`. The runtime is free to implement this
blending exactly using sorted draw calls or an A-buffer, or to
approximate it with alpha-to-coverage and multisampling or
fixed-memory order-independent pixel shading techniques. Blending
guarantees at least five bits per channel of intermediate precision
and four bits per channel of framebuffer storage, but implementations
may use more.

Colors are specified as objects that have either `r`, `g`, and `b`;
or `h`, `s`, and `v` fields, and an optional `a` field. All color
channels are on the range 0-1 and snapped to discrete
values. Additional fields in color objects are ignored.

Many routines accept both a "fill" color for the interior and a
"border" color for the perimeter.  Set either to transparent (`nil`)
to efficiently disable that portion of rendering.

The `nil` value is transparent.

Borders are drawn inside shape coordinate boundaries and on top of
fills, so a transparent border is identical to a border that is the
same color as the fill. Shapes include their endpoints and borders.


### Drawing

`draw_corner_rect(corner, size, color, outline default ∅, z default corner.z default 0)`
: Draw a rectangle covering all of the pixel centers between `corner`
  and `corner + size`. This is primarily for UI window drawing.
  `size` may be negative.

  If the top or right sides exactly touch a pixel center (at a
  half-integer), then they do not cover it. The direction in which the
  `size` applies is determined by the current transform. Note that if
  `up_y()` is positive, then the rectangle will extend _upward_ from
  the corner.

  See also `draw_rect()`.

`draw_corner_rect(args)`
: Named argument version of `draw_corner_rect()`.

`draw_disk(pos, radius, color, outline default ∅, z default pos.z default 0)`
: Draw a circle or filled disk centered at (`pos.x`, `pos.y`)
  with radius `radius` and z-order `z`.
  
  Choose the radius to be a half-integer, such as 3.5, and place
  the position at a half-integer if you want it to be centered on a pixel.
  
  Guarantees:
   - zero self-overdraw within the circle (important when using alpha)
   - zero overdraw between the circle outline and filled interior disk
   - disk exactly inscribes the containing rectangle 
   - the total number of pixels covered will not change size under subpixel translation if the circle radius is an integer or half-integer

`draw_disk(args)`
: Object version of `draw_disk()`.

`draw_line(A, B, color, z default A.z default 0, width default 1)`
: Draw a line from (`A.x`, `A.y`) to (`B.x`, `B.y`) using z-order `z`.
  When using the default transformation, put the endpoints at half-pixel
  positions for the best alignment with the pixel grid.
  
  The endpoints of the line are transformed independently by `camera.zoom`,
  so 3D perspective can be obtained.
  
  The `width` will be scaled by the `camera.zoom`. The line is always
  at least one pixel thick in screen space.

`draw_line(args)`
: Named argument version of `draw_line()`.

`draw_point(pos, color, z default pos.z default 0)`
: Set the color of pixel (`pos.x`, `pos.y`) to color `color` with z-order `z`.
  A series of `draw_point` calls with the same `z` value are about twice as
  fast as ones with mixed `z` values or intermixed with other draw calls.
  For the best alignment under the default transformation, put the endpoints
  at half-pixel positions.

`draw_point(args)`
: Named argument version of `draw_point()`.

`draw_poly(vertex_array, color, outline default nil, pos default xy(0, 0), angle default 0, scale default xy(1, 1), z default pos.z default 0)`
: Draws the _convex_ polygon defined by the `vertex_array`, first
  scaling by `scale`, rotating by `angle`, and then translating by
  `pos`. The polygon may have any winding direction. If the polygon is
  not convex, then the outcome of the drawn result is undefined and
  may change across platforms (but there will never be an error).
  See also `convex_hull()`.

`draw_poly(args)`
: Named argument version of `draw_poly()`.

`draw_previous_mode()`
: Re-issue all of the drawing commands from the previous mode's frame
  that completed before the `set_mode()` call. These are not
  affected by the current `clip` or `transform`. The calls are in full
  2.5D, so calls from this mode may insert graphics between them in
  the z-order.  Useful for drawing the main game background during
  inventory, pause, menu, and dialogue modes.

`draw_rect(pos, size, color, outline default ∅, angle default 0, z default pos.z default 0)`
: Draws the rectangle _centered_ at `pos` with the given `size` and `angle`.
  No `scale` argument is provided because it is easy for the caller to
  explicitly multiply `size` by `scale`.
  See also `draw_corner_rect()` and `draw_sprite_corner_rect()`.

`draw_rect(args)`
: Named argument version of `draw_rect()`.

`draw_sprite(sprite, pos, angle default 0°, scale default xy(100%, 100%), opacity default 100%, z default pos.z default 0, override_color default rgba(0,0,0,0), override_blend default "lerp", pivot default sprite.pivot)`
: Draw sprite `sprite` with its center at `pos`. `pos` must have at
  least `x` and `y` fields. The sprite appears at `z` in the z-order
  (defaults to 0). If specified, the `scale` parameter must be a
  number that is not zero, or an `xy()` with nonzero fields.  Scale is
  applied before the sprite is rotated.  Sprites are not flipped or
  scaled by `set_transform` values, but the rotation and center are
  affected by the `set_transform` scaling.

  If it is not `nil`, the `override_color` blends with the red, green,
  and blue values read from each pixel of the sprite. The default
  blend mode is `"lerp"`, which interpolates between the sprite color
  and the `override_color` based on `override_color.a`. The other
  blend operation supported is `"multiply"`, which multiplies the `r`,
  `g`, `b` values and ignores the `override_color.a`. The alpha value
  of the result is always the sprite's original alpha value. Useful
  for simulating lighting, turning a sprite into a shadow silhouette,
  or flashing a sprite a different color to indicate hits or
  invincibility.
  
  The `pivot` is in the sprite's coordinate system relative to its
  center, so it is affected by the `angle` and `scale`.
  
  The `z` value is used for ordering. The value `pos.z default z`
  is used for camera zoom perspective and transform skew.

`draw_sprite(args)`
: Keyword version of `draw_sprite()`. Pass an object that has properties
  whose names match the arguments of the positional version. For example,
  `draw_sprite({sprite: wizard, pos: xy(100, 100), z: 2})`.
  Values default according to the positional argument version.

`draw_sprite_corner_rect(sprite, corner, size, z default 0)`
: Draw a rectangle enclosing points `corner` and `corner+size`
  filled with `sprite` tiled as needed (and aligned to the
  center), and surrounded by the neighbors of `sprite`
  in its spritesheet. The edges surround the specified coordinates.
  Used for drawing user interface elements (GUI) of dynamic size such as
  windows and health bars.  Keep in mind that some artwork is designed
  to only be stretched in one dimension, or to tile only at integer
  multiples.

  See also `draw_corner_rect()` and `draw_rect()`.
  
  This routine ignores the global camera. That may change before SDK version 1.0.

`draw_text(font default ∅, text, pos, color default ∅, shadow default ∅, outline default ∅, x_align default "center", y_align default "center", z default pos.z default 0, wrap_width default ∅, text_size default size(text), markup default false)`
: Print string `text` relative to `pos`. If the font is unspecified,
  it defaults to the <quadplay/> system 8-pixel font.

  Returns a camera-space bounding box _that is clipped to the current
  clipping region_ of the text rendered. This bounding box has fields `{pos: xy(), size: xy(), height:h,
  z:z}` that contains the text but not shadows and outlines. This
  bounding box is conservative in height and accounts for the highest
  ascender and accent and lowest descender. The `height` is the
  vertical size before clipping, which is useful for
  layout. `overlaps(bounds, touch)` is convenient for recognizing when
  the player has touched the text. The bounds are tight in width and
  tailored to the exact characters. The bounding box also does not
  include the spacing that should be added between consecutive
  lines. The `pos` property will have `nan` values if the bounds are
  entirely clipped. _In future versions, there may be more fields on
  the bounding box object to identify the location of markup
  sections._
  
  Use `font.line_height` to know how far to place separate lines
  vertically or simply use strings with `"\n"` characters in them to
  print multiple lines.
  
  The positioning of text will follow the transform and camera, but
  individual letters always draw upright and 1:1 pixel perfect,
  without flipping, rotation, or scaling, no matter what the transform
  or camera are.

  `x_align` options:
    - `-1` or `"left"` = left
    - `0` or `"center"` = center
    - `+1` or `"right"` = right

  `y_align` options:
    - `-1` or `"top"` = top
    - `0` or `"center"` = center vertically based on the font (not actual characters, so that alignment won't change with different characters in the text)
    - `+1` or `"baseline"` = baseline of the first line of text
    - `+2` or `"bottom"` = bottom of the block of text

  `font` must be loaded from the assets.  Color, shadow, and outline
  default to transparent. Any non-transparent outline causes the
  shadow to move below both the outline and main color. If `nil`, the system's
  default 8-pixel high font is used.
  
  If `wrap_width` is specified, breaks the text at the maximum width
  and renders multiple lines. Each line is offset by the font's
  vertical spacing and aligned as specified. See also `text_width()`.

  `text_size` restricts draw_text to only printing that many characters,
  *after* word-wrapping. This allows gradually revealing text in a stable
  way under word wrap.

  `markup = true` enables special syntax for changing the style within
  a single string and removes single linebreaks, in order to make it
  easier to import long text strings from constants or data files. 
  
  The markup syntax is `"...{property:value text...}..."`.
  The valid property names are `color`, `font`, `shadow`, and `outline`.
  That property is valid from the beginning brace to the end one. Only
  one property can be changed per brace, and braces can be nested.
  For strings that word wrap, the vertical spacing of lines is based
  on the original font specified as an argument to `draw_text()`, so
  using very different fonts can result in poorly formatted output.
  The legal values are colors specified using `rgba()`, `rgb()`, `hsva()`,
  `hsv()`, or `gray()` with numbers, the `#` color syntax, or the
  names of constants specified in the `game.json` file. Variables
  and expressions are not permitted in the values. 
  
  To insert a regular brace within markup, use a slash escape, which
  must be typed in a string using a double slash: `"\\{"` or `"\\}"`.
  
  To insert a single linebreak within markup, use `"{br}"`.

`draw_text(args)`
: Keyword version of `draw_text()`. Pass an object that has properties
  whose names match the arguments of the positional version. For example,
  `draw_text({text: "Fire!", pos: xy(100, 100), x_align:"left", z: 2})`.
  Values default according to the positional argument version.

`draw_tri(A, B, C, color, outline default ∅, pos default xy(0, 0), angle default 0, scale default xy(1, 1), z default pos.z default 0)`
: Scale `A`, `B`, and `C` by `scale`, rotate them around the origin by `angle`, translate
  by `pos`, and then draw the triangle. The `pos` argument is not first because in many
  cases this is called with draw-space vertices and no translation. The triangle may have
  any winding direction.

`draw_tri(args)`
: Named argument version of `draw_tri()`.

`get_background()`
: Returns the value previously set with `set_background()`.

`get_clip()`
: Returns the current net clipping region as an object that
  can be passed to `set_clip()`.

`intersect_clip(corner default ∅, size default ∅, z default ∅, z_size default ∅)`
: Intersect the current clipping region with this new one. Ignores the
  current transformation.

`intersect_clip(args)`
: Object version of `intersect_clip()`.

`reset_clip()`
: Reset to the default clipping region, `set_clip(xy(0, 0), SCREEN_SIZE, -2047, 4096)`.

`set_background(color default #000)`
: Replace the background with this color. The background is automatically
  drawn each frame with the last value set.

`set_background(sprite)`
: Replace the background with this sprite, which must be the exact size of
  the screen and in a spritesheet that is the exact size of the screen.

`set_clip(corner default ∅, size default ∅, z default ∅, z_size default ∅)`
: Set the clipping region to this corner rectangle in screen
  space. Unspecified and `nil` values retain their current
  value. `corner` is the upper-left corner.  `corner` and `size` must be
  `nil` or `xy()` values.  Coordinates are clamped to the physical
  screen and z to the range [-2047, 2048]. `size` and `z_size` may be
  negative. It is impossible to set a clipping region smaller than
  1x1x1 pixels.

`set_clip(args)`
: Object version of `set_clip()`.

`text_width(font, s, markup default false)`
: Returns the pixel width of string `s` in this font, including border padding.
  Note that leading and trailing numbers may incur additional empty space for
  column alignment. If `markup` is true, then `s` is processed using the
  markup rules from `draw_text()`.

`xy(x, y)`
: Create a structure with values `x` and `y`, which can be used with most drawing routines.

`xy(xy)`
: Clone the `xy` value, stripping other properties (such as a `z` property).

`xyz(x, y, z)`
: Create an object `x`, `y`, and `z` properties, which can be used with most drawing routines.

`xyz(xyz)`
: Clone the `xyz` value, stripping other properties.

`xyz(xy, z default 0)`
: Clone the `xy` value, adding a `z` property.

           --------------------------------------------


![Text styling options](text-style.png width=500%)


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
set_background(#FFF)

// Make the text color clear to draw outlines.
draw_text(goodNeighbors, "Transparent", xy(83, 155), rgba(0,0,0,0), nil, #0)

// Make the bottom outline look thick by making the shadow and outline
// the same color.
draw_text(goodNeighbors, "Thick Bottom", xy(83, 170), #2AF, #0, #0)

// Draw an explicit shadow wherever you want it
draw_text(goodNeighbors, "Offset Shadow", xy(85, 184), rgba(0,0,0,25%))
draw_text(goodNeighbors, "Offset Shadow", xy(83, 182), #0A0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Tricks with text styling]

![Tricks with text styling](text-tricks.png width=200%)


               ------------------------------------

Font assets have the following properties:

`font.line_height`
:  Vertical spacing between baselines in multiline text. Advance the `y`
   coordinate of a position by this much if explicitly rendering multiline
   text (you can also just put newlines in the text or use the `wrap_width`
   argument for automatic multiline).
   
   The `line_height` is not the vertical bounds of all characters. Some
   characters may exceed the spacing because they have especially high
   accents or ascenders or low hooks and descenders.

`font.spacing`
: `xy()` spacing between characters vertically and horizontally.

`font.glyph_size`
: `xy()` width and height that will bound all characters in this font, 
  not including border or shadow. The `font.glyph_size.y` is usually
  less than `font.line_height`, which only considers the typically highest
  and lowest characters in English.


Good bounds for centered text are `xy(text_width(font, text), font.line_height)`.
Some accents or descenders for exceptional cases
may stick out of these bounds vertically. 


### Post Effects

The final image drawn can be transformed in limited ways during scan
out to the display, as if it were a sprite being drawn to the screen.
Setting any post effects may slow down rendering slightly.

`get_post_effects()`
: Return the current post effects in a form that can be passed to `set_post_effects()`.

`set_post_effects(args)`
: The arguments have the following fields, all optional. `nil` values
  default to their previous value.  Invoke `reset_post_effects()`
  first for a clean set.

  - `color` is an `rgba()` to combine with the the new frame before it
    is composited. Setting the `a` to 0 disables the color.
  - `color_blend` is one of the following strings: `"source-over"`,
    `"difference"`, `"hue"`, `"multiply"` describing how the `color`
    affects the frame before compositing.
  - `scale` is an `xy` for how to stretch the new frame.
  - `angle` is a counter-clockwise angle in radians to rotate the
    image about its center by.
  - `pos` is an `xy` translation from the center, with +y = down.
    Not visible in screenshots or GIFs
  - `motion_blur` is the amount of the previous frame to 
    maintain into the new frame. The initial value is `0%`.
  - `afterglow` simulates CRT phosphor afterglow level using a fade color for both hue 
     and intensity. The initial value is `rgb(0, 0, 0)`.
  - `bloom` is the amount of overdrive to use on bright areas of the
    screen. This may affect performance on slower machines. The default of `0%`
    disables the effect, `50%` is a reasonable value, and `100%` is an
    extreme value.

  The visual impact of non-default `motion_blur` and `afterglow`
  is accumulative and so is sensitive to graphics frame rate scaling.
  
  *`bloom` and `burn_in` effects are not visible in <quadplay/> built-in
  screenshot or GIF recording capture.* Use separate whole screen
  capture software to record these effects.
  
  `scale`, `angle`, and `pos` are applied to the entire screen, so 
  do not interact well with multiplayer private views configured via
  `set_screen_size()`.
 
`reset_post_effects()`
: Restore the defaults, which directly composite each frame.


### Resolution

`set_screen_size(size, private_views default false)`
: Erases the current and previous graphics drawing state, including
  all drawing commands for the current frame. Resets the clipping
  region, transform, and camera transform. Switches the screen to the
  new resolution immediately. It is an error to call with an
  unsupported resolution.
  
  `SCREEN_SIZE` will immediately be bound to a new immutable `xy()`
  object that has the new resolution.

  `VIEW_ARRAY` will immediately be bound to a new immutable
  array of corner rect objects.
  
  The `private_views` flag is for implementing per-player private
  screens for online multiplayer play, at reduced resolution. The
  screen configuration is the same as splitscreen multiplayer, except
  that each player can see only their own screen. This is an advanced
  feature and I only recommend it for experienced quadplay developers.
  Quadplay is primarily intended for shared-screen multiplayer and
  private screens are hard to use effectively.
  
  If `private_views == false`, then:
  
  - the supported resolutions are 640x360, 384x224, 320x180, 192x112, 128x128,
    and 64x64
  - global `VIEW_ARRAY[0].size = xy(SCREEN_SIZE)`
  
  
  If `private_views == true`, then:
  
  - the supported resolutions are 384x224 and 128x128 
    (corresponding to 192x112 and 64x64 player views)
    unless other features are enabled with `device_control()`
  - global `VIEW_ARRAY[0].size = SCREEN_SIZE / 2`
  - only the upper left 1/4 of the screen will be displayed on the
    local host machine. When playing online, the other 1/4 screens are
    streamed to P2 (top left), P3 (bottom left), and P4 (bottom right)
    when connected
  - screenshots and video on the host will capture all players's screens
  - the Show Private Views option in the Tools menu overrides the
    cropping when debugging


In private screen mode with y increasing upwards, the player with
index `0 ≤ p < 3` has screen corner at `½ SCREEN_SIZE * xy(p ∩ 1, p >> 1)`.

To set up rendering for both private views and unified screens, use:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Pyxlscript
for view at view_index in VIEW_ARRAY:
    set_clip(view)
    set_transform(view.corner)
    const gamepad = gamepad_array[view_index]
    // Your draw code here
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Always draw all views for connected players. All of the code runs on
the host machine.  Program exactly as if it was split-screen local
multiplayer, but with the knowledge that each player can only see
their own screen.

In the current API, private views are for pixels only--there is no per-player 
private _audio_.

<center>
<table style="font-size:200%; border-collapse:separate" cellspacing=0>
<tr>
<td style="color:#f5a; border: 3px solid; width:200px"><div style="text-align:left;font-size:50%">(0,0)</div><center>*P1*<br><span style="font-size:50%">Host</span></center></td>
<td style="color:#0af; border: 3px solid; width:200px"><div style="text-align:left;font-size:50%">(192,0)</div><center>*P2*<br><span style="font-size:50%">1st Guest</span></center></td>
</tr>
<tr>
<td style="color:#fd3; border: 3px solid"><div style="text-align:left;font-size:50%">(0,112)</div><center>*P3*<br><span style="font-size:50%">2nd Guest</span></center></td>
<td style="color:#4e4; border: 3px solid"><div style="text-align:left;font-size:50%">(192,112)</div><center>*P4*<br><span style="font-size:50%">3rd Guest</span></center></td>
</tr>
</table>
</center>

Map
---------------------------------------------------------------------------

A map asset has the following fields. The sprites in the map can be
changed at runtime (maps are the only mutable assets). Use `deep_clone(map)`
to make a copy of a map at runtime if you will want the original and plan
to mutate the asset.


`map[x][y]`
: The sprite at `x, y` in integer map coordinates in layer 0, or `nil` if empty.

`map.layer[L]`
: A 2D array of the contents of layer `L`.

`map.layer[L][x][y]`
: The sprite at `x`, `y` in layer `L`, or `nil` if empty.
  The elements *can* be changed at runtime.

`map.size`
: `xy()` size in map coordinates (not pixels).

`map.size_pixels`
: `xy()` size in pixels.

`map.spritesheet_table`
: A table mapping TMX tile set names to spritesheets for this map.

`map.spritesheet`
: For maps with a single spritesheet, this is the spritesheet.

`map.sprite_size`
: The `xy()` size of source sprites in pixels.

`map.offset`
: `xy()` offset of the map when reading:
  `ws_coord = map_coord * map.sprite_size + map.offset`

`map.loop_x`
: If true, the map wraps horizontally. Array access does not automatically
  wrap, but functions such as `get_map_sprite()`, `map_find_path()`, and `get_map_pixel_color()`
  will implement wrapping. See details on each map function to see how it supports wrapping.

`map.loop_y`
: If true, the map wraps vertically. Array access does not automatically
  wrap, but functions such as `get_map_sprite()`, `map_find_path()`, and `get_map_pixel_color()`
  will implement wrapping. See details on each map function to see how it supports wrapping.
  
`map.z_offset`
: Amount to add to each layer index when computing a z value for rendering.
  `layer = (z - map.z_offset) / map.z_scale`; `z = layer * map.z_scale + map.z_offset`.
  See also `transform_ws_to_map_space()` and `transform_map_space_to_ws()`.

`map.z_scale`
: Amount to multiply each layer index to compute a z value for rendering.
  `layer = (z - map.z_offset) / map.z_scale`; `z = layer * map.z_scale + map.z_offset`.
  See also `transform_ws_z_to_map_layer()` and `transform_map_layer_to_ws_z()`.

Any other custom properties set on the map in the TMX file are added to this set of
properties.

The following functions relate maps, pixels, and sprites. In them, a
"pixel coordinate" is in the _pre-transformed_ space in which graphics
commands operate and a "map coordinate" is in the space of the map
indices. The map's z-axis corresponds to layers.

`draw_map(map, min_layer default 0, max_layer default length(map.layer), replacement_array default ∅, pos default xy(0, 0), angle default 0, scale default xy(1, 1), z default pos.z default 0, override_color default rgba(0,0,0,0), override_blend default "lerp")`
: Draws the map with the current transform.  If there is no transform,
  the map is drawn with the first tile's center at (0, 0), which means
  that the tile will be half off the screen.  If specified, `min_layer`
  and `max_layer` determine the inclusive range of layers to draw.  Map
  rendering ignores skew transformations...typically the skew will be
  implicit in the map's layout and rendering.

  If `replacement_array` is specified, it must be an even length array
  of the form `[from0, to0, from1, to1, ...]`.  Each `from` value is a
  sprite in the map. It will be replaced during drawing with the
  corresponding `to` value. The `to` values may also be `nil`.

  If specified in the source `.json` file, the map will wrap
  appropriately horizontally or vertically when drawn, if it is large
  enough to covers at least 1/3 of the current clipping area.
  
  The `pos`, `angle`, and `scale` apply the position of the map as if
  it was a giant object, with the origin centered at the center of
  tile (0, 0).  Using a non-default `angle` and `scale` will
  approximately double the cost of drawing the map.
  
  For wrapping maps, the map is rendered 9x (at very little
  performance penalty). It does not tile infinitely.
  If the game explicitly relocates the camera when it has moved
  off of the end of the map, then it will _appear_ infinite in game.
  
  The `z` value is used for z ordering. The value `(pos.z default z)`
  is used for transform skew and perspective camera zoom. The `map.z_scale`
  and `map.z_offset` affect both.

`draw_map(args)`
: Draw the map using the named argument object.

`draw_map_span(start, size, map, map_coord0, map_coord1, min_layer default 0, max_layer_exclusive default +infinity, replacement_array default [], z default start.z default 0, override_color default rgba(0,0,0,0), override_blend default "lerp", invert_sprite_y default (get_transform().dir.y < 0), quality default 100%)`
: Draws a perfectly horizontal (regardless of the camera) span of constant z with pixel colors taken from the map.
  This is a key primitive for building fast perspective rendering of horizontal surfaces.  See the
  Kart and Warlock 3D examples. It can also be used for 2D textured polygon rendering.
  
  `start` is an `xy()` or `xyz()` value on screen at the left edge of the
  span. `size` is the extent of the span, which must be 0 along the
  `y` axis (vertical spans are reserved for future expansion). 
  The span will be transformed by the `camera.pos`, but does not rotate with
  the `camera.angle`.  `map_coord0` is an `xy()` in map coordinates for the source colors,
  which corresponds to the `start` pixel on screen. `map_coord1` is
  the end coordinate in map coordinates.
  
  `map`, `replacement_array`, `min_layer`, `max_layer_exclusive`, and `invert_sprite_y` 
  are as for `get_map_pixel_color()`.
  
  `override_color` and `override_blend` are as for `draw_sprite()`.
  
  `quality` is a number between 0% and 100% that affects the texture mapping precision.
  The implementation details may change in the future. In the current implementation,
  any value below 50% samples at half resolution.
  
  Respects the wrapping and wraps infinitely.

`draw_map_span(args)`
: Object version of `draw_map_span()`.

`map_find_path(map, start_xy, goal_xy, edge_cost, cost_layer default 0, use_sprite_id default true)`
: Specialized version of `find_path` for maps. The start and end positions
  are rounded down to the nearest integer map coordinates. The `edge_cost`
  is either a function or an array. The function returns an array of
  map coordinates to visit or `nil` if no traversable path exists.

  The function version is `def edge_cost(A, B, map)`. It returns the
  cost of traversing from `A` to `B` in the map, where each is an
  `xy()`. That cost should always be nonnegative. It should be 1 for a
  typical edge, `infinity` for an edge that is not traversable, and
  higher or lower than 1 for edges of varying difficulty such as
  walking through rough terrain or downhill.

  The array version of `edge_cost` is an array of pairs of the form
  `[sprite0, cost0, sprite1, cost1, ...]`. Each cost corresponds to
  entering that sprite on `map.layer[cost_layer]`. These are the `B`
  values from `edge_cost`. Empty map cells and sprites that are not specified in the array
  cost 1 to traverse, and it costs `infinity` to leave the map bounds.
  Sprites are matched by their `sprite.id` if `use_sprite_id` is true,
  otherwise they must exactly match, including orientation.
  
  Supports map wrapping.

`get_map_pixel_color(map, map_coord, min_layer default -infinity, max_layer_exclusive default +infinity,replacement_array default ∅, result default ∅, invert_sprite_y default false)`
: Returns the color of the pixel in `map` at the corresponding
  `map_coord` and all layers between `min_layer` and `max_layer_exclusive`.
  If an `rgba()` value `result` is provided, then that object is mutated and returned to
  avoid memory allocation.
  
  Returns `nil` for out of bounds values and empty sprites if `result` is not specified, and
  sets `result.a = 0` in those cases if it is present. See also
  `get_map_pixel_color_by_ws_coord()`.
  
  If `invert_sprite_y` is true, then individual sprites pixels are
  read upside down. This is needed in rare cases where the transform's
  _y_ direction was changed between when the map itself was drawn and when
  the pixel was read.

`get_map_pixel_color_by_ws_coord(map, ws_coord, ws_z_min default -infinity, ws_z_max_exclusive default +infinity, replacement_array default ∅, result default nil)`
: Returns the pixel color in `map` at the corresponding `ws_coord`
  by compositing all layers between `ws_z_min` and `ws_z_max_exclusive`. The result is guaranteed
  to match what was drawn by `draw_map()`. If `result` is specified, that `rgba()`
  value is mutated and returned instead of allocating a new color.
  
  Returns `nil` for out of bounds values and empty sprites, or a result with `result.a = 0`
  if `result` is specified.
  
  Respects the wrapping and can wrap infinitely.
  
  See also `get_map_pixel_color()`.

`get_map_sprite(map, map_coord, layer default 0, replacement_array default ∅)`
: Returns the sprite in `map` at the corresponding `map_coord` and
  `layer` using rounding. Returns `nil` for out of bounds values. See
  also `get_map_sprite_by_ws_coord()`. Respects the wrapping and can wrap
  infinitely.

`get_map_sprite_by_ws_coord(map, ws_coord, ws_z default 0, replacement_array default ∅)`
: Returns the sprite in `map` at the corresponding `draw_coord` and
  `ws_z` using `transform_ws_to_map_space()` and rounding to compute the
  coordinates. Returns `nil` for out of bounds values. See also
  `get_map_sprite()`. Respects the wrapping and can wrap
  infinitely.

`map_generate_maze(args)`
: Replace a layer of the map with a maze. The map is approximately the
  same as its original size, but may be slightly larger or smaller if
  that is needed to satisfy the options.
  
   - `map: map`
   - `layer: number default 0`
   - `hall: {thickness: integer default 1, sprite: sprite default nil} default {}`. 
       Description of the passageways. The `sprite` should be from `map.spritesheet` or `nil`.
       `thickness` is measured in map cells.
   - `wall: {thickness: integer default 1, sprite: sprite default map.spritesheet[0][0]} default {}`. Description of the dividers between passageways and inaccessible aeas. Same options as for `hall`.
   - `horizontal: {border: number default 1, loop: boolean default false, symmetric: boolean default false} default {}`.
      The border is the number of walls (not cells) around the outside of the map. Because
      the wall layers can themselves cover more than one cell, the border can be a fractional
      value to create partial walls on the exterior.
   - `vertical` same options as `horizontal`
   - `shortcuts: number default 0%`. Amount of additional hall connections beyond a 
     continous labryinth path.
   - `straightness: number default 0%`. Preference for long straight halls (100%) vs. short twisty
     ones (0%).
   - `coverage: number default 100%`. Amount of the map layer
     reachable by halls. The remainder is wall.
   - `dead_end_array: array default []`. If provided, then 
     this array will be filled with the `xy()` map coordinates of dead-end
     passageways, which are good locations for spawn points or building rooms.
   - `random: function default random`. Random number generator to use.

`map_resize(map, width default map.size.x, height default map.size.y, layers default size(map.layer))`
: Resizes the map in place. Newly revealed values will be `nil`.  Maps
  should only be resized using this function. There is no guarantee
  that the individual arrays themselves will be preserved--they may be
  reallocated and copied, although the values will be preserved. So,
  do not hold pointers into the map across `map_resize()` calls.

`set_map_sprite(map, map_coord, sprite, layer default 0)`
: Sets the corresponding map sprite. Does nothing if `map_coord` is out of bounds.
  Respects the wrapping and can wrap infinitely.

`set_map_sprite_by_ws_coord(map, ws_point, sprite, ws_z default 0)`
: Sets the corresponding map sprite. Does nothing if `ws_point` is out of bounds.
  Respects the wrapping and can wrap infinitely.

`transform_ws_to_map_space(map, ws_point)`
: Returns the _fractional_ map coordinates of `ws_point`.  See also
  `transform_map_space_to_ws()`. Note that integer map coordinates are
  at the corners of map tiles unless the map JSON has an `offset`.
  
  To account for a map that is rendered by `draw_map()` with its own
  `pos`, `angle`, and `scale`, use `transform_ws_to_map_space(map,
  transform_to(pos, angle, scale, ws_coord))`.

`transform_ws_z_to_map_layer(map, ws_z)`
: Using the current transformation, returns the _fractional_ map layer
  of `z`.

`transform_map_layer_to_ws_z(map, L)`
: Returns the `z` value that will be used for `map` under the current
  transformation.

`transform_map_space_to_ws(map, map_coord)`
: Returns the draw coordinates of `map_coord`. Integer `map_coord`s correspond to the corners of tiles if
  the offset on the map is zero (the default). See also `transform_ws_to_map_space()`
  and `get_map_pixel_color()`.
  
  To account for a map that is rendered by `draw_map()` with its own `pos`, `angle`, and `scale`, use
  `transform_from(pos, angle, scale, transform_map_space_to_ws(map, map_coord))`.


Frame Hooks
----------------------------------------------------------

Frame hooks are useful for registering animation callbacks that happen
at the beginning of every frame or after a set number of frames.

The order of execution between frame hooks is undefined and can change
as hooks expire. The transform for a frame hook is whatever was set at
the end of the previous frame.

When drawing, use `z` arguments to ensure that drawn objects overlap
in the desired order regardless of the order in which drawing executes.

`add_frame_hook(callback, end_callback, frames, run_in_mode default get_mode(), data default nil)`
: Register a `callback` function to run at the end of the "frame" event for the given number of 
  `frames`. The return value of `add_frame_hook()` is a hook that can be
  passed to `remove_frame_hook()`.

  - `callback`: `def callback(frames_left, total_frames, data)`, runs every frame. `frames_left`
    will be `total_frames - 1` on the first frame and `0` on the last one.
    This argument may be `nil`. If the callback returns `true`, the hook
    is removed without running the `end_callback`, otherwise it keeps running.
  - `end_callback`: `def end_callback(data)`, runs on the last frame. Can be `nil`.
  - `frames`: Number of frame events to run for. May be `infinity`.
  - `run_in_mode`: Only execute while the game is in this mode. Use `"all"` to
    run in every mode.

  The frame counter is only decremented if the hook returns. If the
  mode change happens due to `push_mode()`, `pop_mode()`, or
  `set_mode()` inside of the `callback` then the frame counter remains
  and the same callback will execute when the mode returns unless it
  removes itself.

  See also `sequence()` and `delay()` for common cases.

`delay(callback, delay_frames default 0, data default nil)`
: Same as `add_frame_hook(nil, callback, delay_frames, nil, data)`.
  It is often convenient to use a local function defined immediately
  before the `delay()` as the `callback`.
  The delayed callback only runs in the current mode.
  Returns the new frame hook.

`remove_frame_hook(hook)`
: Remove this frame hook immediately, without executing its `end_callback`.
  If the hook has already ended or is not present, nothing happens. If the
  hook is removed while frame hooks are executing, it may still execute
  this frame.

`remove_frame_hooks_by_mode(mode)`
: Remove all frame hooks that are locked to the `mode`. Use `nil` to
  remove all hooks with no mode at all. Do not invoke the
  `endCallback`s on these hooks.

`sequence(...)`
: Add a series of frame hooks that run in the current mode. Returns a master
  hook that can be used with `remove_frame_hook()` to cancel the entire sequence.
  Each argument may be either a function, `nil`, a number of frames to skip, or 
  `{callback: function, begin_callback: function, end_callback: function, frames: number, data: (any value)}`.
  The callbacks only run the current mode.

  Returns a main frame hook that can be removed to cancel the entire sequence.

  The signatures of the callbacks, if not `nil`, are:
  
  - `def callback(frames_left, total_frames, data)`
  - `def begin_callback(data)`, which executes immediately before the first `callback` for that entry.
  - `def end_callback(data)`, which executes immediately after the last `callback` for that sequence entry.

  The callbacks run for the specified number of `frames`, rounded if
  fractional. If the `frames` is less than 1, then none of the
  callbacks for that entry execute at all.
  
  Example: `sequence(6, draw_explosion, {callback: draw_fire, frames: 20}, {callback: draw_smoke, frames: 4, end_callback: cleanup})`.
  Skips 6 frames, runs `draw_explosion` after the 7th, `draw_fire` after each of
  the next 20 frames after that, `draw_smoke` for the next 4 frames after _that_, 
  and then `cleanup` immediately after the last `draw_smoke` in the same frame.
  
  If a callback returns the special value `sequence.NEXT`, then the
  sequence runs the `end_callback` for that entry and advances to the
  next step regardless of the frame count. If any callback returns
  `sequence.BREAK`, then the sequence immediately terminates and does
  not run the `end_callback` for the current entry. All other return
  values are ignored.

  A `sequence` entry can itself trigger a new sequence or `delay()`, although
  be careful not to trigger uncontrolled recursive chains.
  
  Note that `sequence(...array)` allows passing an array of the individual
  callbacks instead of as separate parameters.

  Useful expressions for interpolation within the `callback` are below.
  The table uses mathematical interval notation, where "[start" means
  the closed interval exactly hitting "start" and "(start" is the open
  interval that begins after start, and correspondingly for the "end":
  
  Interval      | Interpolation Expression
  --------------|-----------
  [start, end]  | `lerp(start, end, linstep(total_frames - 1, frames_left))`
  (start, end]  | `lerp(start, end, linstep(total_frames, 0, frames_left))`
  [start, end)  | `lerp(start, end, linstep(total_frames, 0, frames_left + 1))`
  (start, end)  | `lerp(start, end, linstep(total_frames + 1, 0, frames_left + 1))`

  In these expressions, `linstep()` might be replaced with `smoothstep()` or `smootherstep()`
  to ease in and out with various degrees of continuity. The `lerp()` might
  be replaced with `lerp_angle()` or `perceptual_lerp_color()` for the special
  needs of angular and color interpolation.


Time
----------------------------------------------------------

<quadplay/> always runs your `frame` event code at 60 fps. You can
hardcode this assumption into your program. For example, the built-in
simulation routines all use "frame" as the unit of time (and "pixel"
as the unit of distance). 

The _display_ may not refresh at 60 fps if
your program is consuming too much computation, because the runtime
will start dropping graphics calls to maintain the simulation rate.
It will scale all the way down to 12 fps on refresh while still
trying to execute your main loop at 60 fps so that simulation is
unaffected. 

`game_frames`
: Number of elapsed 1/60 frames since the program started. The program may
  mutate this global variable.

`mode_frames`
: Number of elapsed 1/60 frames since the current mode was most recently entered.
  The program may mutate this global variable.

`now()`
: Returns a time in seconds that is accurate to at least one millisecond.
  The origin for the time is arbitrary but constant per program run.
  Do not use this time for simulation because it will have inconsistent
  jumps between frames dues to frame rate scaling. It is good for performance
  monitoring within a frame and for synchronizing to a real-time clock,
  for example for music or MIDI. The value returned may change within a frame. See also `utc_now()`.

`local_time(time_spec default nil)`
: Returns an object with the following properties set in the local
  time zone:

  - `year`, e.g., 2019
  - `month` 0-11
  - `day` 1-31
  - `hours` 0-23
  - `minute` 0-59
  - `second` 0-59
  - `millisecond` 0-999
  - `weekday` 0-6, where 0 = Sunday
  - `day_second` seconds since midnight, including a fractional part
  - `timezone` minutes from UTC. See [time zones](https://www.timeanddate.com/time/zones/).
  - `absolute_milliseconds` milliseconds since 1970-01-01 in UTC

  If `time_spec` is nil (the default) the current time is used.

  If `time_spec` is a string of the form `"hh:mm:ss DD MM YYYY TZ"`
  such as `"16:30:10 21 Nov 2022 PST"`, then it is parsed 
  and used as the time. All elements are optional and default to 
  the lowest possible value, except for the time zone which defaults 
  to the current time zone.

  If `time_spec` is a structure with the above fields, then it is converted
  using the `timezone` field to a local time structure.

  See `format_number()` for the various clock formatting options for numbers in seconds,
  and `now()` for a high-precision timer. See also `utc_time()`.

  The value of `local_time` is constant throughout a frame.

`utc_time()`
: Returns an object with the same fields as `local_time()` for the current time.
  There is no way to produce this object for a different time. The value of
  `utc_time()` is constant throughout a frame.

`utc_now()`
: Seconds since midnight Jan 1, 1970 in UTC, with no guaranteed accuracy 
  below the second. The value returned by `utc_time()` may change
  within a frame. See also `now()`.
 
 
AI
----------------------------------------------------------
### AI Gamepads

Virtual gamepads follow the same API as `gamepad_array[]`
elements. These allow implementing AI players by synthetic control
inputs instead of direct logic within simulation.

`make_bot_gamepad(color default gray(80%), name default "bot", index default nil)`
: Just as with the `gamepad_array[]` gamepads, the gamepad's
  directional properties will be read with respect to the current
  transform at the time they are read.

  Has the same properties as a `gamepad_array[]` element, including the derived
  properties `xy`, `angle`, `pressed_a`, etc.


`update_bot_gamepad(gamepad, controls, absolute default false)`
: Updates the state of the bot gamepad by sending it virtual data
  for polling.

  The `controls` object has the following properties representing the
  current state of the gamepad controls. Unspecified elements are
  assumed to have the value `0`. If `absolute` is true, the current
  transform is ignored when interpreting directional input.
  `x`, `y`, `a`, `b`, `c`, `d`, `e`, `f`, `q`. The `p` button is reserved
  for pause and cannot be pressed on an AI gamepad.
  
  In absolute (default <quadplay/>) coordinates, `y` = +1 is pulling
  the gamepad D-pad down and `y` = -1 is pushing it up. In relative
  coordinates it will follow the current transform at the time this
  function is called.
  

### Board Games

`find_move(player_index, game_state, generate_moves, apply_move, static_evaluate, max_depth default 2, unpredictability default 0, debug_move_to_string default nil)`
: Chooses the best move for the current player in a two player, zero
  sum game with perfect information and discrete moves by game tree search
  using the negamax algorithm. This can handle most two player board games.

  - `player_index`: 0 for the maximizing player, 1 for the minimizing player. This must be the current player in `game_state`
  - `game_state`: state of the game, an arbitrary data structure (which probably also keeps track of the `player_index` itself…)
  - `generate_moves(game_state)`: function that returns an array of moves, an arbitrary game-specific data structure
  - `apply_move(game_state, move)`: function that returns a new game state after a move has been performed. This must clone the
    state and not mutate it
  - `static_evaluate(game_state)`: function that evaluates a game position as a signed number.
     Higher is better for `player_index` 0, lower is better for `player_index` 1. 
     `inf` is a win for player 0, `-inf` is a win for player 1. Returns `"draw"` for a draw (tie).
  - `max_depth`: integer number of turns to look ahead. Minimum 1. Time cost is exponential in max_depth
  - `unpredictability`: magnitude of random number to add to the `static_evaluate()` values to create variation in play.
            Use a small value, like `ε` to add variation when choosing between equally good moves and a large
            number (like the value of a minor piece) to add surprising or suboptimal play.
  - `debug_move_to_string(move)`: function that maps a move to a string. If specified, this is used for printing the tree as it is searched to the output window.


`make_move_finder(player_index, game_state, generate_moves, do_move, static_evaluate, max_depth default 2, unpredictability default 0, debug_move_to_string default nil)`
: This allows the search to continue over multiple frames when it goes deep into a game tree. The
  arguments are the same as for `find_move()`. Returns a function
  `finder(max_time default 0.25 * 1/60)`. That function runs for about
  `max_time` in seconds and then returns an object `{progress: percentage, move: move}`. If it has found a good move for this
  player, then `progress = 100%` and `move` is the best move known to
  the AI. Otherwise, `progress` is less than 100% and `move` is `nil`.


### Path Finding

`find_path(start_node, goal_node, estimate_path_cost, edge_cost, get_neighbors, node_to_ID, graph_obj default ∅)`
: `find_path()` is a general-purpose path-finding routine for any kind of
  world representation. It uses the "A*" (A-star) algorithm. _See also `map_find_path()` for a simpler, map-specific version._

  The return value is an array of nodes to traverse to follow the shortest path discovered.
  The first node in the returned path will
  be the `start_node` and the last node will be the `goal_node`.
  `find_path()` will return `∅` if no path exists between the `start_node` and `goal_node`.

To recover the cost of the path, use the idiom:

````````````` PyxlScript
let cost = 0
for i < size(path) - 1: cost += edge_cost(path[i], path[i + 1])
`````````````

The arguments are below. See the example of using these on a map for a
better understanding of how they are typically computed.

`start_node`
: The starting location, in your chosen node representation.

`goal_node`
: The ending location, in your chosen node representation.

`estimate_path_cost(node_from, node_to, graph_obj default nil)`
: Heuristic function used to significantly accelerate approximate path finding.
  Returns a numerical estimate of the cost for the path between
  `node_from` and `node_to`. *For example, a good 
  common implementation is to return the straight line distance between the nodes*.
  
  The more accurate this estimate is, the faster and better that the algorithm
  will run. If this function returns 0 for all inputs, then the algorithm
  will run in the worst case quadratic time but is guaranteed to find
  the exact shortest path instead of an approximation.

  Note that the function must work for _any_ two nodes in the graph.
  `node_from` and `node_to` are not generally not the `start_node` and `end_node`,
  and are not generally neighbors or even connected by a viable path to each other.

`edge_cost(node_from, node_to, graph_obj default nil)`
: The actual cost of going from `node_from` to `node_to`, which are guaranteed to be
  neighbors that were previously discovered by `get_neighbors()`.
  Together, `edge_cost()` and `get_neighbors()` define the graph structure.

`get_neighbors(node, graph_obj default nil)`
: Returns an array of all neighbor nodes reachable from node. It is not required that
  neighbors are bidirectional. For example, a ledge may create an edge traversable
  in only one direction

`node_to_ID(node, graph_obj)`
: Returns a compact integer or string representation of the node, which is
  required internally by the algorithm for maintaining a table of nodes.

`graph_obj`
: Any object that represents your world graph. This can be `nil` if the other
  function arguments use global state.

### Map Example

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
const sprite = map.spritesheet_table["mapTiles"]
const wall = sprite[0][0]
const swamp = sprite[0][1]
const dir = [xy(-1, 0), xy(0, -1), xy(0, 1), xy(1, 0)]

// Assume all edges cost 1
def estimate_path_cost(A, B, map): return |B.x - A.x| + |B.y - A.y|

// Moving through swamps is slow
def edge_cost(A, B, map): return 1 + (get_map_sprite(map, A) == swamp)

// Block traversal at map edges and walls
def get_neighbors(A, map):
   const neighbors = []
   for d in dir:
      const B = A + d; const s = get_map_sprite(map, B)
      if s and s != wall: push(neighbors, B)
   return neighbors

// Map to integer indices
def node_to_ID(A, map): return A.x + map.width * A.y

// In map coordinates
let start_node = xy(1, 1)
let goal_node = xy(20, 20)
let path = find_path(start_node, goal_node, estimate_path_cost, edge_cost, get_neighbors, node_to_ID, map)

// Print the path
for P in path: debug_print(P)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Debugging
------------------------------------------------------------------------------------

The following are provided for debugging and development support
only. They may do nothing on some platforms and may crash on others.
These APIs are subject to change. None of these are regular functions
or variables. They are special syntax that cannot be bound as values.

For enabling or disabling large sets of debugging statements at once in a
program, they can be masked using standard boolean operators. For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PyxlScript
// Error on unimplemented routine
todo("Implement explosions")

// To customize the startup mode per user when working on a team,
// add a conditional set_mode() to your program's general startup mode (for example, Title)
if IDE_USER == "forrester": set_mode(Inventory) because "Forrester is debugging inventory"

// Make a global flag that jumps to gameplay in a debug build by putting
// this in your Title or other startup mode
if DEBUG: set_mode(Play) because "in DEBUG build"

// Only error if your own debug_graphics constant is true.
// You can change a constant from the IDE while the program
// is running!
debug_graphics and todo("Implement explosions")

// Error if running in the IDE using a local quadplay server
// and the current developer's local machine username is "stephan"
(IDE_USER == "stephan") and todo("Implement explosions")

// Only print if debug_graphics is true.
debug_graphics and debug_print("Running iteration" + i)

// Print when your own LOG_LEVEL constant is greater than 5
(LOG_LEVEL > 5) and debug_print("Simulating")

// Print when the 2nd bit of your own LOG_MASK constant 
// is set
(LOG_MASK bitand 0b010) and debug_print(format_number(x, "%"))
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


`assert(x, msg default "Assertion Failed")`
: If `x` is true, does nothing. If `x` is false, creates the
  error `msg`. Assertions can be completely disabled
  from the Tools menu to make them have zero cost. In the current
  implementation, the `msg` is always evaluated when assertions
  are enabled even if the assertion test passes.

`debug_pause()`
: Pause program execution.

`debug_print(x, ...)`
: If `x` is a string, directly prints it to the Output window, otherwise
  prints `unparse(x, 3)` to the Output window. When multiple arguments
  are provided they are processed individually with spaces between them.
  Debug print statements can be completely disabled from the Output
  window, which causes them to consume no processing time.

  In the output pane, click on the output to go to the line that
  produced it in the code editor.
  
`debug_watch(expr)`
: Make the expression appear along with its value at the time that
  `debug_watch` executs in the Watch pane of the debugger. If there are
  multiple expressions that are syntactically identical, they will be
  collapsed and only the last to execute each frame will be
  shown. This is *not* a function. It is a special syntax. You may not
  pass the `debug_watch` command as if it were a function.
  
  In the watch pane, click on the expression to go to the line that
  contains it in the code editor.

`draw_bounds(e, color default gray(60%), recurse default true)`
: Render a debugging view of the bounds of an entity or other object `e`
  with `pos` and optional `angle`, `size`, `scale`, and `shape`
  properties. If `recurse` is true, descend into
  any `e.child_array` property.

`draw_physics(physics)`
: Render a debugging view of the physics system

`IDE_USER`
: A string constant bound to the `USER` environment variable for the operating
  system. This is "anonymous" when not running the IDE or a <quadplay/> local
  server.

`todo(message default "")`
: Adds to the todo list in the IDE. If todo as error is enabled, 
  at runtime also reports the error `"Unimplemented: " + message`. 
  The `message` must be a compile-time constant string, similar 
  to `because`.


Persistence
-----------------------------------------------------------

The local persistence API stores values in the browser's 
[`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage).

This state is tied to a specific web browser and the URL from which
<quadplay/> is hosted, as well as the URL of the game. Some browsers may
automatically synchronize local storage across computers, however.
Beware that some browsers conserve memory and wipe local storage if it is not used after
a certain period of time, usually on the order of weeks to months.

Using any of these APIs triggers <quadplay/> to add Import and Export Save Game
items on the Console menu, so that players can move their saved game
state between machines.

The storage API performs string manipulation and can be slow relative
to other commands. Avoid using it every frame.

This API is useful for saved game state, GUI defaults, high scores,
and persistent worlds.

Beware that the `localStorage` state can be accessed by anyone from the browser's
development tools. A sufficiently motivated player can therefore hack the state 
and you should obfuscate data if you want to inhibit this.
The save game files are always lightly obfuscated by quadplay, although
it is easy for a programmer to reverse-engineer the format if they are
determined to hack save games.


`load_local(key)`
: The key is loaded and deserialized with `parse()` to return an
  object that was previously saved with `save_local()`. If the `key`
  is not found, then `∅` is returned. The idiom `load_local(key)
  default def_val` is convenient for specifying a default when
  no previous value was stored.
  
`load_local()`
: Return an object mapping all stored keys to their values. The empty
  object `{}` is returned if there are no keys.

`save_local(key, value)`
: The value will be serialized to a string with `unparse(value, 0)` and then
  stored associated with `key` and the URL of the game. Save a value
  of `∅` to delete the key. There is a maximum size of 32,768
  characters for the unparsed value for each key and a maximum size of
  64 keys per application. There is no way for two different games to
  read each other's values.

`save_local(object)`
: Replace all previous keys with these key value pairs. The same size
  restrictions apply as for the individual key-value pair.

`save_local()`
: Delete all previous key-value pairs


Network
------------------------------------------------------------------------------------

All <quadplay/> games with 2-4 player *local* multiplayer ("couch multiplayer") support
automatically recieve shared-screen *network* multiplayer support.
Program your game as if it was solely local mulitplayer, using `gamepad_array` and such.
Players can begin hosting or join another game as a guest using the system pause menu or the game
launcher. There's no work for you as the programmer and no code to write.

The default network multiplayer support requires players to use some outside
mechanism to discover each other. <quadplay/> provides Host Codes (4-word sequences),
URLs, and QR codes that players can communicate via text, email, discord, phone,
verbally, etc. to connect. This helps ensure players do not encounter strangers
online.

You can customize network multiplayer in several ways beyond this automatic support:

- The Host-Guest section describes how to extend 2-4 player shared-screen games
  with _custom_ in-game UI for launching the online experience in addition to the
  built-in pause menu support.
- Setting the `online_menu` property of the game.json file to `false` disables
  the built-in Online option of the System Menu. It is automatically disabled
  if the maximum number of players is set to 1 in the game.json file as well
- The `private_screens` argument to `set_screen_size()` can enable per-player
  private screens instead a single shared screen in multiplayer.
- The Conduit section describes a more complicated alternative API that can
  support unbounded numbers of players and slightly lower latency. It also 
  provides online discovery for connecting players without requiring them
  to exchange data through a side channel.

Because all of these APIs are is implemented using on WebRTC, they will work even between
computers that are not publicly accessible on the internet due to NATs or firewalls.

### Host-Guest

You can make your own 2-4 player games easier to join, or support private screens
using this Host Code network API. These are still programmed with an entirely
local model. The Host-Guest network API is for improving the user experience when
joining games and supporting optional private per-player screens, not for
state synchronization or messages. Those are still handled automatically for you.

`HOST_CODE`
: A string of the six words that are the online ID this host uses. Can
  change at runtime if the player intentionally changes it.

`start_hosting(show_buttons default true)`
: Start hosting as soon as possible, if the `--offline` flag was not set.
  Check `HOST_CODE` to display to the players so they know where to tell
  guests where to connect to. If already hosting, just changes the state
  of the button display if the argument has changed.
  
  Check `gamepad_array[0].status == "host"` to see when hosting has started.
  
  If `show_buttons` is true, then the Copy Host Code and Copy Host URL
  buttons are displayed on the bottom of the screen _in this mode_
  until the game stops hosting or `start_hosting(false)` is called.

`stop_hosting()`
: Stop hosting as soon as possible.
  Check `gamepad_array[0].status != "host"` to see when hosting has ended.

`pause_menu("Online")`
: Show the system's pause menu option for online play, as if the player
  had pressed P and then selected Online.

`pause_menu("Online -> Guest")`
:  Show the menu for connecting to hosts and changing your own name
   if the `--offline` flag was not set, as if the player had pressed P
   and then selected Online and then selected Visit a New Host.
   If the player connects to a host, then the local game remains paused. 
   See also `start_hosting()`
  
`disconnect_guest(gamepad_index)`
: Immediately drop the player with `1 <= gamepad_index <= 3` if they are
  connected as a guest.

See also `gamepad.online_name` and `gamepad.status` for information about
guests. 

#### Limitations

Host-Guest online play can only be entered from 384x224 and 192x112
resolution because the on-screen UI is designed for those.
It can be _used_ with games in any resolution once in game.

Disconnecting and reconnecting could change the order of
players.

Only one player is supported per computer. 

Games with
complicated animated backgrounds and background music are more likely
to be laggy (pausing the game can reset the lag).

As host, you cannot currently kick or ban players, or change the order of players. As a
guest, you cannot currently leave a game without restarting <quadplay/>.


### Conduit

!!! Warning Experimental API
    The Conduit API is currently experimental and likely to change throughout fall 2025

The Conduit network API is an alternative to built-in Host-Guest shared-screen
multiplayer. Both APIs can be used together, although the Conduit API is intended to
completely replace Host-Guest for games that use it.

The default behavior of `make_conduit()` connects you to a *global broadcast group* that
is like a world-wide radio station. Here's what happens:

1. **Automatic Join**: When you call `make_conduit()`, you're instantly connected to every other instance of your game running anywhere in the world
2. **No Setup Required**: No dedicated servers, no server configuration, no IP addresses, no port forwarding needed
3. **Broadcast Communication**: You can send messages that reach all other players, and receive messages from all other players
4. **Game-Specific**: Only players running the same game (from the same URL) can join this group

This works because system uses a virtual routing layer that handles all the complex networking (NAT traversal, peer discovery, etc.) behind the scenes and operates 
in a purely peer-to-peer, client side manner from statically hosted content. You can also
customize the behavior to produce alternative network structures, more restricted groups,
or have peers act in differentiated roles (e.g., as servers).

The simplest possible example of using the global group is a chatroom:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Pyxlscript
let group_conduit

def handle_message(message, node_netid):
  debug_print(node_netid + " says: " + message)

enter
--------------------------------------------------
// Instantly connect to a single massive global group of all
// instances of this game everywhere in the world
group_conduit = make_conduit()

frame
--------------------------------------------------
// Receive
conduit_iterate(group_conduit, handle_message)

// Send
if gamepad_array[0].aa:
  conduit_send(group_conduit, "Hello world!")

exit
--------------------------------------------------
// Leave the group on exit
conduit_close(group_conduit)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


A more game-like framework extends that chatroom to track per-player
state about other nodes, and handle the local player's state directly:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Pyxlscript
let group_conduit
let my_netid
let last_jump
let player_table = {}

def handle_message(message, node_netid, conduit):
  if message.type == "action":
    player_table[node_netid] = message.action


def handle_leave(node_netid, conduit):
    remove_key(player_table, node_netid)
  

// Send to others and process myself immediately for lower latency
def send(message):
    conduit_send(group_conduit, message)
    handle_message(message, my_netid)


def jump():
    send({type: "action", action: "jump"})

    
def land():
  send({type: "action", action: "land"})


enter
--------------------------------------------------
my_netid = get_node_netid()
player_table[my_netid] = "idle"

// Connect to a single massive global group of all
// instances of this game everywhere
group_conduit = make_conduit()


frame
--------------------------------------------------
// Example of receiving incoming messages. We receive never receive
// messages from ourselves
conduit_iterate(group_conduit, handle_message, nil, handle_leave)

if gamepad_array[0].aa and player_table[my_netid] == "idle":
  jump()
  delay(5, land)


exit
--------------------------------------------------
// Leave the group on exit
conduit_close(group_conduit)
group_conduit = nil
remove_all(player_table)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


The key concepts in this API are:

*Conduit*
: A connection on which discrete messages can be reliably sent and received.
  The latency is reasonably low, but remaines limited by the 60 Hz frame rates of
  the sender and receiver serving their queues. So, expect a minimum of
  120 ms for a round trip communication and much higher if the nodes are
  behind NATs, many physical network hops apart, or the messages are very large.

*Message*
: An arbitrary game-specific data structure. It can have cycles and other
  complex internal pointer relationships that will be preserved similar to 
  structured cloning. However, certain values can't be included in a message
  because they can't be serialized or are machine specific (e.g., functions, 
  sprites and other assets).

*Node*
: A single instance of your game, running on one tab of a web browser. There 
  can be multiple instances on the same computer, and each instance might perform
  multiple roles simultaneously, or change roles over time. A node can be programmed
  to act as a discovery server, a game server, a game client, or a game peer.

*Group*
: A network clique of nodes that can broadcast to each other. Think of this 
  like a global radio channel where everyone can send and receive. When connected to
  a group, each node holds a single group conduit on which it sends and receives messages. It 
  can only broadcast to everyone on in the group and not send individual messages. 
  However, when receiving messages it does know
  the ID of the node that sent that message to the group.

*netid*
: A virtual address by which a node or group is identified. These are strings
  that can be chosen as transient per session or hardcoded for specific purposes.
  They must be globally unique. For a node, this is somewhat analogous to an IP address, but 
  because it operates on a virtual network avoids many of the limitations of IP
  addresses. For a group, this is somewhat analogous to a UDP broadcast mask,
  but it is reliable and operates on the global internet instead of the local network and has
  no routing limitations.


The Conduit API supports creating direct peer-to-peer data connections between
instances of your game running on multiple computers or in multiple browser windows
on the same computer. It gives nearly full control of the network code to your game,
at the expense of requiring you to perform all state synchronization. 

Conduits can be used for building any network topology, including peer-to-peer,
clients that host a temporary server on the same node, and client-dedicated server star networks.
Conduit operates on a virtual routing system that does not use IP addresses, so will
work with nodes behind NATs and does not require static IP addresses. 

The ways that you can connect to other nodes with Conduit are:

- In Groups
  - Connect to a single global peer group. This forms a clique where every node communicates
    with ever other node. This is the default operation of `make_conduit()` and is good
    for an MMO-like experience.
  - Connect to a peer group with a specific static or dynamic ID, where that ID has been discovered
    via a side channel. You can build your own "server browser" by using the global group 
    as the side channel, or ask players to use another side channel such as Discord or SMS.
- 1:1
  - Connect to a node with a specific dynamic ID, where that ID has been discovered via
    a side channel. This is good for 1:1 games, or for star networks with transient
    servers hosted by players.
  - Connect to a node with a specific static ID, where that ID is either hardcoded into
    your game or discovered via a side channel. This is good for dedicated servers, such
    as where you use a computer that you can keep online continuously to host your game.
    This can be as simple as a Rasberry Pi on a home network or as complex as an AWS virtual hosted
    process.
  - Listen for incoming connections from other nodes. This is the receiving side 
    of the two previous connection strategies.

Conduit's state synchronization and server coding are more complex than the
built in shared-screen Host-Code network multiplayer. So, the Conduit API is best for 
experienced developers polishing games rather than for new developers or rapid protyping
in game jams.

A conduit has the following properties:

`conduit.status`
: - `"pending"` - in the process of connecting the conduit. Messages sent or received will be queued while awaiting the full handshake.
  - `"online"` - the conduit is open and stable.
  - `"closed"` - the conduit has been terminated on one or both sides and cannot come `"online"` again.
  - `"offline"` - the conduit is queuing but not actively delivering
      messages because there is no internet connection on this node (or, in rare cases, the servers that initally broker the P2P connections are offline or overloaded).
      but may come `"online"` later.

`conduit.netid`
: The `netid` of the group or node being communicated with through this conduit.

*****************************************************
*                    .-> "closed" <-.
*                   |                |
*                   |                |
* "pending" ---> "online" <-----> "offline"
*     |                              ^
*     |                              |
*      '----------------------------'
*****************************************************
[`conduit.status` transitions]

The functions in the conduit API are:

`make_conduit(id default "group_netid 0000")`
: Create a connection to one or more nodes on the network. `id`
  is a string.

  If `id` begins with the string `"group_netid"`, then the conduit
  communicates many-to-many with all nodes in that group that are running the same game loaded
  from the same server, i.e., from the same URL. You do not need to put the name 
  of your game in the ID. (The restriction to the same game is to make it harder
  for someone to fork your game and then corrupt its network communications.)
  The group is created (or recreated) when the first node connects and taken down when the last node
  disconnects.
  The default value connects everyone to a single global group for your game.

  If `id` begins with the string `"node_netid"`, then the conduit communicates
  one-to-one with a single node that was calling `conduit_listen()`. You must
  have obtained that netid through some side band, or chosen to make it
  fixed if you are connecting to a server.

`get_node_netid()`
: Get the `netid` for this node, which is a globally unique string per session
  unless `set_node_netid()` has been called.

`get_conduit_online_status()`
: Get the current network status as a string: `"pending"` while establishing the initial
  network connection, `"online"` when ready to create conduits, or `"offline"` when
  there is no network connectivity. This indicates the overall ability to create new
  conduits, not the status of any individual conduit. In all states
   new conduits may be created, and messages sent on them. The underlying implementation
  queues the work until the connection is established if offline or pending. If offline
  for a significant amount of time then individual conduits may be forcibly closed. If offline
  for a short period, the conduits will queue work waiting to come back online.

`conduit_send(conduit, message)`
: Send this message, which can be any serializable message. If `conduit` is a group conduit,
  every node in the group will receive the message.

`conduit_iterate(conduit, message_handler, join_handler, leave_handler)`
: Iterate through all incoming messages. For each, invokes `message_handler(message, node_netid, conduit)`.
  Calls `join_handler(node_netid, conduit)` for each node that has newly joined the conduit
  since the last call to `conduit_iterate()`. For single conduits, this is not used.
  Calls `leave_handler(node_netid, conduit)` for each node that has closed their
  side of the conduit or left the group.

`conduit_close(conduit)`
: Close this connection immediately. This is faster and conserves resources compared to
  dropping pointers and letting the conduit time out.

`reset_conduits()`
: Close all connections and assign a new random `node_netid`.

`set_node_netid(node_netid)`
: Set the `node_netid` for this node. This is only used when creating a static server
  architecture. Calling this resets any network connections that have previously
  been established by the Conduit API. After calling this, use `conduit_listen()`
  each frame to accept incoming connections; there's no other use for a fixed
  ID than to accept connections.

`conduit_listen(new_conduit_handler)`
: When creating a game architecture that uses one-to-one connections, you must
  call this every frame to process new incoming connections that were initiated
  on the other side by `make_conduit()` with a node netid instead of a group netid.

  The function `new_conduit_handler(conduit)` will be invoked for each incoming 
  connection. You must retain these conduits to communicate on them and keep
  them open. To reject a connection, ignore it to force it to time out, or call `conduit_close()`
  to terminate it and free resources.

If using the Conduit API, you likely also want to disable the built-in Host-Code
network API by unchecking the corresponding option on your game's main
page in the IDE or changing it directly in the game.json file.


### HTTP

!!! Warning Experimental API
    The HTTP API is in beta and may change or be removed in the future.

This lets a program fetch data and access HTTP APIs from its own server, or from a
remote server that supports CORS. 

For security and safety, the HTTP API is disabled when a game is run from the
launcher or in kiosk mode. You can make the API calls in this case, but they will always fail.

`make_http(url, options default {method: "GET"}, data default nil)`
: Create a HTTP request to the given URL. The `options` object 
  has the form of a JavaScript [`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit)
  object.

`add_http_frame_hook(url, options default {method: "GET"}, data default nil, success_handler default nil, failure_handler default nil)`
: Create a HTTP request to the given URL. The `options` object 
  has the form of a JavaScript [`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit)
  object. 

  Then registers a frame hook that invokes `http_poll(http, success_handler, failure_handler)` every frame
  until the request is complete, which runs in every mode.

  Returns the hook object so that it can be cancelled.


`http_poll(http, success_handler default nil, failure_handler default nil)`
: Poll the HTTP request.
  If complete, it invokes one of the two handlers. Each has the form
  `handler(response, http, data)` where `response` has the form of a JavaScript
  [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)
  object and `data` is the corresponding value passed to `make_http()`.
  
  If the request fails because of quadplay security restrictions, 
  then the failure status code will be 418.

  Returns `nil` if the request is complete and the `http` request otherwise
  to support the idiom: `if http: http = http_poll(http, success_handler, failure_handler)`.


`http_iterate(http_array, success_handler, failure_handler)`
: Iterate through all pending HTTP requests in the array.
  For each that is complete, invokes one of the two handlers and removes the http value from the array.
  Each handler has the form
  `handler(response, http, data)` where `response` has the form of a JavaScript
  [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)
  object and `data` is the corresponding value passed to `make_http()`.
  
  If the request fails because of quadplay security restrictions, then the failure status code
  will be 418.

Raw Device Access
-----------------------------------------------------------

`device_control(command, ...)`
: Reserved function for executing device-specific features such as the
  game launcher, GPIO, and alternative input devices. `command` is a
  string telling the host which control feature to execute, and the
  remaining arguments are passed to it. 
  
  Unlike the rest of the API, all `device_control()` commands may change in future releases and 
  *may fail silently on any physical platform* or when not using the IDE.
  This function breaks the <quadplay/> abstraction so that you are not
  limited by that abstraction. By using it, you are also forgoing the guarantees
  that the game will work on all devices.

  <table class="nested">
    <tr><th> Parameters                      </th><th> Effect </th></tr>
    <tr><td> `"start_GIF_recording"`         </td><td> Begin GIF recording.</td></tr>
    <tr><td> `"stop_GIF_recording"`          </td><td> End GIF recording. When the compression completes, the GIF will appear in a new tab.</td></tr>
    <tr><td> `"start_preview_recording"`     </td><td> Begin preview video recording. There is no "stop" command because this terminates automatically after a set time.</td></tr>
    <tr><td> `"take_screenshot"`             </td><td> Take a screenshot and download it to the local disk. </td></tr>
    <tr><td> `"take_label_image"`            </td><td> Capture the center of the image and save it to disk, overwriting the label128 and label64 images (only works when running in the IDE on an editable project). </td></tr>
    <tr><td> `"set_pad_type", index, "type"` </td><td> Set `gamepad_array[index].type` and the corresponding prompts. There is no "get" version because you can read the property directly from the gamepad object.</td></tr>
    <tr><td> `"get_analog_axes",`
    `player_index default 0,`
    `stick_index default 0`                  </td><td> Return an `xy()` of the analog axis values for `gamepad_array[player_index]`, without D-pad snapping and unlocking reading of the
                                                    values beyond the first stick.
                                                    Needed for accessing Atari paddles, car pedals, steering wheels, and flight stick throttles in
                                                    a meaningful way. There is currently no way to read the D-pad directly (it will be overriden by the analog axis if moved).</td></tr>
     <tr><td> `"get_analog_triggers",` 
      `player_index default 0`              </td><td> Return an array of two values representing the state of the analog trigger buttons for `gamepad_array[player_index]`.</td></tr>
    <tr><td> `"rumble",` 
      `player_index default 0`, `duration_frames default 10`, `strength default 100%`                </td><td> Activate the haptic vibration on `gamepad_array[player_index]` for `duration_frames`. This requires a browser that supports haptics as well as a controller that supports them on that OS and browser. Windows with an Xbox controller on a Chromium browser (Edge, Chrome, Brave) is your best shot at compatibility.</td></tr>   
   <tr><td> `"get_mouse_state"`             </td><td> Return `{x:number, y:number, ` `dx:number, dy:number, ` `xy:xy(...), dxy:xy(...), ` `wheel:xy(...), ` `button_array:[...],` `cursor:string, lock:boolean}` for the current mouse position and buttons. Each element of
                                                      `button_array` is 0 or 1. There are at least two buttons, but may be more. The `dx`, `dy`, and `dxy` values may have higher precision than the absolute numbers because they
                                                      are tracked at subpixel resolution on browsers that support this. The `wheel` values follow the transform at the time of the `device_control()` call and on macOS follow the scroll direction from the OS ("natural" vs. normal).</td></tr>
    <tr><td> `"set_mouse_lock", bool`       </td><td> Enable or disable mouse lock. Mouse lock hides the OS mouse cursor and prevents the mouse from moving 
                                                      from the center of the screen, so that it returns only `dxy` values and absolute `xy` values will be fixed. 
                                                      This is useful for first-person mouselook.</td></tr>
    <tr><td> `"set_mouse_cursor", name`     </td><td> Change the OS mouse cursor to any [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor) cursor. The default is `"crosshair"`. Note that the OS 
                                                      cursor is at a different resolution than quadplay, so you may want to set to `"none"` and draw your own cursor from a sprite. The OS cursor has 1-4 frames less lag
                                                      than a game-drawn cursor, however.</td></tr>    
    <tr><td> `"set_debug_flag", flagname, bool` </td><td> Set the enabled state of an IDE debugging flag. The flagnames are 
                                                       `"entity_bounds"`, `"assert"`, `"debug_print"`, 
                                                        `"debug_watch"`, `"physics"`.</td></tr>
    <tr><td> `"get_debug_flag", flagname`    </td><td> Return the state of an IDE debugging flag.</td></tr>
    <tr><td> `"console.dir", ...`            </td><td> Execute `console.dir(...)` if running in a web browser.</td></tr>
    <tr><td> `"save", filename, value, callback` </td><td> Serializes `value` to JSON using WorkJSON extensions and writes to `filename` on disk in the same directory as the game.json file. `filename` cannot contain slashes
                                                         and must end in `.json`. 
                                                         This is intended for creating development
                                                         tools within quadplay itself, for example, level editors, NPC ghost tracks, and demo sequences. 
                                                         The JSON files can be loaded as game constants with the `raw` type. If present, `callback` is invoked with `value, filename` when the asynchronous
                                                         save is complete. This will only work with the IDE enabled and a quadplay server.</td></tr>
    <tr><td> `"load", filename, callback`</td><td>Loads `filename` and (asynchronously) runs the callback with the arguments `value, filename` when
                                                         the load is complete. This will only work with the IDE enabled and a quadplay server.</td></tr>
    <tr><td> `"enable_feature", feature`</td><td>Enables the given feature, which is nonstandard and may fail on some devices. The options are: <dl><dt>`feature = "768x448,private_views"`</dt><dd>Enables 768x448 resolution for `set_screen_size()` with `private_views=true`, which is too slow to make 60 Hz framerate on Raspberry Pi and some phones and so not enabled in the base API.</dd><dt>`feature = "custom_screen_size"`</dt><dd>Enables arbitrary values for `set_screen_size()`, which may cause problems with layout of the HTML page, the pause/system menu, or performance.</dd></dl></td></tr>
    <tr><td> `"multitouch"`</td><td>Returns an array of touch objects for every currently-active touch, which have the form `{id:string, x:number, y:number, xy:xy, screen_x:number, screen_y:number, screen_xy:xy}`. The touch with id == -1 is the mouse.</td></tr>
    <tr><td> `"get_display"`</td><td>Get an object describing the physical display device, with properties:
      <dl><dt>`fullscreen_size`<dt><dd>`xy()` of the largest in OS-defined HiDPI pixels the largest the emulator
      could be with fullscreen if not showing the mobile touch gamepad controls. 
      This is the display client rect minus the <quadplay/> toolbar height.</dd>
        <dt>`window_size`</dt><dd>`xy()` of the
      largest in OS-defined HiDPI pixels the emulator screen can be without fullscreen mode
      if not showing the mobile touch gamepad controls, as constrained by the browser
      window or an iframe if embedded. This is the window client rect minus the <quadplay/>
      toolbar height. When the app goes fullscreen, the `windowed_size` will grow to the
    `fullscreen_size`.</dd>
      <dt>`quadplay_size`</dt><dd>xy()` of the emulator's current screen in OS-defined HiDPI pixels.</dd>
      <dt>`orientation_angle_degrees`</dt><dd>
        The display's orientation relative to its preferred orientation. 
       For a phone, this is 0 when it is in 
       primary portrait mode and changes clockwise with rotation. For a regular desktop monitor with landscape 
       orientation, this is 0 always.</dd>
       <dt>`fullscreen`</dt><dd>`true` if the emulator currently in fullscreen mode.</dd>
      </dl>
    </td></tr>
  </table>

For example, combining
`device_control("enable_feature", "custom_screen_size")` with
`device_control("get_display")` and `set_screen_size()` enables making a game
that is responsive to the exact resolution of a browser window or orientation
and fullscreen status on a phone.

Intrinsics
-----------------------------------------------------------

<quadplay/> can execute about 10,000 vector operations per frame even
on embedded platforms. This is sufficient to program most mathematical
routines in a readable way and intrinsics are usually not required.

For some _very_ math intensive routines, such as those with thousands
of particles, it is necessary to run slightly faster at the expense of
code that is harder to maintain. In these cases, use the function
calls below, which produce inline assembly instructions for the
<quadplay/> platform.

These calls have no argument checking. The vector functions execute
about twice as fast as regular overloaded operator arithmetic. The scalar
versions may be substantially faster than overloaded operators.

Intrinsics are never needed on literal values. `5 + 6` compiles to the
same code as `ADD(5, 6)`, for example. Intrinsics are not provided for
exponents, square root, bit shifts, trigonometric, modulo (remainder), 
and other operations that naturally compile with maximum efficiency.

`ADD(s1, s2)`
: Returns the scalar sum.

`DIV(s1, s2)`
: Returns the scalar quotient.

`MAD(s1, s2, s3)`
: Returns `s1 * s2 + s3`.

`MUL(s1, s2)`
: Returns the scalar product.

`SUB(s1, s2)`
: Returns the scalar difference.

`ABS(s1)`
: Returns the absolute value of a scalar.

`LERP(s1, s2, s3)`
: Returns `lerp(s1, s2, s3)`.

`MAX(s1, s2)`
: Returns the larger scalar.

`MEAN(s1, s2)`
: Returns the average scalar.

`MEAN3(s1, s2, s3)`
: Returns the average scalar.

`MEAN4(s1, s2, s3, s4)`
: Returns the average scalar.

`MIN(s1, s2)`
: Returns the smaller scalar.

`FLOOR(s1)`
: Returns the floor of the scalar.

`CEIL(s1)`
: Returns the ceil of the scalar.

`ROUND(s1)`
: Returns the round of the scalar.

`SIGN(s1)`
: Returns +1, -1, or 0 as the sign of the scalar.

`CLAMP(s, slo, shi)`
: Clamps `s` to [`slo`, `shi`] where all are scalar and returns the result.

`SUM(array)`
: Returns the sum of the numbers in the array. The result is zero if
  the array has zero length.

`PROD(array)`
: Returns the product of the numbers in the array. The result is one
  if the array has zero length.

`RGB_ADD(srcrgb, s, dstrgb)`
: Add `s` to each element of `srcrgb` and return the result in `dstrgb`.

`RGB_ADD_RGB(srcrgb, srcrgb, dstrgb)`
: Element addition.

`RGB_SUB_RGB(srcrgb1, srcrgb2, dstrgb)`
: Element subtraction.

`RGB_MUL_RGB(srcrgb1, srcrgb2, dstrgb)`
: Element multiplication.

`RGB_DIV_RGB(srcrgb1, srcrgb2, dstrgb)`
: Element division.

`RGB_MUL(srcrgb, srcs, dstrgb)`
: Vector-scalar product.

`RGB_DIV(srcrgb, srcs, dstrgb)`
: Vector-scalar quotient.

`RGB_DOT_RGB(srcrgb1, srcrgb2)`
: Returns the scalar result.

`RGB_LERP(srcrgb1, srcrgb2, s1, dstrgb)`
: Interpolates between the two source values and returns the result in
  `dstrgb`.  The destination may be the same as one of the sources.
  
`RGB_DISTANCE(srcrgb1, srcrgb2)`
: Color vector distance `magnitude(srcrgb1 - srcrgb2)`

`RGBA_ADD_RGBA(srcrgba1, srcrgba2, dstrgba)`
: Element addition.

`RGBA_SUB_RGBA(srcrgba1, srcrgba2, dstrgba)`
: Element subtraction.

`RGBA_MUL_RGBA(srcrgba1, srcrgba2, dstrgba)`
: Element multiplication.

`RGBA_DIV_RGBA(srcrgba1, srcrgba2, dstrgba)`
: Element division.

`RGBA_MUL(srcrgba, srcs, dstrgba)`
: Vector-scalar product.

`RGBA_DIV(srcrgba, srcs, dstrgba)`
: Vector-scalar quotient.

`RGBA_DOT_RGBA(srcrgba1, srcrgba2)`
: Returns the scalar result.

`RGBA_LERP(srcrgba1, srcrgba2, s1, dstrgba)`
: Interpolates between the two source values and returns the result in `dstrgba`.
  The destination may be the same as one of the sources.

`XY_ADD_XY(srcxy1, srcxy2, dstxy)`
: Element addition.

`XY_SUB_XY(srcxy1, srcxy2, dstxy)`
: Element subtraction.

`XY_MUL_XY(srcxy1, srcxy2, dstxy)`
: Element multiplication.

`XY_MAD_XY_XY(srcxy1, srcxy2, srcxy3, dstxy)`
: `dstxy = srcxy1 * srcxy2 + srcxy3`

`XY_MAD_S_XY(srcxy1, srcs2, srcxy3, dstxy)`
: `dstxy = srcxy1 * srcs2 + srcxy3`

`XY_DIV_XY(srcxy1, srcxy2, dstxy)`
: Element division.

`XY_MUL(srcxy1, srcs2, dstxy)`
: Vector-scalar product.

`XY_DIV(srcxy1, srcs2, dstxy)`
: Vector-scalar quotient.

`XY_DIRECTION(srcxy, dstxy)`
: Normalize vector (or zero vector).

`XY_MAGNITUDE(srcxy)`
: `magnitude(srcxy)`

`XY_DISTANCE(srcxy1, srcxy2)`
: `magnitude(srcxy1 - srcxy2)`

`XY_LERP(srcxy1, srcxy2, s1, dstxy)`
: Interpolates between the two source values and returns the result in
  `dstx`.  The destination may be the same as one of the sources.

`XY_DOT_XY(srcxy1, srcxy2)`
: Returns the scalar result.

`XY_CRS_XY(srcx1, srcx2)`
: 2D cross product (z component of treating as a 3D cross product). Returns the scalar result.

`XZ_ADD_XZ(srcxz1, srcxz2, dstxz)`
: Element addition.

`XZ_SUB_XZ(srcxy1, srcxz2, dstxz)`
: Element subtraction.

`XZ_MUL_XZ(srcxz1, srcxz2, dstxz)`
: Element multiplication.

`XZ_DIV_XZ(srcxz1, srcxy2, dstxz)`
: Element division.

`XZ_MUL(srcxz1, srcs2, dstxz)`
: Vector-scalar product.

`XZ_DIV(srcxz1, srcs2, dstxz)`
: Vector-scalar quotient.

`XZ_DIRECTION(srcxz, dstxz)`
: Normalize vector (or zero vector).

`XZ_MAGNITUDE(srcxz)`
: `magnitude(srcxz)`

`XZ_DISTANCE(srcxz1, srcxz2)`
: `magnitude(srcxz1 - srcxz2))`

`XZ_LERP(srcxz1, srcxz2, s1, dstxz)`
: Interpolates between the two source values and returns the result in
  `dstxz`.  The destination may be the same as one of the sources.
  
`XZ_DOT_XZ(srcxz1, srcxz2)`
: Returns the scalar result.

`XYZ_ADD_XYZ(srcxyz1, srcxyz2, dstxyz)`
: Element addition.

`XYZ_SUB_XYZ(srcxyz1, srcxyz2, dstxyz)`
: Element subtraction.

`XYZ_MAD_S_XYZ(srcxyz1, s2, srcxyz3, dstxyz)`
: Fused multiply-add with a scalar.

`XYZ_MUL_XYZ(srcxyz1, srcxyz2, dstxyz)`
: Element multiplication.

`XYZ_DIV_XYZ(srcxyz1, srcxyz2, dstxyz)`
: Element division.

`XYZ_MUL(srcxyz1, srcs2, dstxyz)`
: Vector-scalar product.

`XYZ_DIV(srcxyz1, srcs2, dstxyz)`
: Vector-scalar quotient.

`XYZ_DIRECTION(srcxyz, dstxyz)`
: Normalize vector (or zero vector).

`XYZ_MAGNITUDE(srcxyz)`
: `magnitude(srcxyz)`

`XYZ_DISTANCE(srcxyz1, srcxyz2)`
: `magnitude(srcxyz1 - srcxyz2)`

`XYZ_LERP(srcxyz1, srcxyz2, s1, dstxyz)`
: Interpolates between the two source values and returns the result in
  `dstxyz`. The destination may be the same as one of the sources.

`XYZ_DOT_XYZ(srcxyz1, srcxyz2)`
: Returns the scalar result.

`XYZ_CRS_XYZ(srcxyz1, srcxyz2, dstxyz)`
: Cross product. `dstxyz` can be the same object as one of the input arguments.

`MAT2x2_MATMUL_XY(src2x2, srcxy, dstxy)`
: Multiply matrix `src2x2` represented as `[[m11, m12], [m21, m22]]` by 
  vector `(srcxy.x, srcxy.y)` and put the result in `dstxy`,
  which can be the same object as `srcxy`.

`MAT2x2_MATMUL_XZ(src2x2, srcxz, dstxz)`
: Multiply matrix `src2x2` represented as `[[m11, m12], [m21, m22]]` by 
  vector `(srcxy.x, srcxy.z)` and put the result in `dstxz`,
  which can be the same object as `srcxz`.

`MAT3x3_MATMUL_XYZ(src3x3, srcxyz, dstxyz)`
: Multiply matrix `src3x3` represented as an array of length three row arrays, each of length
  three by vector `(srcxyz.x, srcxyz.y, srcxyz.z)` and put the result in `dstxyz`,
  which can be the same object as `srcxyz`.
  
`MAT3x3_ORTHONORMALIZE(m3x3)`
: Snap to the nearest 3x3 rotation matrix in place, where all rows and
  columns have unit length and are orthogonal to each other.

`MAT3x4_MATMUL_XYZ(src3x4, srcxyz, dstxyz)`
: Multiply matrix `src3x4` represented as an array of length three row arrays of length
  four by vector `(srcxyz.x, srcxyz.y, srcxyz.z, 1)` and put the result in `dstxyz`,
  which can be the same object as `srcxyz`. You can use `MAT3x3_MATMUL_XYZ()` on the
  same `src3x4` to effectively multiply by `(srcxyz.x, srcxyz.y, srcxyz.z, 1)`.

`MAT3x4_MATMUL_XYZW(src3x4, srcxyzw, dstxyzw)`
: Multiply matrix `src3x4` represented as an array of length three row arrays of length
  four by vector `(srcxyzw.x, srcxyzw.y, srcxyzw.z, srcxyzw.w)` and put the result in `dstxyzw`,
  which can be the same object as `srcxyzw`. The `dstxyzw.w = srcxyzw.w`.


<script>markdeepOptions = {tocStyle:'long', definitionStyle:'long', inlineCodeLang: 'PyxlScript'};</script>
<link rel="stylesheet" href="slate.css">
<link rel="stylesheet" href="manual.css">
<!-- Markdeep: --><script src="markdeep.min.js"></script>
