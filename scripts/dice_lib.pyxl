/*
@url quad://scripts/dice_lib.pyxl
@license © 2025 Sʜᴍᴜᴇʟ. Open source under the [MIT license](https://opensource.org/licenses/MIT)
@summary 3D rendered polyhedral dice.

@requires quad://scripts/mat3x3_lib.pyxl


## Usage

`````````````````
// Prepare:
dice = make_dice(…)
die0 = dice_add_die(dice, …)
die1 = dice_add_die(dice, …)
…


// Set the desired result. Do this
// before every roll if you don't want
// random values generated by dice_prepare_roll()
die0.result_index = random_integer(…)
…
dice_set_initial_positions(dice)
dice_prepare_roll(dice, true)


///////////////////////////////////
// Animate in the main loop
dice_update(dice)


// Frames left on the current roll
const t = dice_roll_time(dice)

// Force a specific result on a static die
if joy.pressed_a:
    die_set_result_index(die, n)
`````````````````
*/

let _dice_geometry_cache = {}

/*
 Define a set of dice and the tray within which they are rolled.
 Use `dice_add_die()` and `dice_transfer()` to create/transfer individual dice.
 Use `dice_add_obstruction()` to create objects for them to hit and irregular
 dice trays.
 
 - `pos`: center of the dice rolling area in the coordinate system where dice_update() will be called
 - `size`: size of the dice rolling area in the coordinate system where dice_update() will be called
 - `shadow_color`: `rgba()` color of the drop shadow 
 */
def make_dice(
    pos default ½ SCREEN_SIZE,
    size default SCREEN_SIZE,
    shadow_color default #0005,
    die_sound default ∅,
    table_sound default ∅,
    wall_sound default ∅):
        
    const dice = {
        pos: pos,
        size: size,
        physics: make_physics({gravity: xy(0, 0)}),
        shadow_color: rgba(shadow_color),
        wall_sound: wall_sound,
        table_sound: table_sound,
        die_sound: die_sound,
        die_array: [],
        obstruction_array: []}
    
    physics_add_contact_callback(dice.physics, _dice_collision_callback, 0.5)
    
    const WALL_THICKNESS = 10
    
    // Add walls
    const WALL_TEMPLATE = {    
        shape: "rect", 
        restitution: 90%,
        friction: 0,
        density: ∞}
        
    physics_add_entity(dice.physics, make_entity({
        …WALL_TEMPLATE,
        name: "right_wall",
        size: xy(WALL_THICKNESS, size.y), 
        pos: pos + xy(½ size.x + ½ WALL_THICKNESS, 0)}))
        
    physics_add_entity(dice.physics, make_entity({
        …WALL_TEMPLATE,
        name: "left_wall",
        size: xy(WALL_THICKNESS, size.y), 
        pos: pos + xy(-½ size.x - ½ WALL_THICKNESS, 0)}))

    physics_add_entity(dice.physics, make_entity({
        …WALL_TEMPLATE,
        name: "bottom_wall",
        size: xy(size.x, WALL_THICKNESS), 
        pos: pos + xy(0, -½ size.y - ½ WALL_THICKNESS)}))
        
    physics_add_entity(dice.physics, make_entity({
        …WALL_TEMPLATE,
        name: "top_wall",
        size: xy(size.x, WALL_THICKNESS), 
        pos: pos + xy(0, ½ size.y + ½ WALL_THICKNESS)}))

    return dice
    


/* Helper equivalent to `die and die.value_array[die.result_index]`.
   Returns nil if `die` is ∅. */
def die_value(die):
    return die and die.value_array[die.result_index]



/* Adds an obstruction to the dice tray to allow 
   non-rectangular trays and collision objects within
   the tray. The `tracked_entity` must have properties:
   
   - `shape`: `"rect"` or `"disk"`
   - `pos`: Position in the coordinate system where `dice_update()` will be called
   - `size`: `xy()`
   
   The obstruction object returned will track the `tracked_entity`
   and move to its `pos` when `dice_prepare_roll()` is called.
   Note that the `tracked_entity` is in the same coordinate system
   that `dice_update()` will be called from. If this is undesirable,
   make a copy of your entity's properties pre-transformed to the 
   dice coordinate system.
   
   The dice system uses
   its own private physics engine that runs both forwards and
   backwards in time, so tracking instead of directly
   adding the entity allows that entity to have its own physics
   simulation.
   
   The obstruction is not visible.   
 */
def dice_add_obstruction(dice, tracked_entity):
    const obstruction = make_entity({
        name: "dice_tracker_for_" + tracked_entity.name,
        pos: xy(tracked_entity.pos default xy(dice.pos)),
        size: xy(tracked_entity.size default xy(32, 32)),
        shape: tracked_entity.shape default "rect",
        density: ∞,
        dice: dice,
        tracked_entity: tracked_entity})

    physics_add_entity(dice.physics, push(dice.obstruction_array, obstruction))

    return obstruction



/*
 Create a new die, add it to `dice`, and return the new die.

 - `dice`: Set of dice/tray to add to
 - `pos`: in the coordinate system where `dice_update()` will be called.
   It is the caller's responsibility to ensure this is inside the bounds
   of the dice tray and use `dice_correct_overlaps()` as needed for cleanup.
 - `bright_color`: may be a color or a hue percentage.
 - `label_array`: may be an array of strings, sprites, or numbers. Defaults
    to the numbers 1 through sides.
 - `value_array`: an array of any type of values, corresponding to
    the value for each face (used by the program, not displayed). Defaults
    to the same as the `label_array`
 - `translucent`: gem dice effect
 
 Can also be called as `dice_add_die(args)`,
 */
def dice_add_die(
    dice,
    sides,
    pos default round(random_within_region(dice)),
    radius default 12,
    font default ∅,
    label_array default ∅,
    value_array default label_array,
    bright_color default ∅,
    dim_color default ∅,
    label_color default #FFF,
    label_y_offset default 0,
    label_outline default #0000,
    translucent default false):
        
    if sides == ∅:
        // args version
        return dice_add_die(
            dice.dice,
            dice.sides,
            dice.pos, 
            dice.radius,
            dice.font,
            dice.label_array,
            dice.value_array,
            dice.bright_color, 
            dice.dim_color,
            dice.label_color,
            dice.label_y_offset,
            dice.label_outline,
            dice.translucent)

    assert(not isNaN(pos.x))
    ++dice_add_die.count
    
    // Dice with more sides should roll better, so decrease friction
    // with the number of sides.
    const base_drag = 0.0008 pow(20 / min(12, sides), 2.2)

    // Default value for label_array
    if label_array == ∅:
        label_array = make_array(sides)
        for 1 ≤ i ≤ sides:
            label_array[i - 1] = "" + i
    
    // Default value_array
    if value_array == ∅:
        value_array = label_array
    
    if bright_color == ∅ or is_number(bright_color):
        const hue = bright_color default ξ
        bright_color = artist_hsv_to_rgb(hue, 100%, 75%)
        dim_color = artist_hsv_to_rgb(hue + 22%, 88%, 40%)
        
    if dim_color == ∅:
        const temp = hsv(bright_color)
        dim_color = artist_hsv_to_rgb(temp.h + 22%, 88% temp.h, 60% temp.v)
    
    const die = make_entity({
        // Entity base properties
        name: "d" + sides + "_" + dice_add_die.count,
        shape: "disk",
        pos: xy(pos),
        vel: xy(0, 0),
        size: 2.2 radius * xy(1, 1),
        
        // Entity physics properties
        drag: base_drag,
        base_drag: base_drag,
        friction: 0,
        restitution: 90%,
        
        // Extended properties
        sides: sides,
        rotation: mat3x3_identity(),
        model: _dice_DATA_TABLE["d" + sides],
        result_index: sides - 1,
        label_font: font,
        label_color: rgb(label_color),
        label_outline: rgba(label_outline),
        label_array: clone(label_array),
        value_array: clone(value_array),
        bright_color: rgb(bright_color),
        dim_color: rgb(dim_color),
        translucent: translucent default false,
        
        label_y_offset: label_y_offset,
        
        // Array of positions and rotations
        history: [],
        
        // Increases with velocity each frame,
        // used to play the table sound for simulating
        // faces flipping over
        tumble_count: 0,
        
        draw: _dice_die_draw,
        dice: dice})
    
    // Show the highest value by default
    die_set_result_index(die, die.sides - 1)
        
    physics_add_entity(dice.physics, push(dice.die_array, die))

    return die


/* Constant for assisting in unique generated dice entity names */    
dice_add_die.count = 0    



/* Add `die` into `dice`, remove it from any previous dice set, and
   erase the history (for rolling purposes). 
   
   - `pos`: If specified, put the die at this location, _without_ 
     avoiding overlaps. If ∅, the die will go to a random
     position and then use `dice_correct_overlaps()` to avoid overlaps,
     which may move other dice. */
def dice_transfer(dice, die, pos default ∅):
    dice_remove(die.dice, die)
    
    // Add
    die.dice = dice
    remove_all(die.history)
    push(die.dice.die_array, die)
    physics_add_entity(die.dice.physics, die)
    
    // Reposition
    if pos:
        die.pos = xy(pos)
    else:
        die.pos = random_within_region(dice)
        dice_correct_overlaps(dice)


    
/* Remove `die_or_obstruction` or from `dice` */
def dice_remove(dice, die_or_obstruction):
    assert(contains(dice.die_array, die_or_obstruction) or contains(dice.obstruction_array, die_or_obstruction))
    remove_values(die_or_obstruction.dice.die_array, die_or_obstruction)
    remove_values(die_or_obstruction.dice.obstruction_array, die_or_obstruction)
    physics_remove_entity(die_or_obstruction.dice.physics, die_or_obstruction)
    die_or_obstruction.dice = ∅
    

/* Remove all dice and obstructions from `dice` */
def dice_remove_all(dice):
    dice_remove_all_obstructions(dice)
    dice_remove_all_dice(dice)


    
def dice_remove_all_dice(dice):
    for die in dice.die_array:
        die.dice = ∅
        remove_all(dice.history)
        physics_remove_entity(die.dice.physics, die)

    remove_all(dice.die_array)


    
def dice_remove_all_obstructions(dice):
    for obstruction in dice.obstruction_array:
        obstruction.dice = ∅
        physics_remove_entity(entity.dice.physics, entity)
    remove_all(dice.obstruction_array)

    
/* Fix any out of bounds or overlapping dice */
def dice_correct_overlaps(dice):
    // Simulated annealing
    for k < max(20, 4 size(dice.die_array)):
        for A at i in dice.die_array:
            // Avoid other dice
            for i < j < size(dice.die_array):
                const B = dice.die_array[j]
                const offset = A.pos - B.pos
                if ‖offset‖ < ½ (A.size.x + B.size.x):
                    const shift = xy(dice.size.x / dice.size.y, 1) * 300 direction(offset) / max(10, magnitude(offset))²
                    A.pos += shift
                    B.pos -= shift
            
            // Avoid obstructions
            for B in dice.obstruction_array:
                const offset = A.pos - B.pos
                if ‖offset‖ < ½ (A.size.x + B.size.x):
                    const shift = xy(dice.size.x / dice.size.y, 1) * 300 direction(offset) / max(10, magnitude(offset))²
                    A.pos += shift                
                    
            // Keep in the dice tray
            const side = max(½ dice.size - ½ A.size, xy(0, 0))
            A.pos = clamp(A.pos, dice.pos - side, dice.pos + side)
    


/* Return the mat3x3 suitable for use as `die.rotation`
   for the current `die.result_index` but do not modify `die`.*/
def die_rotation_for_result(die):
    assert(die.result_index ≥ 0 and die.result_index < die.sides)
    const normal = die.model.geometry.face_array[die.model.unmap[die.result_index]].normal
    const R = mat3x3_rotation_between(normal, xyz(0, 0, 1))
    
    if die.sides == 4:
        // The 4-sided die is a weird case because it does
        // not have a top face. We draw it rotated to look
        // plausibly like it is standing up.
        if die.result_index < 2:
            return mat3x3_mul(mat3x3_roll(-10°), mat3x3_mul(mat3x3_pitch(45°), R))
        else:
            return mat3x3_mul(mat3x3_mul(mat3x3_pitch(45°), mat3x3_roll(60°)), R)
    else:
        return R



def _dice_die_draw(die):
    _dice_die_model_draw(
        die.model, 
        die.pos, 
        die.rotation,
        die.bright_color,
        die.dim_color,
        die.dice.shadow_color,
        ½ die.size.x * |die.scale.x|,
        die.label_array,
        die.label_color,
        die.label_font,
        die.label_y_offset,
        die.label_outline,
        die.translucent)
        


/*
 Draw a convex solid polyhedral die with slightly 
 rounded edges, drop shadow, and a label on its top
 face.
 
 Assumes the ground plane is at z = 0.
 
 - `rotation`: 3x3 rotation matrix (see `mat3x3.pyxl` for helpers)
 - `pos`: `xyz()` translation
 - `label_array`: an array of strings or sprites. The default
    value maps each face to a number, based on 1.
 
 With zero rotation, `label[0]` will appear on the top face.
*/
def _dice_die_model_draw(
    model, 
    pos, 
    rotation,
    bright_color,
    dim_color,
    shadow_color,
    radius,
    label_array,
    label_color,
    label_font,
    label_y_offset,
    label_outline,
    translucent)
& preserving_transform:
    // Force Y=up, assumed by the orientation and shading code
    compose_transform(pos, xy(1, up_y()))

    if pos.z == ∅:
        pos = xy(0, 0)
    else:
        pos = xyz(0, 0, 0)
    
    // Ensure 3D pos, fix alignment to bounding dice,
    // Put on top of rolling surface
    pos = xyz(-0.5, 0.5, radius)
        
    // For the 4-sided die, draw the "top" face at a lower threshold
    // since it doesn't sit flat
    const shaded_face_threshold = if model.sides > 4 then 92% else 70%    

    if _dice_geometry_cache[model.sides] == ∅:
        _dice_geometry_cache[model.sides] = deep_clone(model.geometry)
        
    // Use the cached copy to minimize allocations
    const src_geometry = model.geometry
    const dst_geometry = _dice_geometry_cache[model.sides]
        
    // Apply the base transformation first
    const scale = radius
    
    const light_dir = direction(xyz(-1.2, 1.75, 0.4))
    const view_dir = xyz(0, 0, 1)
    const half_dir = direction(light_dir + view_dir)
    const edge_thickness = 1
    
    const shadow_offset = -½ radius * xy(light_dir)

    if translucent:
        // Tint shadows
        shadow_color = rgba(shadow_color)
        RGB_LERP(shadow_color, dim_color, 50%, shadow_color)
   
    
    // If translucent is true, returns an rgba() and tweaks glossy intensity,
    // otherwise returns an rgb()
    def shade(N, intensity, translucent, back_face):
        const diffuse_color = {r: 0, g: 0, b: 0}
        // Aliasing to reduce allocation
        const color = diffuse_color

        // Wrap shading
        let β = MAX(0, MAD((if back_face then -60% else 60%), XYZ_DOT_XYZ(N, light_dir), 40%))
        // Boost the bright color, which tends to get lost in the
        // shadow on translucent dice
        if translucent: β += 10%

        RGB_LERP(dim_color, bright_color, β, diffuse_color)
        
        // Scalar because we assume white light
        let glossy_intensity = MUL(intensity, MAX(0, XYZ_DOT_XYZ(N, half_dir))³)

        // Turn the rgb into an rgba and increase and sharpen glossy_intensity
        if translucent:
            glossy_intensity = pow(glossy_intensity, 1.6)
            RGB_ADD(diffuse_color, MUL(300%, glossy_intensity), color)
            color.a = MIN(MAD(130%, glossy_intensity, 40%), 50%)
        else:
            RGB_ADD(diffuse_color, glossy_intensity, color)
            
        return color
        

    // Draws the label on a face. Assums N.z > 10%        
    def draw_label(N, label, centroid):
        const label_z = pos.z + 140% radius
        const underscore = (label == 6 or label == 9 or label == "6" or label == "9")

        if label_outline.a > 0:
            const color = label_outline * rgba(1, 1, 1, clamp(1.2 N.z - 0.2, 0, 1)⁵)
            for i ≤ 0: 
                draw_text({
                    font: label_font, 
                    text: label, 
                    z: label_z,
                    pos: centroid + xyz(0, 1, 0),
                    outline: color,
                    shadow: color,
                    color: #0000})
        
        if N.z > shaded_face_threshold: // Top face
            const label_shadow_opacity = 28%
            const label_highlight_opacity = 45%
                        
            if label.spritesheet == ∅:
                // Text or number label

                // Inset
                draw_text({
                    font: label_font, 
                    text: label, 
                    z: label_z,
                    pos: centroid + xyz(0, +1, 0),
                    color: rgba(0, 0, 0, label_shadow_opacity)})
                 
                if underscore:
                    draw_text({
                        font: label_font, 
                        text: "_", 
                        z: label_z,
                        pos: centroid,
                        color: rgba(0, 0, 0, label_shadow_opacity)})
                    
                   
                // Label and shadow
                draw_text({
                    font: label_font, 
                    text: label, 
                    pos: centroid,
                    z: label_z,
                    color: label_color,
                    //outline: outline,
                    shadow: rgba(1, 1, 1, label_highlight_opacity)})
                 
                if underscore:                 
                    draw_text({
                        font: label_font, 
                        text: "_", 
                        pos: centroid + xyz(0, -1, 0),
                        z: label_z,
                        color: label_color,
                        shadow: rgba(1, 1, 1, label_highlight_opacity)})
                    
            else:
                // Sprite label
                draw_sprite({sprite: label, z: label_z, pos: centroid + xyz(0, 1, 0), override_color: #000, opacity: label_shadow_opacity})
                draw_sprite({sprite: label, z: label_z, pos: centroid + xyz(0, -1, 0), override_color: #FFF, opacity: label_highlight_opacity})
                draw_sprite({sprite: label, z: label_z, pos: centroid})
        
        else: // Side face
            
            let α = max(N.z - 0.05, 0)
            if model.sides == 20:
                // d20 has too many labels, make them
                // fade off more quickly
                α = α³
            else if model.sides == 12:
                // d12 faces are small in profile
                α = α^(3.5)
            else if model.sides == 8 or model.sides == 4:
                // Steep angles
                α = α^(1.5)
            else:
                α = α²
                
            if label.spritesheet:
                draw_sprite({sprite: label, pos: centroid, opacity: α, z: label_z})
            else:
                draw_text({font: label_font, pos: centroid, text: label, color: rgba(label_color.r, label_color.g, label_color.b, α), z: label_z})
                if underscore:
                    draw_text({font: label_font, pos: centroid + xyz(0, -1, 0), text: "_", color: rgba(label_color.r, label_color.g, label_color.b, α), z: label_z})
    
    // The vertex transform incorporates the scale
    const S = mat3x3_scale(scale)
    const SR = mat3x3_mul(S, rotation)
    
    // Transform all points and normals
    const vertex_array = dst_geometry.vertex_array
    for v < size(vertex_array):
        const V = vertex_array[v]
        MAT3x3_MATMUL_XYZ(SR, src_geometry.vertex_array[v], V)
        XYZ_ADD_XYZ(V, pos, V)

    const shadow_poly = convex_hull(vertex_array)
    
    // Faces
    const face_array = dst_geometry.face_array
    for f < size(face_array):
        const src_face = src_geometry.face_array[f]
        const dst_face = face_array[f]
        const N = dst_face.normal
        MAT3x3_MATMUL_XYZ(rotation, src_face.normal, N)
        dst_face.z = -∞

        const front_face = N.z ≥ 0
        
        // Draw if front face
        if front_face or translucent:         
            const poly = []
            const centroid = xyz(0, 0, 0)
            for i < size(dst_face.index_array):
                const V = vertex_array[dst_face.index_array[i]]
                push(poly, V)
                XYZ_ADD_XYZ(centroid, V, centroid)
                dst_face.z = MAX(dst_face.z, V.z)
            
            // Face
            //const debug_color = rgb(f ∩ 1, (f bitshr 1) ∩ 1, (f bitshr 2) ∩ 1)
            const face_color = shade(N, 60%, translucent, not front_face)
            draw_poly(poly, face_color, ∅, ∅, ∅, ∅, dst_face.z)
            
            if front_face:            
                XYZ_DIV(centroid, size(dst_face.index_array), centroid)
            
                centroid.y -= label_y_offset
                const label = label_array[model.remap[f]]
                if N.z > 10% and label:
                    draw_label(N, label, centroid)
            else:
                // Translucent backface. Flag z for edge detection
                dst_face.z = -infinity

    // Drop shadow
    draw_poly(shadow_poly, shadow_color, ∅, shadow_offset, ∅, ∅, 0)

    // Caustic
    if translucent:
        // Caustic in shadow
        if shadow_color.a > 0:
            draw_disk(2.3 shadow_offset, 15% radius, rgba(bright_color, 14%), rgba(bright_color, 7%), 0)

        // Caustic/highlight in the die center
        const alpha = if model.sides > 6 then 70% else 30%
        draw_disk(xy(0, 0), 50% radius, rgba(bright_color, alpha), rgba(bright_color, 1/3 alpha), 1)
        draw_disk(xy(0, 0), 30% radius, rgba(1, 1, 1, alpha), ∅, 1)

        
    // Edges
    const edge_array = dst_geometry.edge_array
    const silhouette_darkness = if translucent then 40% else 70%
    for e < size(edge_array):
        const edge = edge_array[e]
        const face0 = face_array[edge.face_index_array[0]]
        const face1 = face_array[edge.face_index_array[1]]

        // Use the max of the face z values to ensure
        // the edge overdraws correctly. Backfaces have z = infinity
        const z = MAX(face0.z, face1.z)
        
        // Draw edge if either face is a front face
        if z > -∞:
            const N = edge.normal
            MAT3x3_MATMUL_XYZ(rotation, src_geometry.edge_array[e].normal, N)
            
            const V0 = vertex_array[edge.index_array[0]]
            const V1 = vertex_array[edge.index_array[1]]
            
            const color = shade(N, 75%, translucent)
                        
            if MIN(face0.z, face1.z) == -∞:
                // Silhouette edge, darken, thicken and push back
                draw_line(V0, V1, silhouette_darkness * rgb(color), z - ε, 2)
            else:
                // Front face. Push away from the vertices
                // to highlight/smooth the center of the edge
                // only
                const dir = direction(V1 - V0)
                draw_line(V0 + dir, V1 - dir, color, z, edge_thickness)

    // Visualize bounds    
    if false:
        draw_disk(xy(0, 0), radius, ∅, #FFF)
        draw_rect(xy(0, 0), xy(2, 2) * radius, ∅, #FFF)



/* Sets the `die.result_index` and `die.rotation`, wipes the history. */
def die_set_result_index(die, i):
    die.result_index = i
    die.rotation = die_rotation_for_result(die)
    remove_all(die.history)


/*
  Place each die in `dice` within the rectangular area that
  was specified when `dice` was created.
  
  - `method`: "random" or "grid"
*/
def dice_set_initial_positions(dice, method default "random"):  
   
    if method == "grid":
        const aspect = dice.size.y / dice.size.x
        const N = size(dice.die_array)

        // Constraints:  
        //   x_count * y_count ≥ N
        //   y_count = aspect * x_count
        //
        //   x_count² * aspect ≤ N
        //   x_count ≤ sqrt(N / aspect)
        
        const x_count = max(⌊sqrt(N / aspect)⌋, 1)
        const y_count = ⌈N / x_count⌉
        
        for die at i in dice.die_array:
            const x = i mod x_count
            const y = floor(i / x_count)
            
            const α = (xy(x, y) + xy(if y mod 2 then ⅓ else ⅔, ½)) / xy(x_count, y_count)
            die.pos = dice.pos + dice.size * (α - ½)
            remove_all(die.history)

    else: // Random
        // Distribute the dice randomly
        for die at i in dice.die_array:
            die.pos = random_within_region(dice)
            remove_all(die.history)
    
    dice_correct_overlaps(dice)
    
    
    
/* Run simulation until termination */
def _dice_preroll_simulate(dice):
    assert(size(dice.die_array) > 0)
    
    // Erase previous history, set initial velocity
    for die in dice.die_array:
        die.vel = 7 random_on_circle()
        die.drag = die.base_drag
        remove_all(die.history)
    
    let any_awake = true

    // Fail-safe
    const MAX_STEPS = 400
    let steps = 0
    
    while any_awake and steps < MAX_STEPS:
        any_awake = false
        ++steps
        
        physics_simulate(dice.physics)
            
        for die in dice.die_array:
            const speed = ‖die.vel‖
                
            if speed < 1.5:
                // Add drag when moving slowly, so that they tend to stop
                // in the middle instead of near walls
                die.drag = 15 die.base_drag
                //draw_disk(die.pos, 20, ∅, #F00)
                
            if die.physics_sleep_state ≠ "sleeping": 
                any_awake = true
            
            // Rotate based on velocity, adding some yaw
            const tumble_axis = direction(xyz(-die.vel.y, die.vel.x, 30% die.vel.x))
            const R = mat3x3_from_axis_angle(tumble_axis, 150 deg ‖die.vel‖ / |die.size.x * die.scale.x|)
            die.rotation = mat3x3_mul(R, die.rotation, true)
            assert(not is_nan(die.pos.x) and not is_nan(die.rotation[0][0]))

            const [axis, angle] = mat3x3_to_axis_angle(die.rotation)
            const state = {pos:xy(die.pos), axis: axis, angle: angle}

            const old = die.tumble_count
            die.tumble_count += 1% speed * die.sides
            if ⌊die.tumble_count⌋ > ⌊old⌋:
                // Play a sound
                state.sound_data = {sound: dice.table_sound, pan: xy(die.pos), pitch: 50% - die.sides / 60, volume: clamp(3% speed, 2%, 10%)}
                
            push(die.history, state)

    assert(size(dice.die_array[0].history) > 0)

    // The last few frames of the simulation are boring because it is almost
    // at rest. Preserve the final exact one and remove the boring frames
    const REMOVE_FRAMES = 40
    if size(dice.die_array[0].history) > REMOVE_FRAMES:
        for die in dice.die_array:
            for i < REMOVE_FRAMES:
                remove_key(die.history, size(die.history) - 2)
 



def _dice_collision_callback(args):
    const die = if args.entityA.history then args.entityA else args.entityB
    if die.history and size(die.history) > 0:
        let sound_data
        
        if max(args.entityA.density, args.entityB.density) == ∞:
            // Wall
            sound_data = {
                sound: die.dice.wall_sound,
                volume: 25% args.depth}
        else:
            // Dice                
            sound_data = {
                sound: die.dice.die_sound,
                pitch: 200% - die.sides / 20, 
                volume: 35% args.depth}
            
        last_value(die.history).sound_data = sound_data



/* For each die in dice, adjust stored `die.history` rotations to achieve 
   `die.result_index` facing up */
def _dice_adjust_result(dice):
    assert(size(dice.die_array[0].history) > 0)
    for die in dice.die_array:
        // Rotation that makes face[current] point up
        const desired = die_rotation_for_result(die)
        const last_state = last_value(die.history)
        assert(last_state)
        const actual = mat3x3_from_axis_angle(last_state.axis, last_state.angle)
        
        const change = mat3x3_mul(mat3x3_transpose(actual), desired)
        
        // Apply transformation to all history to achieve final result,
        // but start after the first frame to hide the initial transformation
        for 1 ≤ f < size(die.history):
            const state = die.history[f]
            let M = mat3x3_from_axis_angle(state.axis, state.angle)

            M = mat3x3_mul(M, change)
            const [axis, angle] = mat3x3_to_axis_angle(M)
            state.axis = axis
            state.angle = angle



/* Number of remaining frames on the rolling
   animation to reach the final state */
def dice_roll_time(dice):
    if size(dice.die_array) > 0:
        let t = 0
        for d < size(dice.die_array):
            t = max(size(dice.die_array[d].history) - 1, t)
        return t
    else:
        return 0
      
     
     
def _dice_replay_simulation(dice):        
    for die in dice.die_array:
        if size(die.history) > 1:
            pop_front(die.history)
            const state = die.history[0]
            die.rotation = mat3x3_from_axis_angle(state.axis, state.angle)
            die.vel = state.pos - die.pos
            die.pos = state.pos
            
            if state.sound_data and state.sound_data.sound:
                play_sound({…state.sound_data, pos: die.pos})
            
        
        
def _dice_draw(dice):
    for die in dice.die_array:
        die.draw(die)
   
   
   
def dice_update(dice, no_clip)
& preserving_transform:
    
    if not no_clip:
        intersect_clip(transform_cs_to_ss(dice.pos + xy(-½, ½ up_y()) * dice.size), dice.size)

    _dice_replay_simulation(dice)
    _dice_draw(dice)
    
    
    
/* Prepare all of the dice to be rolled.
   If `random_results` is `false` then
   each `die.result_index` is unmodified, otherwise
   the final results will be random. */
def dice_prepare_roll(dice, random_results default true, rng default random):
    for obstruction in dice.obstruction_array:
        obstruction.pos = xy(obstruction.tracked_entity.pos)
    
    if size(dice.die_array) > 0:
        if random_results:
            for die in dice.die_array:
                die.result_index = random_integer(0, die.sides - 1, rng)
        
        _dice_preroll_simulate(dice)
        _dice_adjust_result(dice)


// Remap the geometry faces to the labels.
//
// label_index = die.model.remap[face]
// result = die.model.unmap[label_index]

const _dice_DATA_TABLE = {
    d4:  {remap:[0, 1, 2, 3], geometry:{vertex_array:[{x:-0.9166666666666666,y:-0.6376290442079258,z:-0.11243120417720794},{x:0.9166666666666666,y:-0.6376290442079258,z:-0.11243120417720782},{x:0,y:0.47845154801323964,z:1.0151716444383985},{x:0,y:0.7968065404026119,z:-0.7903092360839827}],face_array:[{index_array:[0,1,2],normal:{x:0,y:-0.7107290586752417,z:0.7034654144701108}},{index_array:[0,2,3],normal:{x:-0.816195,y:0.5689981900003974,z:0.10033028432415873}},{index_array:[3,1,0],normal:{x:0,y:-0.42726750993352125,z:-0.9041249134694874}},{index_array:[3,2,1],normal:{x:0.816195,y:0.5689983758932027,z:0.10032923007367195}}],edge_array:[{index_array:[0,1],face_index_array:[0,2],normal:{x:0,y:-0.984807753012208,z:-0.17364817766693033}},{index_array:[0,2],face_index_array:[1,0],normal:{x:-0.707106,y:-0.1227878419655301,z:0.6963644558092034}},{index_array:[0,3],face_index_array:[2,1],normal:{x:-0.707107,y:0.12278766831735245,z:-0.6963634710014504}},{index_array:[1,2],face_index_array:[0,3],normal:{x:0.707107,y:-0.12278766831735245,z:0.6963634710014504}},{index_array:[1,3],face_index_array:[3,2],normal:{x:0.707106,y:0.1227878419655301,z:-0.6963644558092034}},{index_array:[2,3],face_index_array:[1,3],normal:{x:0,y:0.984807753012208,z:0.17364817766693033}}]},"sides":4},
    d6:  {remap:[0, 1, 2, 4, 3, 5], geometry:{vertex_array:[{x:0.7083333333333334,y:-0.7083333333333334,z:-0.7083333333333334},{x:-0.7083333333333334,y:-0.7083333333333334,z:-0.7083333333333334},{x:-0.7083333333333334,y:0.7083333333333334,z:-0.7083333333333334},{x:0.7083333333333334,y:0.7083333333333334,z:-0.7083333333333334},{x:-0.7083333333333334,y:-0.7083333333333334,z:0.7083333333333334},{x:-0.7083333333333334,y:0.7083333333333334,z:0.7083333333333334},{x:0.7083333333333334,y:0.7083333333333334,z:0.7083333333333334},{x:0.7083333333333334,y:-0.7083333333333334,z:0.7083333333333334}],face_array:[{index_array:[0,1,2,3],normal:{x:0,y:0,z:-1}},{index_array:[2,1,4,5],normal:{x:-1,y:0,z:0}},{index_array:[6,3,2,5],normal:{x:0,y:1,z:0}},{index_array:[3,6,7,0],normal:{x:1,y:0,z:0}},{index_array:[1,0,7,4],normal:{x:0,y:-1,z:0}},{index_array:[5,4,7,6],normal:{x:0,y:0,z:1}}],edge_array:[{index_array:[0,1],face_index_array:[0,4],normal:{x:0,y:-0.707107,z:-0.707107}},{index_array:[6,7],face_index_array:[3,5],normal:{x:0.707107,y:0,z:0.707106}},{index_array:[0,3],face_index_array:[3,0],normal:{x:0.707106,y:0,z:-0.707107}},{index_array:[0,7],face_index_array:[4,3],normal:{x:0.707107,y:-0.707107,z:0}},{index_array:[5,6],face_index_array:[2,5],normal:{x:0,y:0.707107,z:0.707107}},{index_array:[1,2],face_index_array:[0,1],normal:{x:-0.707107,y:0,z:-0.707107}},{index_array:[1,4],face_index_array:[1,4],normal:{x:-0.707107,y:-0.707107,z:0}},{index_array:[2,3],face_index_array:[0,2],normal:{x:0,y:0.707107,z:-0.707107}},{index_array:[4,7],face_index_array:[5,4],normal:{x:0,y:-0.707107,z:0.707107}},{index_array:[2,5],face_index_array:[2,1],normal:{x:-0.707107,y:0.707107,z:0}},{index_array:[4,5],face_index_array:[1,5],normal:{x:-0.707107,y:0,z:0.707107}},{index_array:[3,6],face_index_array:[3,2],normal:{x:0.707107,y:0.707107,z:0}}]},"sides":6},
    d8:  {remap:[0, 4, 6, 2, 3, 7, 1, 5], geometry:{vertex_array:[{x:0.8840725,y:0.5915599679901917,z:0.6569939037218636},{x:0,y:-0.9289310318467427,z:0.8364132579485728},{x:0.8840725,y:-0.5915599679901917,z:-0.6569939037218636},{x:-0.8840725,y:0.5915599679901917,z:0.6569939037218636},{x:-0.8840725,y:-0.5915599679901917,z:-0.6569939037218636},{x:0,y:0.9289310318467427,z:-0.8364132579485728}],face_array:[{index_array:[0,1,2],normal:{x:0.816439,y:-0.4291148597202372,z:0.3863767551604018}},{index_array:[3,4,1],normal:{x:-0.816438,y:-0.42911634600988824,z:0.3863780934216146}},{index_array:[1,0,3],normal:{x:0,y:0.11718872025995719,z:0.9931098424589465}},{index_array:[4,2,1],normal:{x:0,y:-0.9754199259900825,z:-0.22035499387693014}},{index_array:[5,2,4],normal:{x:0,y:-0.11718872025995719,z:-0.9931098424589465}},{index_array:[3,0,5],normal:{x:0,y:0.9754199259900825,z:0.22035499387693014}},{index_array:[5,4,3],normal:{x:-0.816439,y:0.4291156028650626,z:-0.38637742429100813}},{index_array:[5,0,2],normal:{x:0.816438,y:0.42911634600988824,z:-0.3863780934216146}}],edge_array:[{index_array:[0,1],face_index_array:[0,2],normal:{x:0.49994700000000003,y:-0.19100880471346246,z:0.8447301465290169}},{index_array:[0,2],face_index_array:[7,0],normal:{x:1,y:0,z:0}},{index_array:[0,3],face_index_array:[2,5],normal:{x:0,y:0.6691306063588582,z:0.7431448254773942}},{index_array:[0,5],face_index_array:[5,7],normal:{x:0.49994599999999995,y:0.8600684832280466,z:-0.10166409440312331}},{index_array:[1,2],face_index_array:[0,3],normal:{x:0.49994700000000003,y:-0.8600684832280466,z:0.10166409440312328}},{index_array:[1,4],face_index_array:[3,1],normal:{x:-0.49994599999999995,y:-0.8600684832280466,z:0.10166409440312331}},{index_array:[1,3],face_index_array:[1,2],normal:{x:-0.49994599999999995,y:-0.19100880471346252,z:0.8447301465290169}},{index_array:[2,4],face_index_array:[4,3],normal:{x:0,y:-0.6691306063588582,z:-0.7431448254773942}},{index_array:[2,5],face_index_array:[7,4],normal:{x:0.49994599999999995,y:0.19100880471346252,z:-0.8447301465290169}},{index_array:[3,4],face_index_array:[1,6],normal:{x:-1,y:0,z:0}},{index_array:[3,5],face_index_array:[6,5],normal:{x:-0.49994700000000003,y:0.8600684832280466,z:-0.10166409440312328}},{index_array:[4,5],face_index_array:[4,6],normal:{x:-0.49994700000000003,y:0.19100880471346246,z:-0.8447301465290169}}]},"sides":8},
    d10: {remap:[0, 8, 1, 5, 6, 4, 7, 3, 2, 9], geometry:{vertex_array:[{x:0,y:0.9510565162951535,z:0.3090169943749474},{x:0.8674562703721571,y:0.18750330838818283,z:-0.23543444080361964},{x:0.5361170213728716,y:0.12761852919852631,z:-0.7344108509414091},{x:0,y:0.3822593397164907,z:-0.8348318721883408},{x:0.5361171652602079,y:-0.12761836040517174,z:0.7344103314488806},{x:0.867455677210434,y:-0.18750343947316572,z:0.23543484424171346},{x:0,y:-0.9510565162951535,z:-0.3090169943749474},{x:-0.5361171652602079,y:0.12761836040517174,z:-0.7344103314488806},{x:-0.867455677210434,y:0.18750343947316572,z:-0.23543484424171346},{x:-0.5361170213728716,y:-0.12761852919852631,z:0.7344108509414091},{x:0,y:-0.3822593397164907,z:0.8348318721883408},{x:-0.8674562703721571,y:-0.18750330838818283,z:0.23543444080361964}],face_array:[{index_array:[0,1,2,3],normal:{x:0.4534024401801491,y:0.7980794813582818,z:-0.3968574334085002}},{index_array:[1,0,4,5],normal:{x:0.733619661117717,y:0.5315766578301304,z:0.42335391917481363}},{index_array:[2,1,5,6],normal:{x:0.733619654646549,y:-0.5315764166606355,z:-0.4233546614181978}},{index_array:[3,2,6,7],normal:{x:0,y:-0.36686874018878707,z:-0.9302727657419936}},{index_array:[0,3,7,8],normal:{x:-0.45340167341660187,y:0.7980794490094587,z:-0.3968573338490596}},{index_array:[4,0,9,10],normal:{x:0,y:0.36686874018878707,z:0.9302727657419936}},{index_array:[5,4,10,6],normal:{x:0.45340167341660187,y:-0.7980794490094587,z:0.3968573338490596}},{index_array:[7,6,11,8],normal:{x:-0.733619661117717,y:-0.5315766578301304,z:-0.42335391917481363}},{index_array:[0,8,11,9],normal:{x:-0.7336202424318012,y:0.5315766666606355,z:0.4233538919973135}},{index_array:[10,9,11,6],normal:{x:-0.4534024401801491,y:-0.7980794813582818,z:0.3968574334085002}}],edge_array:[{index_array:[0,1],face_index_array:[0,1],normal:{x:0.6658887345533389,y:0.7459030603708008,z:0.014863369955244399}},{index_array:[9,11],face_index_array:[9,8],normal:{x:-0.8090169943749475,y:-0.1816356320013402,z:0.5590169943749475}},{index_array:[0,3],face_index_array:[4,0],normal:{x:0,y:0.895404332278156,z:-0.44525423338078374}},{index_array:[0,4],face_index_array:[1,5],normal:{x:0.41154195888934114,y:0.5040046410130604,z:0.7593501528812778}},{index_array:[9,10],face_index_array:[5,9],normal:{x:-0.3090171472195055,y:-0.2938925640948282,z:0.904508306212876}},{index_array:[0,8],face_index_array:[8,4],normal:{x:-0.6658889624223508,y:0.7459029497479648,z:0.014863710417325593}},{index_array:[0,9],face_index_array:[5,8],normal:{x:-0.41154230018133986,y:0.5040047216553201,z:0.7593499046899231}},{index_array:[8,11],face_index_array:[8,7],normal:{x:-0.9999998562569681,y:0,z:0}},{index_array:[1,2],face_index_array:[0,2],normal:{x:0.8090169943749475,y:0.1816356320013402,z:-0.5590169943749475}},{index_array:[7,8],face_index_array:[4,7],normal:{x:-0.8090172832402858,y:0.18163575190584186,z:-0.5590173634030582}},{index_array:[1,5],face_index_array:[2,1],normal:{x:1,y:0,z:0}},{index_array:[2,3],face_index_array:[0,3],normal:{x:0.3090171472195055,y:0.2938925640948282,z:-0.904508306212876}},{index_array:[6,11],face_index_array:[7,9],normal:{x:-0.6658887345533389,y:-0.7459030603708008,z:-0.014863369955244399}},{index_array:[2,6],face_index_array:[3,2],normal:{x:0.41154230018133986,y:-0.5040047216553201,z:-0.7593499046899231}},{index_array:[6,10],face_index_array:[9,6],normal:{x:0,y:-0.895404332278156,z:0.44525423338078374}},{index_array:[3,7],face_index_array:[4,3],normal:{x:-0.30901727413875957,y:0.2938927480941581,z:-0.9045088725045844}},{index_array:[4,5],face_index_array:[1,6],normal:{x:0.8090172832402858,y:-0.18163575190584186,z:0.5590173634030582}},{index_array:[6,7],face_index_array:[3,7],normal:{x:-0.41154195888934114,y:-0.5040046410130604,z:-0.7593501528812778}},{index_array:[4,10],face_index_array:[6,5],normal:{x:0.30901727413875957,y:-0.2938927480941581,z:0.9045088725045844}},{index_array:[5,6],face_index_array:[2,6],normal:{x:0.6658889624223508,y:-0.7459029497479648,z:-0.014863710417325593}}]},"sides":10},
    d12: {remap:[7, 5, 6, 2, 4, 1, 3, 0, 8, 9, 10, 11], geometry:{vertex_array:[{x:0.5149316666666667,y:-0.21291190129222534,z:-0.6964034498481121},{x:0,y:-0.5863091326721404,z:-0.6723582874671794},{x:-0.5149316666666667,y:-0.21291190129222534,z:-0.6964034498481121},{x:-0.31840166666666664,y:0.3912263023215757,z:-0.7357896607157726},{x:0.31840166666666664,y:0.3912263023215757,z:-0.7357896607157726},{x:0,y:0.5863091326721404,z:0.6723582874671794},{x:0.5149316666666667,y:0.21291190129222534,z:0.6964034498481121},{x:0.8333333333333334,y:0.2811319851456038,z:0.14948052804363227},{x:0.5149316666666667,y:-0.6964034498481121,z:0.21291190129222534},{x:0.8333333333333334,y:-0.2811319851456038,z:-0.14948052804363227},{x:0.31840166666666664,y:-0.3912263023215757,z:0.7357896607157726},{x:0,y:0.8852701887594048,z:0.1100943171759719},{x:-0.5149316666666667,y:0.6964034498481121,z:-0.21291190129222534},{x:-0.8333333333333334,y:-0.2811319851456038,z:-0.14948052804363227},{x:-0.8333333333333334,y:0.2811319851456038,z:0.14948052804363227},{x:0,y:-0.8852701887594048,z:-0.1100943171759719},{x:-0.31840166666666664,y:-0.3912263023215757,z:0.7357896607157726},{x:-0.5149316666666667,y:0.21291190129222534,z:0.6964034498481121},{x:-0.5149316666666667,y:-0.6964034498481121,z:0.21291190129222534},{x:0.5149316666666667,y:0.6964034498481121,z:-0.21291190129222534}],face_array:[{index_array:[0,1,2,3,4],normal:{x:0,y:-0.06505556701552073,z:-0.9978822591970904}},{index_array:[8,9,7,6,10],normal:{x:0.850536,y:-0.24690307588566732,z:0.4643571491935883}},{index_array:[14,12,3,2,13],normal:{x:-0.850536,y:0.24690307588566732,z:-0.4643571491935883}},{index_array:[15,8,10,16,18],normal:{x:0.000466775,y:-0.8635836852808229,z:0.5042054831740654}},{index_array:[16,10,6,5,17],normal:{x:0,y:0.06505556701552073,z:0.9978822591970904}},{index_array:[13,18,16,17,14],normal:{x:-0.850535,y:-0.2469035453572301,z:0.46435803214118115}},{index_array:[15,18,13,2,1],normal:{x:-0.525789,y:-0.7512674972488992,z:-0.39892761682851496}},{index_array:[11,12,14,17,5],normal:{x:-0.525918,y:0.7509787138398603,z:0.3993024651256604}},{index_array:[11,5,6,7,19],normal:{x:0.52566,y:0.7511191025071249,z:0.39937711110414337}},{index_array:[11,19,4,3,12],normal:{x:0.000465599,y:0.8635836852808229,z:-0.5042054831740654}},{index_array:[19,7,9,0,4],normal:{x:0.850535,y:0.2469035453572301,z:-0.46435803214118115}},{index_array:[8,15,1,0,9],normal:{x:0.525918,y:-0.7509787138398603,z:-0.3993024651256604}}],edge_array:[{index_array:[0,1],face_index_array:[0,11],normal:{x:0.309177,y:-0.4792657543670661,z:-0.8214096154270214}},{index_array:[16,18],face_index_array:[3,5],normal:{x:-0.500136,y:-0.6527825097212672,z:0.5689796076969751}},{index_array:[16,17],face_index_array:[5,4],normal:{x:-0.500061,y:-0.10664624199092015,z:0.8593982567530691}},{index_array:[0,4],face_index_array:[10,0],normal:{x:0.499938,y:0.10660120313731386,z:-0.8594754351287053}},{index_array:[15,18],face_index_array:[6,3],normal:{x:-0.309253,y:-0.9489651959002473,z:0.06186644246281975}},{index_array:[0,9],face_index_array:[11,10],normal:{x:0.808719,y:-0.29678565259019934,z:-0.507830167679717}},{index_array:[1,2],face_index_array:[0,6],normal:{x:-0.309055,y:-0.47910616445213994,z:-0.8215478762640429}},{index_array:[14,17],face_index_array:[7,5],normal:{x:-0.808871,y:0.2963201018629518,z:0.5078601096295414}},{index_array:[1,15],face_index_array:[6,11],normal:{x:0.000151461,y:-0.882947592858927,z:-0.4694715627858908}},{index_array:[13,18],face_index_array:[5,6],normal:{x:-0.808842,y:-0.5867807189274731,z:0.0382549758849475}},{index_array:[2,3],face_index_array:[0,2],normal:{x:-0.499939,y:0.10660073366575107,z:-0.8594745521811124}},{index_array:[2,13],face_index_array:[2,6],normal:{x:-0.808842,y:-0.2964092710434601,z:-0.5078542909314488}},{index_array:[3,4],face_index_array:[0,9],normal:{x:0,y:0.4693378306605288,z:-0.8830186994912981}},{index_array:[13,14],face_index_array:[2,5],normal:{x:-1,y:0,z:0}},{index_array:[3,12],face_index_array:[9,2],normal:{x:-0.50026,y:0.652693340540759,z:-0.5689737889988825}},{index_array:[12,14],face_index_array:[7,2],normal:{x:-0.808918,y:0.5866627013631841,z:-0.038454767913115084}},{index_array:[11,19],face_index_array:[9,8],normal:{x:0.309253,y:0.9489651959002473,z:-0.06186644246281975}},{index_array:[4,19],face_index_array:[10,9],normal:{x:0.500259,y:0.6526938100123217,z:-0.5689746719464753}},{index_array:[11,12],face_index_array:[7,9],normal:{x:-0.309253,y:0.9489651959002473,z:-0.06186644246281975}},{index_array:[5,6],face_index_array:[8,4],normal:{x:0.309055,y:0.47910616445213994,z:0.8215478762640429}},{index_array:[10,16],face_index_array:[3,4],normal:{x:0,y:-0.46933786156369456,z:0.8830186830597934}},{index_array:[5,17],face_index_array:[4,7],normal:{x:-0.309177,y:0.4792657543670661,z:0.8214096154270214}},{index_array:[5,11],face_index_array:[7,8],normal:{x:-0.000151461,y:0.882947592858927,z:0.4694715627858908}},{index_array:[6,7],face_index_array:[8,1],normal:{x:0.808842,y:0.2964092710434601,z:0.5078542909314488}},{index_array:[6,10],face_index_array:[1,4],normal:{x:0.499939,y:-0.10660073366575107,z:0.8594745521811124}},{index_array:[8,15],face_index_array:[11,3],normal:{x:0.309376,y:-0.9489388750763101,z:0.06165505605306898}},{index_array:[7,9],face_index_array:[10,1],normal:{x:1,y:0,z:0}},{index_array:[8,10],face_index_array:[3,1],normal:{x:0.50026,y:-0.652693340540759,z:0.5689737889988825}},{index_array:[8,9],face_index_array:[1,11],normal:{x:0.808795,y:-0.5868522892234673,z:0.0381297133896375}},{index_array:[7,19],face_index_array:[8,10],normal:{x:0.808918,y:0.586663170834747,z:-0.0384556508607079}}]},"sides":12},
    d20: {remap:[2, 1, 0, 4, 3, 7, 6, 5, 9, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], geometry:{vertex_array:[{x:0,y:-0.9659258262890683,z:0.25881904510252074},{x:0.8506506267003252,y:-0.5035113618811431,z:-0.15122777481646782},{x:0.5257309789904098,y:-0.24469226870440436,z:0.8146982308880245},{x:-0.5257313391170517,y:-0.2446923434771421,z:0.8146979518323682},{x:-0.8506509660565227,y:-0.5035113333830682,z:-0.1512276684602043},{x:0,y:-0.6634703749649558,z:-0.7482029387738315},{x:0.5257313391170517,y:0.2446923434771421,z:-0.8146979518323682},{x:0.8506509660565227,y:0.5035113333830682,z:0.1512276684602043},{x:0,y:0.6634703749649558,z:0.7482029387738315},{x:-0.8506506267003252,y:0.5035113618811431,z:0.15122777481646782},{x:-0.5257309789904098,y:0.24469226870440436,z:-0.8146982308880245},{x:0,y:0.9659258262890683,z:-0.25881904510252074}],face_array:[{index_array:[0,1,2],normal:{x:0.5773497914192821,y:-0.7190243008052122,z:0.3868720637739136}},{index_array:[0,2,3],normal:{x:0,y:-0.6104576390690677,z:0.7920483613813487}},{index_array:[0,3,4],normal:{x:-0.5773502708951684,y:-0.7190243164093653,z:0.38687200553842166}},{index_array:[0,4,5],normal:{x:-0.3568215557072163,y:-0.8946889015776134,z:-0.26871715139999075}},{index_array:[0,5,1],normal:{x:0.3568216674855672,y:-0.8946888699788245,z:-0.26871703347170495}},{index_array:[1,6,7],normal:{x:0.9341724099613656,y:0.10264034996952541,z:-0.34174082942795614}},{index_array:[2,7,8],normal:{x:0.5773501591168175,y:0.3868715808792821,z:0.7190245654250975}},{index_array:[3,8,9],normal:{x:-0.577349903197633,y:0.3868715652751291,z:0.7190245071896055}},{index_array:[4,9,10],normal:{x:-0.9341718266023848,y:0.10264038274606682,z:-0.3417407071042382}},{index_array:[5,10,6],normal:{x:0,y:-0.07302320489756609,z:-0.99733000493341}},{index_array:[7,2,1],normal:{x:0.9341718266023848,y:-0.10264134867189315,z:0.3417409659232833}},{index_array:[8,3,2],normal:{x:0,y:0.07302320489756609,z:0.99733000493341}},{index_array:[9,4,3],normal:{x:-0.9341724099613656,y:-0.10264034996952541,z:0.34174082942795614}},{index_array:[10,5,4],normal:{x:-0.5773501591168175,y:-0.3868715808792821,z:-0.7190245654250975}},{index_array:[6,1,5],normal:{x:0.577349903197633,y:-0.3868715652751291,z:-0.7190245071896055}},{index_array:[11,8,7],normal:{x:0.3568215557072163,y:0.8946889015776134,z:0.26871715139999075}},{index_array:[11,9,8],normal:{x:-0.3568226185420835,y:0.8946889499583078,z:0.26871733195920056}},{index_array:[11,10,9],normal:{x:-0.5773497914192821,y:0.7190252667310385,z:-0.3868723225929587}},{index_array:[11,6,10],normal:{x:0,y:0.6104576390690677,z:-0.7920483613813487}},{index_array:[11,7,6],normal:{x:0.5773502708951684,y:0.7190252823351916,z:-0.3868722643574668}}],edge_array:[{index_array:[0,1],face_index_array:[0,4],normal:{x:0.4999998933683673,y:-0.8637134638483929,z:0.06324054997098227}},{index_array:[0,2],face_index_array:[1,0],normal:{x:0.3090171388247843,y:-0.7115834672395087,z:0.6309974266706189}},{index_array:[0,3],face_index_array:[2,1],normal:{x:-0.30901660824247307,y:-0.711583486033115,z:0.6309973565319251}},{index_array:[0,4],face_index_array:[3,2],normal:{x:-0.4999996173439993,y:-0.8637135065260279,z:0.06324039069588}},{index_array:[0,5],face_index_array:[4,3],normal:{x:0,y:-0.9577350066255503,z:-0.28765262467938}},{index_array:[1,2],face_index_array:[0,10],normal:{x:0.8090170321931517,y:-0.43978254155143515,z:0.3899778129713857}},{index_array:[1,5],face_index_array:[14,4],normal:{x:0.5000000378182042,y:-0.6859340809374768,z:-0.5286722383786132}},{index_array:[1,6],face_index_array:[5,14],normal:{x:0.8090174526673567,y:-0.15213005779476121,z:-0.5677571050484386}},{index_array:[1,7],face_index_array:[10,5],normal:{x:1.000000461768883,y:0,z:0}},{index_array:[2,3],face_index_array:[1,11],normal:{x:0,y:-0.28765248375667396,z:0.9577349180198242}},{index_array:[2,7],face_index_array:[6,10],normal:{x:0.8090167561687835,y:0.15213003928651914,z:0.5677570359747389}},{index_array:[2,8],face_index_array:[11,6],normal:{x:0.3090169943749474,y:0.2461515393860416,z:0.9186500513499989}},{index_array:[3,4],face_index_array:[2,12],normal:{x:-0.8090171766429887,y:-0.4397825230431931,z:0.3899778820450854}},{index_array:[3,8],face_index_array:[7,11],normal:{x:-0.30901675269230994,y:0.24615152059243528,z:0.9186499812113053}},{index_array:[3,9],face_index_array:[12,7],normal:{x:-0.8090174526673567,y:0.15213005779476121,z:0.5677571050484386}},{index_array:[4,5],face_index_array:[3,13],normal:{x:-0.49999947289416236,y:-0.6859341236151117,z:-0.5286723976537155}},{index_array:[4,9],face_index_array:[8,12],normal:{x:-1,y:0,z:0}},{index_array:[4,10],face_index_array:[13,8],normal:{x:-0.8090167561687835,y:-0.15213003928651914,z:-0.5677570359747389}},{index_array:[5,10],face_index_array:[9,13],normal:{x:-0.3090169943749474,y:-0.2461515393860416,z:-0.9186500513499989}},{index_array:[5,6],face_index_array:[14,9],normal:{x:0.30901675269230994,y:-0.24615152059243528,z:-0.9186499812113053}},{index_array:[6,7],face_index_array:[5,19],normal:{x:0.8090171766429887,y:0.4397825230431931,z:-0.3899778820450854}},{index_array:[6,10],face_index_array:[18,9],normal:{x:0,y:0.28765248375667396,z:-0.9577349180198242}},{index_array:[6,11],face_index_array:[19,18],normal:{x:0.30901660824247307,y:0.711583486033115,z:-0.6309973565319251}},{index_array:[7,8],face_index_array:[6,15],normal:{x:0.5000004239506787,y:0.6859340436356284,z:0.5286720991662199}},{index_array:[7,11],face_index_array:[15,19],normal:{x:0.4999996173439993,y:0.8637135065260279,z:-0.06324039069588}},{index_array:[8,9],face_index_array:[7,16],normal:{x:-0.5000000378182042,y:0.6859340809374768,z:0.5286722383786132}},{index_array:[8,11],face_index_array:[16,15],normal:{x:0,y:0.9577350066255503,z:0.28765262467938}},{index_array:[9,10],face_index_array:[8,17],normal:{x:-0.8090170321931517,y:0.43978254155143515,z:-0.3899778129713857}},{index_array:[9,11],face_index_array:[17,16],normal:{x:-0.4999998933683673,y:0.8637134638483929,z:-0.06324054997098227}},{index_array:[10,11],face_index_array:[18,17],normal:{x:-0.3090171388247843,y:0.7115834672395087,z:-0.6309974266706189}}]},"sides":20}}

// Create inverse table
for die at name in _dice_DATA_TABLE:
    die.unmap = []
    for i at j in die.remap:
        die.unmap[i] = j
        
