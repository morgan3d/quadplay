/*
quad://scripts/cursor_lib.pyxl

Immediate mode GUI gamepad/mouse/touch cursor management routines
for selection, buttons, and scroll boxes.

Supports multiple cursors for multiplayer games or different modes.
However, if the mouse or touch moves it will move all cursors to that
location.

Does not handle overlapping GUI targets.

Copyright 2025, SHMUEL
<br>Open source under the MIT license
<br>https://opensource.org/licenses/MIT


Cursor management:

```````````````````````````````````````````````` PyxlScript
const cursor = make_cursor()

// Optional, if you don't need exact control
// of when the cursor code runs
add_frame_hook(cursor_make_hook(cursor))

// Will be called from cursor_update() when the (a)
// button or is pressed while the cursor is on this target.
def button_callback(data, cursor):
    // Do the thing
    debug_print("Button pressed")


//////////////////////////////////////////////////    
// Per frame:

const button = {pos: xy(100, 100), size: xy(50, 15), shape: "rect"}
cursor_register_target(cursor, button, button_callback);

…

// If you want to control the timing of the cursor processing,
// do this explicitly per frame instead of registering a hook.
cursor_update(cursor)

````````````````````````````````````````````````


Scrollbox management:

```````````````````````````````````````````````` PyxlScript
// Per frame:
preserving_transform:
    // Whatever you want it to be
    const scroll_rect = {corner: xy(0, 30), size: xy(SCREEN_SIZE.x, SCREEN_SIZE.y - 58)}

    set_clip(scroll_rect)
    set_transform(scroll_rect.corner - scroll.offset)

    // Whatever your code is for rendering the contents of the pane
    const content_size = draw_content()
    
    scroll_tracker_update(scroll, content_size, scroll_rect, if selected then ∅ else xy(0, 0))
````````````````````````````````````````````````
*/



/* 
Call once per frame for each UI target for the cursor.
  
Coordinates are relative to the current transform. 

`callback`
: Callback `callback(data, cursor)` runs if the (a) gamepad button is pressed on this target or
  there is a touch on the target. If `callback == ∅`, the cursor changes to show that no callback
  is allowed.

`hover_callback`
: Callback `hover_callback(data, cursor)` runs when this target is selected
  by gamepad navigation or mouse hover.

Sounds and visuals differ for the cursor based on which callbacks are set. If `callback` is
set, the target is activateable by pressing gamepad.pressed_a. Otherwise, the target may be used
for cursor traversal but is not selectable.

Returns `true` if the cursor is currently on this target this frame. Useful if you want
to render the item differently when selected instead of drawing the cursor on top
later with `cursor.draw`.

*/
def cursor_register_target(cursor, region, callback default ∅, data default ∅, hover_callback default ∅):
    assert(region)
    assert(region.pos)
    assert(region.size)
    
    // Transform pos and size to screen space
    let pos = xy(region.pos)
    let size = xy(region.size)
    const z = transform_ws_z_to_ss_z(region.pos.z default 0)
    const A = transform_ws_to_ss(pos + ½ size)
    const B = transform_ws_to_ss(pos - ½ size)
    pos = ½ (A + B)
    size = |B - A|
    const ss_z = transform_ws_z_to_ss_z(z)
    
    assert(not callback or type(callback) == "function")

    const target = {pos: pos, size: size, shape: region.shape default "rect", z: ss_z, callback: callback, data: data, hover_callback: hover_callback}
    if overlaps(target, {pos: ½ SCREEN_SIZE, size: SCREEN_SIZE}):
        // Only allow selection if actually on screen
        push(cursor._target_array, target)

    return overlaps(target, cursor.pos) or (touch.hover and overlaps(target, touch.hover))


/* Find closest target to `pos` that was declared this frame with 
   `cursor_register_target()`.

   - `allow_exact`: if true, allow distance 0 (for mouse), 
     otherwise exclude distance 0 (for controller)   
   - `dir`: Direction to search for the target. If ∅, consider all directions 
     and does not require an exact match.
  */
def cursor_find_closest_target(cursor, pos, dir):
    let closest_target = ∅
    let closest_distance = ∞
    
    for target in cursor._target_array:
        const v = target.pos - pos
        let d = ‖v‖
        
        // Favor those closest to the direction
        if dir: d /= dot(direction(v), dir) 
                        
        if (not dir or d > 0) and d < closest_distance:
            closest_distance = d
            closest_target = target
    
    return closest_target
    


/* Call once per frame after registering targets to update
   the cursor, process input, invoke callbacks, and render
   the selection/cursor. */
def cursor_update(cursor)
& with pos, gamepad in cursor
& preserving_transform:
    // Operate directly in screen space
    reset_camera()
    reset_transform()

    let old_pos = pos
    let changed = false
    
    // Process input:
    let target = ∅
    if gamepad.xx or gamepad.yy:
        const new_target = cursor_find_closest_target(cursor, pos, gamepad.xy)
        if new_target:
            if cursor.new_target_sound:
                play_sound({sound: cursor.new_target_sound, pan: new_target.pos})
            target = new_target
            changed = true
        else if cursor.bad_sound:
            play_sound({sound: cursor.bad_sound, pan: pos})
    
    if touch.hover or touch.pressed_a:
        const mouse_pos = touch.hover or touch.xy
        
        // Find target *under* mouse/touch
        const new_target = cursor_find_closest_target(cursor, mouse_pos)

        // Make sure the target is actually under the mouse
        // and not just nearby
        if new_target and overlaps(new_target, mouse_pos):
            // Only play sound if this is a change of target
            if XY_DISTANCE(cursor.pos, new_target.pos) > 1:
                changed = true
                if cursor.new_target_sound: play_sound({sound: cursor.new_target_sound, pan: new_target.pos})
            target = new_target
    
    if not target:
        // If here, no new user input was processed, so the target
        // remains whatever is currently under the cursor's position
        target = cursor_find_closest_target(cursor, pos)
        
    if target:
        // We have a target, move the cursor to it.
        // This is how selection persists between frames
        pos = xy(target.pos)

    changed = changed or (XY_DISTANCE(cursor.pos, old_pos) > 1)
    if target and changed and target.hover_callback:
        target.hover_callback(target.data, cursor)
        
    // Was there any request for callback 
    if target and target.callback:
        if gamepad.pressed_a:
            target.callback(target.data, cursor)
        else if touch.pressed_a:
            if overlaps(target, touch.xy):
                target.callback(target.data, cursor)
            else if cursor.bad_sound:
                play_sound({sound: cursor.bad_sound, pan: target.pos})
    
    // Wipe the UI targets in preparation for the next frame
    resize(cursor._target_array, 0)

    // Rendering
    if target and cursor.draw:
        cursor.draw(cursor, target)



/* Default cursor drawing function */
def cursor_draw_cursor(cursor, target):
    if not target: return

    const active_color   = lerp(#F0F, #FF0, oscillate(2 now()))
    const inactive_color = lerp(#FFF, #888, oscillate(2 now()))
    
    const color = if target.callback then active_color else inactive_color
    const cursor_z = 20

    const fill = if target.callback then rgba(color, 50%) else ∅

    if target.shape == "disk":
        draw_disk(target.pos, 0.5 + 25% (target.size.x + target.size.y), fill, color, cursor_z)
    else:
        draw_rect(target.pos, target.size, fill, color, ∅, cursor_z)


        
/* Creates a new cursor object for use with the other routines.
   Separate cursors can be created for different players with
   different gamepads, rendering routines, and sounds. 
   
   Set `draw = false` to avoid the default value.
   */
def make_cursor(
    pos default ½ SCREEN_SIZE,
    gamepad default gamepad_array[0],
    draw default cursor_draw_cursor,
    new_target_sound default ∅,
    bad_sound default ∅):
        
    return {
        pos: pos,
        gamepad: gamepad,
        draw: draw or ∅,
        
        new_target_sound: new_target_sound,
        bad_sound: bad_sound,
        
        /*
         Places the cursor can go. Refreshed every frame by 
         cursor_update().
        
         All coordinates stored in screen space.
         */
        _target_array: []}



/* Produces a frame hook that can be used with `add_frame_hook()` 
   by capturing the `cursor` variable. */
def cursor_make_hook(cursor):
    def hook(): cursor_update(cursor)
    return hook
    

///////////////////////////////////////////////////////////////////////////

todo("touch momentum")

/* On the returned `scroll` object, subtract the `scroll.offset` from your
   content's position to handle scrolling. Note that scrolling is 2D, 
   so you may want to select for just the `x` or `y` field. */
def make_scroll_tracker():
    return {
        offset: xy(0, 0),
        
        _drag_start: {
            // Position at which the current drag started,
            // ∅ if not in a drag
            pos: ∅,
            
            // offset when the drag started
            scroll: ∅}}


/* 
`screen_scroll_rect`
: Must be in screen space (like the argument to `set_clip()`)

`other_change`
: Use for auto-scrolling or gamepad scrolling (the default), or set to `xy(0, 0)` 
  to disable gamepad scrolling.
*/
def scroll_tracker_update(scroll, content_size, screen_scroll_rect, other_change default 3 joy.xy)
& preserving_transform:
    // Make sure we're reading the touch and mouse properties in screen space to
    // align with the screen_scroll_rect
    reset_transform()
    const MOUSE_SCROLL_RATE = 0.1
    
    const max_scroll = max(content_size - screen_scroll_rect.size, xy(0, 0))

    if not scroll._drag_start.pos:
        if touch.pressed_a and overlaps(touch.xy, screen_scroll_rect):
            // Start drag
            scroll._drag_start.pos = xy(touch.xy)
            scroll._drag_start.scroll = xy(scroll.offset)
    else if touch.a:
        // Continue drag
        scroll.offset = scroll._drag_start.scroll + scroll._drag_start.pos - touch.xy
    else:
        // End drag
        scroll._drag_start.pos = ∅
            
    const mouse = device_control("get_mouse_state")
    if (mouse.wheel.x ≠ 0 or mouse.wheel.y ≠ 0) and overlaps(screen_scroll_rect, mouse.xy):
        scroll.offset += device_control("get_mouse_state").wheel * MOUSE_SCROLL_RATE
    
    // Gamepad
    scroll.offset += other_change
    scroll.offset = clamp(scroll.offset, xy(0, 0), max_scroll)


